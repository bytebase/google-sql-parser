// Code generated from GoogleSQLParser.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // GoogleSQLParser
import (
	"fmt"
	"strconv"
  	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}


type GoogleSQLParser struct {
	*antlr.BaseParser
}

var GoogleSQLParserParserStaticData struct {
  once                   sync.Once
  serializedATN          []int32
  LiteralNames           []string
  SymbolicNames          []string
  RuleNames              []string
  PredictionContextCache *antlr.PredictionContextCache
  atn                    *antlr.ATN
  decisionToDFA          []*antlr.DFA
}

func googlesqlparserParserInit() {
  staticData := &GoogleSQLParserParserStaticData
  staticData.LiteralNames = []string{
    "", "'ARRAY'", "'ALL'", "'AS'", "'ASC'", "'BY'", "'CROSS'", "'JOIN'", 
    "'DELTA'", "'DESC'", "'DIFFERENTIAL_PRIVACY'", "'DISTINCT'", "'EPSILON'", 
    "'EXCEPT'", "'EXCLUDE'", "'FOR'", "'FROM'", "'FULL'", "'IN'", "'INCLUDE'", 
    "'INNER'", "'INTERSECT'", "'LEFT'", "'LIMIT'", "'MAX_GROUPS_CONTRIBUTED'", 
    "'NULL'", "'NULLS'", "'OF'", "'OFFSET'", "'ON'", "'OPTIONS'", "'ORDER'", 
    "'OUTER'", "'PERCENT'", "'PIVOT'", "'PRIVACY_UNIT_COLUMN'", "'RIGHT'", 
    "'RECURSIVE'", "'REPLACE'", "'UNPIVOT'", "'SELECT'", "'STRUCT'", "'SYSTEM'", 
    "'SYSTEM_TIME'", "'TABLESAMPLE'", "'UNION'", "'UNNEST'", "'USING'", 
    "'VALUE'", "'WITH'", "'TRUE'", "'FALSE'", "'NUMERIC'", "'DECIMAL'", 
    "'BIGNUMERIC'", "'BIGDECIMAL'", "'NOT'", "'AND'", "'OR'", "'JSON'", 
    "'DATE'", "'TIME'", "'DATETIME'", "'TIMESTAMP'", "'RANGE'", "'INTERVAL'", 
    "'SIMPLE'", "'ABORT'", "'ACCESS'", "'ACTION'", "'AGGREGATE'", "'ADD'", 
    "'ALTER'", "'ALWAYS'", "'ANALYZE'", "'APPROX'", "'ARE'", "'ASSERT'", 
    "'BATCH'", "'BEGIN'", "'BREAK'", "'CALL'", "'CASCADE'", "'CHECK'", "'CLAMPED'", 
    "'CLONE'", "'COPY'", "'CLUSTER'", "'COLUMN'", "'COLUMNS'", "'COMMIT'", 
    "'CONNECTION'", "'CONSTANT'", "'CONSTRAINT'", "'CONTINUE'", "'CORRESPONDING'", 
    "'CYCLE'", "'DATA'", "'DATABASE'", "'DECLARE'", "'DEFINER'", "'DELETE'", 
    "'DELETION'", "'DEPTH'", "'DESCRIBE'", "'DETERMINISTIC'", "'DO'", "'DROP'", 
    "'ELSEIF'", "'ENFORCED'", "'ERROR'", "'EXCEPTION'", "'EXECUTE'", "'EXPLAIN'", 
    "'EXPORT'", "'EXTEND'", "'EXTERNAL'", "'FILES'", "'FILTER'", "'FILL'", 
    "'FIRST'", "'FOREIGN'", "'FORMAT'", "'FUNCTION'", "'GENERATED'", "'GRANT'", 
    "'GROUP_ROWS'", "'HIDDEN'", "'IDENTITY'", "'IMMEDIATE'", "'IMMUTABLE'", 
    "'IMPORT'", "'INCREMENT'", "'INDEX'", "'INOUT'", "'INPUT'", "'INSERT'", 
    "'INVOKER'", "'ISOLATION'", "'ITERATE'", "'KEY'", "'LANGUAGE'", "'LAST'", 
    "'LEAVE'", "'LEVEL'", "'LOAD'", "'LOOP'", "'MACRO'", "'MAP'", "'MATCH'", 
    "'KW_MATCH_RECOGNIZE_NONRESERVED'", "'MATCHED'", "'MATERIALIZED'", "'MAX'", 
    "'MAXVALUE'", "'MEASURES'", "'MESSAGE'", "'METADATA'", "'MIN'", "'MINVALUE'", 
    "'MODEL'", "'MODULE'", "'ONLY'", "'OUT'", "'OUTPUT'", "'OVERWRITE'", 
    "'PARTITIONS'", "'PATTERN'", "'POLICIES'", "'POLICY'", "'PRIMARY'", 
    "'PRIVATE'", "'PRIVILEGE'", "'PRIVILEGES'", "'PROCEDURE'", "'PROJECT'", 
    "'PUBLIC'", "'RAISE'", "'READ'", "'REFERENCES'", "'REMOTE'", "'REMOVE'", 
    "'RENAME'", "'REPEAT'", "'REPEATABLE'", "'REPLACE_FIELDS'", "'REPLICA'", 
    "'REPORT'", "'RESTRICT'", "'RESTRICTION'", "'RETURNS'", "'RETURN'", 
    "'REVOKE'", "'ROLLBACK'", "'ROW'", "'RUN'", "'SAFE_CAST'", "'SCHEMA'", 
    "'SEARCH'", "'SECURITY'", "'SEQUENCE'", "'SETS'", "'SHOW'", "'SNAPSHOT'", 
    "'SOURCE'", "'SQL'", "'STABLE'", "'START'", "'STATIC_DESCRIBE'", "'STORED'", 
    "'STORING'", "'STRICT'", "'TABLE'", "'TABLES'", "'TARGET'", "'TEMP'", 
    "'TEMPORARY'", "'TRANSACTION'", "'TRANSFORM'", "'TRUNCATE'", "'TYPE'", 
    "'UNDROP'", "'UNIQUE'", "'UNKNOWN'", "'UNTIL'", "'UPDATE'", "'VALUES'", 
    "'VECTOR'", "'VIEW'", "'VIEWS'", "'VOLATILE'", "'WEIGHT'", "'WHILE'", 
    "'WRITE'", "'ZONE'", "'DESCRIPTOR'", "'INTERLEAVE'", "'NULL_FILTERED'", 
    "'PARENT'", "'NEW'", "'END'", "'CASE'", "'WHEN'", "'THEN'", "'ELSE'", 
    "'CAST'", "'EXTRACT'", "'COLLATE'", "'IF'", "'GROUPING'", "'HAVING'", 
    "'GROUP'", "'ROLLUP'", "'CUBE'", "'HASH'", "'PROTO'", "'PARTITION'", 
    "'IGNORE'", "'RESPECT'", "'ROWS'", "'OVER'", "'BETWEEN'", "'UNBOUNDED'", 
    "'CURRENT'", "'PRECEDING'", "'FOLLOWING'", "'NATURAL'", "'QUALIFY'", 
    "'DEFAULT'", "'SLASH'", "'MATCH_RECOGNIZE'", "'DEFINE'", "'LOOKUP'", 
    "'WHERE'", "'WINDOW'", "'TO'", "'EXISTS'", "'NOT_SPECIAL'", "'ANY'", 
    "'SOME'", "'LIKE'", "'*'", "','", "'.'", "'='", "'{'", "'}'", "'<'", 
    "'>'", "'('", "')'", "'['", "']'", "'|'", "':'", "';'", "'''", "'''''", 
    "'\"'", "'\"\"\"'", "'`'", "'-'", "'?'", "'@'", "'@@'", "'=>'", "'->'", 
    "'+='", "'-='", "'|>'",
  }
  staticData.SymbolicNames = []string{
    "", "ARRAY_SYMBOL", "ALL_SYMBOL", "AS_SYMBOL", "ASC_SYMBOL", "BY_SYMBOL", 
    "CROSS_SYMBOL", "JOIN_SYMBOL", "DELTA_SYMBOL", "DESC_SYMBOL", "DIFFERENTIAL_PRIVACY_SYMBOL", 
    "DISTINCT_SYMBOL", "EPSILON_SYMBOL", "EXCEPT_SYMBOL", "EXCLUDE_SYMBOL", 
    "FOR_SYMBOL", "FROM_SYMBOL", "FULL_SYMBOL", "IN_SYMBOL", "INCLUDE_SYMBOL", 
    "INNER_SYMBOL", "INTERSECT_SYMBOL", "LEFT_SYMBOL", "LIMIT_SYMBOL", "MAX_GROUPS_CONTRIBUTED_SYMBOL", 
    "NULL_SYMBOL", "NULLS_SYMBOL", "OF_SYMBOL", "OFFSET_SYMBOL", "ON_SYMBOL", 
    "OPTIONS_SYMBOL", "ORDER_SYMBOL", "OUTER_SYMBOL", "PERCENT_SYMBOL", 
    "PIVOT_SYMBOL", "PRIVACY_UNIT_COLUMN_SYMBOL", "RIGHT_SYMBOL", "RECURSIVE_SYMBOL", 
    "REPLACE_SYMBOL", "UNPIVOT_SYMBOL", "SELECT_SYMBOL", "STRUCT_SYMBOL", 
    "SYSTEM_SYMBOL", "SYSTEM_TIME_SYMBOL", "TABLESAMPLE_SYMBOL", "UNION_SYMBOL", 
    "UNNEST_SYMBOL", "USING_SYMBOL", "VALUE_SYMBOL", "WITH_SYMBOL", "TRUE_SYMBOL", 
    "FALSE_SYMBOL", "NUMERIC_SYMBOL", "DECIMAL_SYMBOL", "BIGNUMERIC_SYMBOL", 
    "BIGDECIMAL_SYMBOL", "NOT_SYMBOL", "AND_SYMBOL", "OR_SYMBOL", "JSON_SYMBOL", 
    "DATE_SYMBOL", "TIME_SYMBOL", "DATETIME_SYMBOL", "TIMESTAMP_SYMBOL", 
    "RANGE_SYMBOL", "INTERVAL_SYMBOL", "SIMPLE_SYMBOL", "ABORT_SYMBOL", 
    "ACCESS_SYMBOL", "ACTION_SYMBOL", "AGGREGATE_SYMBOL", "ADD_SYMBOL", 
    "ALTER_SYMBOL", "ALWAYS_SYMBOL", "ANALYZE_SYMBOL", "APPROX_SYMBOL", 
    "ARE_SYMBOL", "ASSERT_SYMBOL", "BATCH_SYMBOL", "BEGIN_SYMBOL", "BREAK_SYMBOL", 
    "CALL_SYMBOL", "CASCADE_SYMBOL", "CHECK_SYMBOL", "CLAMPED_SYMBOL", "CLONE_SYMBOL", 
    "COPY_SYMBOL", "CLUSTER_SYMBOL", "COLUMN_SYMBOL", "COLUMNS_SYMBOL", 
    "COMMIT_SYMBOL", "CONNECTION_SYMBOL", "CONSTANT_SYMBOL", "CONSTRAINT_SYMBOL", 
    "CONTINUE_SYMBOL", "CORRESPONDING_SYMBOL", "CYCLE_SYMBOL", "DATA_SYMBOL", 
    "DATABASE_SYMBOL", "DECLARE_SYMBOL", "DEFINER_SYMBOL", "DELETE_SYMBOL", 
    "DELETION_SYMBOL", "DEPTH_SYMBOL", "DESCRIBE_SYMBOL", "DETERMINISTIC_SYMBOL", 
    "DO_SYMBOL", "DROP_SYMBOL", "ELSEIF_SYMBOL", "ENFORCED_SYMBOL", "ERROR_SYMBOL", 
    "EXCEPTION_SYMBOL", "EXECUTE_SYMBOL", "EXPLAIN_SYMBOL", "EXPORT_SYMBOL", 
    "EXTEND_SYMBOL", "EXTERNAL_SYMBOL", "FILES_SYMBOL", "FILTER_SYMBOL", 
    "FILL_SYMBOL", "FIRST_SYMBOL", "FOREIGN_SYMBOL", "FORMAT_SYMBOL", "FUNCTION_SYMBOL", 
    "GENERATED_SYMBOL", "GRANT_SYMBOL", "GROUP_ROWS_SYMBOL", "HIDDEN_SYMBOL", 
    "IDENTITY_SYMBOL", "IMMEDIATE_SYMBOL", "IMMUTABLE_SYMBOL", "IMPORT_SYMBOL", 
    "INCREMENT_SYMBOL", "INDEX_SYMBOL", "INOUT_SYMBOL", "INPUT_SYMBOL", 
    "INSERT_SYMBOL", "INVOKER_SYMBOL", "ISOLATION_SYMBOL", "ITERATE_SYMBOL", 
    "KEY_SYMBOL", "LANGUAGE_SYMBOL", "LAST_SYMBOL", "LEAVE_SYMBOL", "LEVEL_SYMBOL", 
    "LOAD_SYMBOL", "LOOP_SYMBOL", "MACRO_SYMBOL", "MAP_SYMBOL", "MATCH_SYMBOL", 
    "KW_MATCH_RECOGNIZE_NONRESERVED_SYMBOL", "MATCHED_SYMBOL", "MATERIALIZED_SYMBOL", 
    "MAX_SYMBOL", "MAXVALUE_SYMBOL", "MEASURES_SYMBOL", "MESSAGE_SYMBOL", 
    "METADATA_SYMBOL", "MIN_SYMBOL", "MINVALUE_SYMBOL", "MODEL_SYMBOL", 
    "MODULE_SYMBOL", "ONLY_SYMBOL", "OUT_SYMBOL", "OUTPUT_SYMBOL", "OVERWRITE_SYMBOL", 
    "PARTITIONS_SYMBOL", "PATTERN_SYMBOL", "POLICIES_SYMBOL", "POLICY_SYMBOL", 
    "PRIMARY_SYMBOL", "PRIVATE_SYMBOL", "PRIVILEGE_SYMBOL", "PRIVILEGES_SYMBOL", 
    "PROCEDURE_SYMBOL", "PROJECT_SYMBOL", "PUBLIC_SYMBOL", "RAISE_SYMBOL", 
    "READ_SYMBOL", "REFERENCES_SYMBOL", "REMOTE_SYMBOL", "REMOVE_SYMBOL", 
    "RENAME_SYMBOL", "REPEAT_SYMBOL", "REPEATABLE_SYMBOL", "REPLACE_FIELDS_SYMBOL", 
    "REPLICA_SYMBOL", "REPORT_SYMBOL", "RESTRICT_SYMBOL", "RESTRICTION_SYMBOL", 
    "RETURNS_SYMBOL", "RETURN_SYMBOL", "REVOKE_SYMBOL", "ROLLBACK_SYMBOL", 
    "ROW_SYMBOL", "RUN_SYMBOL", "SAFE_CAST_SYMBOL", "SCHEMA_SYMBOL", "SEARCH_SYMBOL", 
    "SECURITY_SYMBOL", "SEQUENCE_SYMBOL", "SETS_SYMBOL", "SHOW_SYMBOL", 
    "SNAPSHOT_SYMBOL", "SOURCE_SYMBOL", "SQL_SYMBOL", "STABLE_SYMBOL", "START_SYMBOL", 
    "STATIC_DESCRIBE_SYMBOL", "STORED_SYMBOL", "STORING_SYMBOL", "STRICT_SYMBOL", 
    "TABLE_SYMBOL", "TABLES_SYMBOL", "TARGET_SYMBOL", "TEMP_SYMBOL", "TEMPORARY_SYMBOL", 
    "TRANSACTION_SYMBOL", "TRANSFORM_SYMBOL", "TRUNCATE_SYMBOL", "TYPE_SYMBOL", 
    "UNDROP_SYMBOL", "UNIQUE_SYMBOL", "UNKNOWN_SYMBOL", "UNTIL_SYMBOL", 
    "UPDATE_SYMBOL", "VALUES_SYMBOL", "VECTOR_SYMBOL", "VIEW_SYMBOL", "VIEWS_SYMBOL", 
    "VOLATILE_SYMBOL", "WEIGHT_SYMBOL", "WHILE_SYMBOL", "WRITE_SYMBOL", 
    "ZONE_SYMBOL", "DESCRIPTOR_SYMBOL", "INTERLEAVE_SYMBOL", "NULL_FILTERED_SYMBOL", 
    "PARENT_SYMBOL", "NEW_SYMBOL", "END_SYMBOL", "CASE_SYMBOL", "WHEN_SYMBOL", 
    "THEN_SYMBOL", "ELSE_SYMBOL", "CAST_SYMBOL", "EXTRACT_SYMBOL", "COLLATE_SYMBOL", 
    "IF_SYMBOL", "GROUPING_SYMBOL", "HAVING_SYMBOL", "GROUP_SYMBOL", "ROLLUP_SYMBOL", 
    "CUBE_SYMBOL", "HASH_SYMBOL", "PROTO_SYMBOL", "PARTITION_SYMBOL", "IGNORE_SYMBOL", 
    "RESPECT_SYMBOL", "ROWS_SYMBOL", "OVER_SYMBOL", "BETWEEN_SYMBOL", "UNBOUNDED_SYMBOL", 
    "CURRENT_SYMBOL", "PRECEDING_SYMBOL", "FOLLOWING_SYMBOL", "NATURAL_SYMBOL", 
    "QUALIFY_SYMBOL", "DEFAULT_SYMBOL", "SLASH_SYMBOL", "MATCH_RECOGNIZE_SYMBOL", 
    "DEFINE_SYMBOL", "LOOKUP_SYMBOL", "WHERE_SYMBOL", "WINDOW_SYMBOL", "TO_SYMBOL", 
    "EXISTS_SYMBOL", "NOT_SPECIAL_SYMBOL", "ANY_SYMBOL", "SOME_SYMBOL", 
    "LIKE_SYMBOL", "ASTERISK_SYMBOL", "COMMA_SYMBOL", "DOT_SYMBOL", "EQUAL_SYMBOL", 
    "LC_BRACKET_SYMBOL", "RC_BRACKET_SYMBOL", "LT_BRACKET_SYMBOL", "GT_BRACKET_SYMBOL", 
    "LR_BRACKET_SYMBOL", "RR_BRACKET_SYMBOL", "LS_BRACKET_SYMBOL", "RS_BRACKET_SYMBOL", 
    "STROKE_SYMBOL", "COLON_SYMBOL", "SEMI_SYMBOL", "SINGLE_QUOTE_SYMBOL", 
    "SINGLE_QUOTE_3_SYMBOL", "DOUBLE_QUOTE_SYMBOL", "DOUBLE_QUOTE_3_SYMBOL", 
    "BACKQUOTE_SYMBOL", "DASH_SYMBOL", "QUESTION_SYMBOL", "AT_SYMBOL", "ATAT_SYMBOL", 
    "EQUAL_GT_BRACKET_SYMBOL", "SUB_GT_BRACKET_SYMBOL", "PLUS_EQUAL_SYMBOL", 
    "SUB_EQUAL_SYMBOL", "PIPE_SYMBOL", "QUOTED_ID", "ID", "INT", "FLOAT", 
    "STRING_LITERAL", "BYTES_LITERAL", "UNCLOSED_STRING_LITERAL", "UNCLOSED_TRIPLE_QUOTED_STRING_LITERAL", 
    "UNCLOSED_RAW_STRING_LITERAL", "UNCLOSED_TRIPLE_QUOTED_RAW_STRING_LITERAL", 
    "UNCLOSED_BYTES_LITERAL", "UNCLOSED_TRIPLE_QUOTED_BYTES_LITERAL", "UNCLOSED_RAW_BYTES_LITERAL", 
    "UNCLOSED_TRIPLE_QUOTED_RAW_BYTES_LITERAL", "INTEGER_LITERAL", "IDENTIFIER", 
    "UNCLOSED_ESCAPED_IDENTIFIER", "WHITESPACE",
  }
  staticData.RuleNames = []string{
    "root", "stmts", "stmt", "query_statement", "query", "query_without_pipe_operators", 
    "bad_keyword_after_from_query", "bad_keyword_after_from_query_allows_parens", 
    "with_clause_with_trailing_comma", "select_or_from_keyword", "query_primary_or_set_operation", 
    "query_set_operation", "query_set_operation_prefix", "query_primary", 
    "set_operation_metadata", "opt_column_match_suffix", "opt_strict", "all_or_distinct", 
    "query_set_operation_type", "opt_corresponding_outer_mode", "opt_outer", 
    "with_clause", "aliased_query", "opt_aliased_query_modifiers", "recursion_depth_modifier", 
    "possibly_unbounded_int_literal_or_parameter", "int_literal_or_parameter", 
    "limit_clause", "order_by_clause", "order_by_clause_prefix", "ordering_expression", 
    "order_by_expr_list", "order_by_expr_list_item", "set_operator", "select", 
    "opt_clauses_following_from", "opt_clauses_following_where", "opt_clauses_following_group_by", 
    "window_clause", "window_clause_prefix", "window_definition", "where_clause", 
    "having_clause", "group_by_clause", "group_by_all", "select_clause", 
    "opt_select_as_clause", "opt_select_with", "from_clause", "from_clause_contents", 
    "table_primary", "tvf_with_suffixes", "pivot_or_unpivot_clause_and_aliases", 
    "sample_clause", "opt_sample_clause_suffix", "repeatable_clause", "possibly_cast_int_literal_or_parameter", 
    "cast_int_literal_or_parameter", "sample_size", "sample_size_value", 
    "sample_size_unit", "partition_by_clause_prefix_no_hint", "match_recognize_clause", 
    "row_pattern_expr", "row_pattern_concatenation", "row_pattern_factor", 
    "select_list_prefix_with_as_aliases", "select_column_expr_with_as_alias", 
    "table_subquery", "join", "join_item", "on_or_using_clause_list", "on_or_using_clause", 
    "join_hint", "table_path_expression", "opt_at_system_time", "opt_with_offset_and_alias", 
    "opt_pivot_or_unpivot_clause_and_alias", "table_path_expression_base", 
    "maybe_slashed_or_dashed_path_expression", "maybe_dashed_path_expression", 
    "dashed_path_expression", "dashed_identifier", "slashed_identifier", 
    "identifier_or_integer", "slashed_identifier_separator", "slashed_path_expression", 
    "unnest_expression", "unnest_expression_prefix", "opt_array_zip_mode", 
    "expression_with_opt_alias", "tvf_prefix", "tvf_argument", "connection_clause", 
    "path_expression_or_default", "descriptor_argument", "descriptor_column_list", 
    "descriptor_column", "table_clause", "model_clause", "qualify_clause_nonreserved", 
    "unpivot_clause", "unpivot_in_item_list", "unpivot_in_item_list_prefix", 
    "unpivot_in_item", "opt_as_string_or_integer", "path_expression_list_with_opt_parens", 
    "path_expression_list", "unpivot_nulls_filter", "pivot_clause", "pivot_expression_list", 
    "pivot_expression", "pivot_value_list", "pivot_value", "tvf_prefix_no_args", 
    "join_type", "opt_natural", "tablesample_operator", "unpivot_operator", 
    "single_column_unpivot", "multi_column_unpivot", "values_column_set", 
    "columns_to_unpivot_list", "columns_to_unpivot_item", "column_sets_to_unpivot", 
    "pivot_operator", "pivot_column_as_alias_list", "pivot_column_as_alias_list_item", 
    "aggregate_function_call_as_alias_list", "aggregate_function_call_as_alias_list_item", 
    "from_item", "unnest_operator", "cross_join_operator", "conditional_join_operator", 
    "join_condition", "on_clause", "using_clause", "select_list", "select_list_item", 
    "select_expression", "select_all", "select_all_except_clause", "select_all_replace_clause", 
    "column_name_list", "expr_as_alias_list", "expr_as_alias_item", "as_alias", 
    "differential_privacy_clause", "privacy_parameters", "with_statement", 
    "cte", "non_recursive_cte", "recursive_cte", "recursive_union_operation", 
    "base_term", "union_operator", "recursive_term", "expression", "expression_higher_prec_than_and", 
    "parenthesized_query", "parenthesized_expression_not_a_query", "expression_maybe_parenthesized_not_a_query", 
    "and_expression", "unparenthesized_expression_higher_prec_than_and", 
    "parenthesized_anysomeall_list_in_rhs", "in_list_two_or_more_prefix", 
    "any_some_all", "like_operator", "expression_subquery_with_keyword", 
    "struct_constructor", "struct_constructor_prefix_with_keyword", "struct_constructor_arg", 
    "struct_constructor_prefix_without_keyword", "struct_constructor_prefix_with_keyword_no_arg", 
    "interval_expression", "function_call_expression_with_clauses", "function_call_expression", 
    "over_clause", "window_specification", "opt_window_frame_clause", "window_frame_bound", 
    "preceding_or_following", "frame_unit", "partition_by_clause", "partition_by_clause_prefix", 
    "with_group_rows", "with_report_modifier", "clamped_between_modifier", 
    "with_report_format", "options_list", "options_list_prefix", "options_entry", 
    "expression_or_proto", "options_assignment_operator", "opt_null_handling_modifier", 
    "function_call_expression_with_args_prefix", "function_call_argument", 
    "sequence_arg", "named_argument", "lambda_argument", "lambda_argument_list", 
    "limit_offset_clause", "opt_having_or_group_by_modifier", "group_by_clause_prefix", 
    "group_by_preamble", "opt_and_order", "hint", "hint_with_body", "hint_with_body_prefix", 
    "hint_entry", "identifier_in_hints", "extra_identifier_in_hints_name", 
    "grouping_item", "grouping_set_list", "grouping_set", "cube_list", "rollup_list", 
    "opt_as_alias_with_required_as", "opt_grouping_item_order", "opt_selection_item_order", 
    "asc_or_desc", "null_order", "function_call_expression_base", "function_name_from_keyword", 
    "replace_fields_expression", "replace_fields_prefix", "replace_fields_arg", 
    "generalized_path_expression", "generalized_extension_path", "with_expression", 
    "with_expression_variable_prefix", "with_expression_variable", "extract_expression", 
    "extract_expression_base", "opt_format", "opt_at_time_zone", "cast_expression", 
    "case_expression", "case_expression_prefix", "case_value_expression_prefix", 
    "case_no_value_expression_prefix", "struct_braced_constructor", "braced_new_constructor", 
    "braced_constructor", "braced_constructor_start", "braced_constructor_prefix", 
    "braced_constructor_field", "braced_constructor_lhs", "braced_constructor_field_value", 
    "braced_constructor_extension", "new_constructor", "new_constructor_prefix", 
    "new_constructor_prefix_no_arg", "new_constructor_arg", "array_constructor", 
    "array_constructor_prefix", "array_constructor_prefix_no_expressions", 
    "range_literal", "range_type", "type", "collate_clause", "string_literal_or_parameter", 
    "system_variable_expression", "parameter_expression", "named_parameter_expression", 
    "opt_type_parameters", "type_parameters_prefix", "type_parameter", "raw_type", 
    "map_type", "function_type", "function_type_prefix", "type_name", "path_expression", 
    "identifier", "keyword_as_identifier", "common_keyword_as_identifier", 
    "token_identifier", "struct_type", "array_type", "template_type_open", 
    "template_type_close", "date_or_time_literal", "date_or_time_literal_kind", 
    "floating_point_literal", "json_literal", "bignumeric_literal", "bignumeric_literal_prefix", 
    "numeric_literal", "numeric_literal_prefix", "integer_literal", "bytes_literal", 
    "null_literal", "boolean_literal", "string_literal", "string_literal_component", 
    "bytes_literal_component", "count", "skip_rows", "name", "cte_name", 
    "column_name", "alias_name", "table_name", "number", "integer_type", 
    "float_type",
  }
  staticData.PredictionContextCache = antlr.NewPredictionContextCache()
  staticData.serializedATN = []int32{
	4, 1, 327, 3092, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 
	7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 
	7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 
	15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 
	2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 
	26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 
	7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 
	36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 
	2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 
	47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 
	7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 
	57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 
	2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 
	68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 
	7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 
	78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 
	2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 
	89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 
	7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7, 
	99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2, 
	104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7, 
	108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2, 
	113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7, 
	117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2, 
	122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7, 
	126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2, 
	131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7, 
	135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2, 
	140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7, 
	144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2, 
	149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7, 
	153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2, 
	158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7, 
	162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2, 
	167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7, 
	171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2, 
	176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7, 
	180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2, 
	185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7, 
	189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2, 
	194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7, 
	198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2, 
	203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7, 
	207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2, 
	212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7, 
	216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2, 
	221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7, 
	225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2, 
	230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7, 
	234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2, 
	239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7, 
	243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2, 
	248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7, 
	252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2, 
	257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7, 
	261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2, 
	266, 7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7, 
	270, 2, 271, 7, 271, 2, 272, 7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2, 
	275, 7, 275, 2, 276, 7, 276, 2, 277, 7, 277, 2, 278, 7, 278, 2, 279, 7, 
	279, 2, 280, 7, 280, 2, 281, 7, 281, 2, 282, 7, 282, 2, 283, 7, 283, 2, 
	284, 7, 284, 2, 285, 7, 285, 2, 286, 7, 286, 2, 287, 7, 287, 2, 288, 7, 
	288, 2, 289, 7, 289, 2, 290, 7, 290, 2, 291, 7, 291, 2, 292, 7, 292, 2, 
	293, 7, 293, 2, 294, 7, 294, 2, 295, 7, 295, 2, 296, 7, 296, 2, 297, 7, 
	297, 2, 298, 7, 298, 2, 299, 7, 299, 2, 300, 7, 300, 2, 301, 7, 301, 2, 
	302, 7, 302, 2, 303, 7, 303, 2, 304, 7, 304, 2, 305, 7, 305, 2, 306, 7, 
	306, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 5, 1, 621, 8, 1, 10, 1, 12, 1, 
	624, 9, 1, 1, 1, 3, 1, 627, 8, 1, 1, 2, 1, 2, 1, 3, 1, 3, 1, 4, 1, 4, 1, 
	5, 1, 5, 1, 5, 3, 5, 638, 8, 5, 1, 5, 3, 5, 641, 8, 5, 1, 5, 1, 5, 1, 5, 
	1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 653, 8, 5, 1, 5, 3, 5, 
	656, 8, 5, 1, 5, 3, 5, 659, 8, 5, 1, 5, 1, 5, 3, 5, 663, 8, 5, 1, 5, 1, 
	5, 1, 5, 1, 5, 1, 5, 3, 5, 670, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 676, 
	8, 5, 1, 6, 1, 6, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 9, 1, 9, 1, 10, 1, 10, 
	3, 10, 689, 8, 10, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 
	12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 703, 8, 12, 1, 12, 1, 12, 1, 12, 
	1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 5, 12, 714, 8, 12, 10, 12, 12, 
	12, 717, 9, 12, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 723, 8, 13, 1, 14, 3, 
	14, 726, 8, 14, 1, 14, 1, 14, 3, 14, 730, 8, 14, 1, 14, 1, 14, 3, 14, 734, 
	8, 14, 1, 14, 3, 14, 737, 8, 14, 1, 15, 1, 15, 1, 15, 3, 15, 742, 8, 15, 
	1, 16, 1, 16, 1, 17, 1, 17, 1, 18, 1, 18, 1, 19, 1, 19, 3, 19, 752, 8, 
	19, 1, 19, 1, 19, 1, 19, 3, 19, 757, 8, 19, 3, 19, 759, 8, 19, 1, 20, 1, 
	20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 769, 8, 21, 1, 21, 
	1, 21, 1, 21, 5, 21, 774, 8, 21, 10, 21, 12, 21, 777, 9, 21, 1, 22, 1, 
	22, 1, 22, 1, 22, 3, 22, 783, 8, 22, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 
	3, 24, 790, 8, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 
	24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 806, 8, 24, 1, 25, 
	1, 25, 3, 25, 810, 8, 25, 1, 26, 1, 26, 1, 26, 3, 26, 815, 8, 26, 1, 27, 
	1, 27, 1, 27, 1, 27, 1, 27, 1, 28, 1, 28, 1, 29, 1, 29, 3, 29, 826, 8, 
	29, 1, 29, 1, 29, 1, 29, 1, 29, 5, 29, 832, 8, 29, 10, 29, 12, 29, 835, 
	9, 29, 1, 30, 1, 30, 3, 30, 839, 8, 30, 1, 30, 3, 30, 842, 8, 30, 1, 30, 
	3, 30, 845, 8, 30, 1, 31, 1, 31, 1, 31, 5, 31, 850, 8, 31, 10, 31, 12, 
	31, 853, 9, 31, 1, 32, 1, 32, 3, 32, 857, 8, 32, 1, 33, 1, 33, 1, 33, 1, 
	33, 1, 33, 1, 33, 3, 33, 865, 8, 33, 1, 34, 1, 34, 3, 34, 869, 8, 34, 1, 
	34, 1, 34, 1, 35, 1, 35, 3, 35, 875, 8, 35, 1, 35, 3, 35, 878, 8, 35, 1, 
	35, 3, 35, 881, 8, 35, 1, 35, 3, 35, 884, 8, 35, 1, 35, 3, 35, 887, 8, 
	35, 1, 36, 1, 36, 3, 36, 891, 8, 36, 1, 36, 3, 36, 894, 8, 36, 1, 36, 3, 
	36, 897, 8, 36, 1, 36, 3, 36, 900, 8, 36, 1, 37, 3, 37, 903, 8, 37, 1, 
	37, 3, 37, 906, 8, 37, 1, 37, 3, 37, 909, 8, 37, 1, 37, 3, 37, 912, 8, 
	37, 1, 37, 3, 37, 915, 8, 37, 3, 37, 917, 8, 37, 1, 38, 1, 38, 1, 39, 1, 
	39, 1, 39, 1, 39, 5, 39, 925, 8, 39, 10, 39, 12, 39, 928, 9, 39, 1, 40, 
	1, 40, 1, 40, 1, 40, 1, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 43, 1, 
	43, 3, 43, 942, 8, 43, 1, 44, 1, 44, 1, 44, 1, 45, 1, 45, 3, 45, 949, 8, 
	45, 1, 45, 3, 45, 952, 8, 45, 1, 45, 3, 45, 955, 8, 45, 1, 45, 3, 45, 958, 
	8, 45, 1, 45, 1, 45, 1, 45, 3, 45, 963, 8, 45, 1, 45, 3, 45, 966, 8, 45, 
	1, 45, 3, 45, 969, 8, 45, 1, 45, 3, 45, 972, 8, 45, 1, 45, 1, 45, 3, 45, 
	976, 8, 45, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 982, 8, 46, 1, 47, 1, 47, 
	1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 991, 8, 47, 1, 48, 1, 48, 1, 
	48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 1004, 
	8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 1011, 8, 49, 1, 49, 3, 
	49, 1014, 8, 49, 1, 49, 5, 49, 1017, 8, 49, 10, 49, 12, 49, 1020, 9, 49, 
	1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 1030, 8, 
	50, 1, 50, 1, 50, 1, 50, 1, 50, 5, 50, 1036, 8, 50, 10, 50, 12, 50, 1039, 
	9, 50, 1, 51, 1, 51, 1, 51, 3, 51, 1044, 8, 51, 1, 51, 3, 51, 1047, 8, 
	51, 1, 51, 1, 51, 1, 51, 3, 51, 1052, 8, 51, 1, 51, 3, 51, 1055, 8, 51, 
	3, 51, 1057, 8, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 
	52, 1066, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1072, 8, 52, 1, 52, 
	1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 
	52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1093, 8, 52, 
	1, 52, 1, 52, 3, 52, 1097, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1102, 8, 
	52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 
	1, 54, 3, 54, 1115, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 1121, 8, 
	54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 1128, 8, 54, 3, 54, 1130, 
	8, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56, 3, 56, 1139, 8, 
	56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 1147, 8, 57, 1, 57, 
	1, 57, 1, 58, 1, 58, 1, 58, 3, 58, 1154, 8, 58, 1, 59, 1, 59, 3, 59, 1158, 
	8, 59, 1, 60, 1, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 5, 61, 1167, 8, 
	61, 10, 61, 12, 61, 1170, 9, 61, 1, 62, 1, 62, 1, 62, 3, 62, 1175, 8, 62, 
	1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 
	62, 3, 62, 1188, 8, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 5, 63, 
	1196, 8, 63, 10, 63, 12, 63, 1199, 9, 63, 1, 64, 1, 64, 1, 64, 1, 64, 1, 
	64, 5, 64, 1206, 8, 64, 10, 64, 12, 64, 1209, 9, 64, 1, 65, 1, 65, 1, 65, 
	1, 65, 1, 65, 3, 65, 1216, 8, 65, 1, 66, 1, 66, 1, 66, 5, 66, 1221, 8, 
	66, 10, 66, 12, 66, 1224, 9, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 68, 1, 
	68, 3, 68, 1232, 8, 68, 1, 69, 1, 69, 5, 69, 1236, 8, 69, 10, 69, 12, 69, 
	1239, 9, 69, 1, 70, 3, 70, 1242, 8, 70, 1, 70, 1, 70, 3, 70, 1246, 8, 70, 
	1, 70, 1, 70, 3, 70, 1250, 8, 70, 1, 70, 1, 70, 3, 70, 1254, 8, 70, 1, 
	71, 4, 71, 1257, 8, 71, 11, 71, 12, 71, 1258, 1, 72, 1, 72, 3, 72, 1263, 
	8, 72, 1, 73, 1, 73, 1, 74, 1, 74, 3, 74, 1269, 8, 74, 1, 74, 3, 74, 1272, 
	8, 74, 1, 74, 3, 74, 1275, 8, 74, 1, 74, 3, 74, 1278, 8, 74, 1, 75, 1, 
	75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 
	1291, 8, 75, 1, 76, 1, 76, 1, 76, 3, 76, 1296, 8, 76, 1, 77, 1, 77, 1, 
	77, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 1305, 8, 77, 1, 77, 1, 77, 1, 77, 
	1, 77, 3, 77, 1311, 8, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 
	77, 1, 77, 3, 77, 1321, 8, 77, 1, 77, 1, 77, 1, 77, 3, 77, 1326, 8, 77, 
	1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 1334, 8, 77, 1, 77, 1, 
	77, 3, 77, 1338, 8, 77, 1, 77, 1, 77, 1, 77, 3, 77, 1343, 8, 77, 1, 78, 
	1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 
	78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 1365, 
	8, 78, 1, 79, 1, 79, 3, 79, 1369, 8, 79, 1, 80, 1, 80, 3, 80, 1373, 8, 
	80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 5, 81, 1381, 8, 81, 10, 81, 
	12, 81, 1384, 9, 81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 
	82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 3, 82, 1400, 8, 82, 1, 82, 
	1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 5, 
	82, 1413, 8, 82, 10, 82, 12, 82, 1416, 9, 82, 1, 83, 1, 83, 1, 83, 1, 83, 
	1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 5, 
	83, 1432, 8, 83, 10, 83, 12, 83, 1435, 9, 83, 1, 84, 1, 84, 3, 84, 1439, 
	8, 84, 1, 85, 1, 85, 1, 85, 1, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 
	86, 3, 86, 1451, 8, 86, 1, 87, 1, 87, 3, 87, 1455, 8, 87, 1, 87, 1, 87, 
	1, 87, 1, 87, 1, 87, 1, 87, 3, 87, 1463, 8, 87, 1, 88, 1, 88, 1, 88, 1, 
	88, 1, 88, 5, 88, 1470, 8, 88, 10, 88, 12, 88, 1473, 9, 88, 1, 89, 1, 89, 
	1, 89, 1, 90, 1, 90, 3, 90, 1480, 8, 90, 1, 91, 1, 91, 1, 91, 1, 91, 5, 
	91, 1486, 8, 91, 10, 91, 12, 91, 1489, 9, 91, 1, 92, 1, 92, 1, 92, 1, 92, 
	1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 
	92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 
	1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1521, 8, 92, 1, 93, 1, 93, 1, 
	93, 1, 94, 1, 94, 3, 94, 1528, 8, 94, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 
	1, 96, 1, 96, 1, 96, 5, 96, 1538, 8, 96, 10, 96, 12, 96, 1541, 9, 96, 1, 
	97, 1, 97, 1, 98, 1, 98, 1, 98, 1, 98, 3, 98, 1549, 8, 98, 1, 99, 1, 99, 
	1, 99, 1, 100, 1, 100, 1, 100, 1, 101, 1, 101, 3, 101, 1559, 8, 101, 1, 
	101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 102, 1, 
	102, 1, 102, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 5, 
	103, 1579, 8, 103, 10, 103, 12, 103, 1582, 9, 103, 1, 104, 1, 104, 3, 104, 
	1586, 8, 104, 1, 105, 3, 105, 1589, 8, 105, 1, 105, 1, 105, 3, 105, 1593, 
	8, 105, 1, 105, 3, 105, 1596, 8, 105, 1, 106, 1, 106, 1, 106, 1, 106, 1, 
	106, 3, 106, 1603, 8, 106, 1, 107, 1, 107, 1, 107, 5, 107, 1608, 8, 107, 
	10, 107, 12, 107, 1611, 9, 107, 1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 
	1617, 8, 108, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 
	109, 1, 109, 1, 109, 1, 109, 1, 110, 1, 110, 1, 110, 5, 110, 1633, 8, 110, 
	10, 110, 12, 110, 1636, 9, 110, 1, 111, 1, 111, 3, 111, 1640, 8, 111, 1, 
	112, 1, 112, 1, 112, 5, 112, 1645, 8, 112, 10, 112, 12, 112, 1648, 9, 112, 
	1, 113, 1, 113, 3, 113, 1652, 8, 113, 1, 114, 1, 114, 1, 114, 3, 114, 1657, 
	8, 114, 1, 115, 1, 115, 1, 115, 3, 115, 1662, 8, 115, 1, 115, 1, 115, 1, 
	115, 3, 115, 1667, 8, 115, 1, 115, 1, 115, 3, 115, 1671, 8, 115, 3, 115, 
	1673, 8, 115, 1, 116, 1, 116, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 
	117, 1, 117, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 3, 118, 1689, 8, 118, 
	1, 118, 1, 118, 1, 118, 3, 118, 1694, 8, 118, 1, 118, 3, 118, 1697, 8, 
	118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 
	120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 121, 1, 
	121, 1, 121, 5, 121, 1718, 8, 121, 10, 121, 12, 121, 1721, 9, 121, 1, 122, 
	1, 122, 1, 122, 5, 122, 1726, 8, 122, 10, 122, 12, 122, 1729, 9, 122, 1, 
	123, 1, 123, 3, 123, 1733, 8, 123, 1, 124, 1, 124, 1, 124, 1, 124, 1, 125, 
	1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 
	1, 125, 3, 125, 1750, 8, 125, 1, 126, 1, 126, 1, 126, 5, 126, 1755, 8, 
	126, 10, 126, 12, 126, 1758, 9, 126, 1, 127, 1, 127, 3, 127, 1762, 8, 127, 
	1, 128, 1, 128, 1, 128, 5, 128, 1767, 8, 128, 10, 128, 12, 128, 1770, 9, 
	128, 1, 129, 3, 129, 1773, 8, 129, 1, 130, 1, 130, 1, 130, 3, 130, 1778, 
	8, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 3, 130, 1785, 8, 130, 1, 
	130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 
	130, 3, 130, 1797, 8, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 
	3, 130, 1805, 8, 130, 1, 130, 1, 130, 1, 130, 3, 130, 1810, 8, 130, 3, 
	130, 1812, 8, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 
	1, 130, 1, 130, 5, 130, 1823, 8, 130, 10, 130, 12, 130, 1826, 9, 130, 1, 
	131, 1, 131, 1, 131, 1, 131, 3, 131, 1832, 8, 131, 1, 131, 3, 131, 1835, 
	8, 131, 1, 131, 1, 131, 1, 131, 3, 131, 1840, 8, 131, 3, 131, 1842, 8, 
	131, 1, 132, 1, 132, 1, 132, 3, 132, 1847, 8, 132, 1, 133, 3, 133, 1850, 
	8, 133, 1, 133, 1, 133, 1, 133, 3, 133, 1855, 8, 133, 1, 133, 1, 133, 1, 
	133, 3, 133, 1860, 8, 133, 1, 133, 1, 133, 1, 133, 3, 133, 1865, 8, 133, 
	1, 133, 3, 133, 1868, 8, 133, 1, 134, 1, 134, 3, 134, 1872, 8, 134, 1, 
	135, 1, 135, 1, 135, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 137, 1, 
	137, 1, 137, 5, 137, 1885, 8, 137, 10, 137, 12, 137, 1888, 9, 137, 1, 138, 
	1, 138, 3, 138, 1892, 8, 138, 1, 139, 1, 139, 3, 139, 1896, 8, 139, 1, 
	140, 1, 140, 1, 140, 3, 140, 1901, 8, 140, 1, 140, 1, 140, 3, 140, 1905, 
	8, 140, 1, 140, 3, 140, 1908, 8, 140, 1, 141, 1, 141, 1, 141, 1, 141, 1, 
	141, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 143, 1, 143, 1, 143, 5, 
	143, 1923, 8, 143, 10, 143, 12, 143, 1926, 9, 143, 1, 144, 1, 144, 1, 144, 
	5, 144, 1931, 8, 144, 10, 144, 12, 144, 1934, 9, 144, 1, 145, 1, 145, 3, 
	145, 1938, 8, 145, 1, 145, 1, 145, 1, 146, 3, 146, 1943, 8, 146, 1, 146, 
	1, 146, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 148, 
	1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 
	1, 148, 1, 148, 1, 148, 3, 148, 1967, 8, 148, 1, 148, 1, 148, 1, 148, 1, 
	148, 1, 149, 1, 149, 3, 149, 1975, 8, 149, 1, 149, 1, 149, 1, 149, 5, 149, 
	1980, 8, 149, 10, 149, 12, 149, 1983, 9, 149, 1, 150, 1, 150, 3, 150, 1987, 
	8, 150, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 152, 1, 152, 
	1, 152, 1, 152, 1, 152, 1, 152, 1, 153, 1, 153, 1, 153, 1, 153, 1, 154, 
	1, 154, 1, 155, 1, 155, 1, 155, 1, 156, 1, 156, 1, 157, 1, 157, 1, 157, 
	3, 157, 2015, 8, 157, 1, 157, 1, 157, 1, 157, 5, 157, 2020, 8, 157, 10, 
	157, 12, 157, 2023, 9, 157, 1, 158, 1, 158, 1, 158, 3, 158, 2028, 8, 158, 
	1, 159, 1, 159, 1, 159, 1, 159, 1, 160, 1, 160, 1, 160, 1, 160, 1, 161, 
	1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 3, 161, 2045, 8, 161, 1, 
	162, 1, 162, 1, 162, 1, 162, 1, 162, 5, 162, 2052, 8, 162, 10, 162, 12, 
	162, 2055, 9, 162, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 
	1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 
	1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 
	1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 
	1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 
	1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 3, 163, 2106, 8, 163, 1, 
	163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 3, 163, 2114, 8, 163, 1, 163, 
	1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 3, 163, 2122, 8, 163, 1, 164, 1, 
	164, 1, 164, 1, 164, 1, 164, 1, 164, 1, 164, 1, 164, 3, 164, 2132, 8, 164, 
	1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 5, 165, 2140, 8, 165, 10, 
	165, 12, 165, 2143, 9, 165, 1, 166, 1, 166, 1, 167, 1, 167, 1, 167, 3, 
	167, 2150, 8, 167, 1, 168, 1, 168, 1, 168, 1, 168, 3, 168, 2156, 8, 168, 
	1, 168, 3, 168, 2159, 8, 168, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 
	169, 1, 169, 1, 169, 1, 169, 3, 169, 2170, 8, 169, 1, 170, 1, 170, 1, 170, 
	1, 170, 5, 170, 2176, 8, 170, 10, 170, 12, 170, 2179, 9, 170, 1, 171, 1, 
	171, 3, 171, 2183, 8, 171, 1, 172, 1, 172, 1, 172, 1, 172, 1, 172, 1, 172, 
	5, 172, 2191, 8, 172, 10, 172, 12, 172, 2194, 9, 172, 1, 173, 1, 173, 1, 
	173, 1, 173, 1, 173, 3, 173, 2201, 8, 173, 1, 174, 1, 174, 1, 174, 1, 174, 
	1, 174, 3, 174, 2208, 8, 174, 1, 175, 1, 175, 3, 175, 2212, 8, 175, 1, 
	175, 3, 175, 2215, 8, 175, 1, 175, 3, 175, 2218, 8, 175, 1, 176, 1, 176, 
	3, 176, 2222, 8, 176, 1, 176, 3, 176, 2225, 8, 176, 1, 176, 3, 176, 2228, 
	8, 176, 1, 176, 1, 176, 1, 176, 1, 176, 3, 176, 2234, 8, 176, 1, 176, 3, 
	176, 2237, 8, 176, 1, 176, 3, 176, 2240, 8, 176, 1, 176, 3, 176, 2243, 
	8, 176, 1, 176, 3, 176, 2246, 8, 176, 1, 176, 3, 176, 2249, 8, 176, 1, 
	176, 1, 176, 3, 176, 2253, 8, 176, 1, 177, 1, 177, 1, 177, 1, 178, 1, 178, 
	1, 178, 3, 178, 2261, 8, 178, 1, 178, 3, 178, 2264, 8, 178, 1, 178, 3, 
	178, 2267, 8, 178, 1, 178, 3, 178, 2270, 8, 178, 1, 178, 3, 178, 2273, 
	8, 178, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 
	1, 179, 3, 179, 2284, 8, 179, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 
	180, 1, 180, 3, 180, 2293, 8, 180, 1, 181, 1, 181, 1, 182, 1, 182, 1, 183, 
	1, 183, 1, 184, 1, 184, 3, 184, 2303, 8, 184, 1, 184, 1, 184, 1, 184, 1, 
	184, 5, 184, 2309, 8, 184, 10, 184, 12, 184, 2312, 9, 184, 1, 185, 1, 185, 
	1, 185, 1, 185, 1, 186, 1, 186, 1, 186, 1, 186, 1, 187, 1, 187, 1, 187, 
	1, 187, 1, 187, 1, 188, 1, 188, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 
	3, 189, 2334, 8, 189, 1, 190, 1, 190, 1, 190, 1, 190, 5, 190, 2340, 8, 
	190, 10, 190, 12, 190, 2343, 9, 190, 1, 191, 1, 191, 1, 191, 1, 191, 1, 
	192, 1, 192, 3, 192, 2351, 8, 192, 1, 193, 1, 193, 1, 194, 1, 194, 1, 194, 
	1, 194, 3, 194, 2359, 8, 194, 1, 195, 1, 195, 1, 195, 1, 196, 1, 196, 3, 
	196, 2366, 8, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 3, 196, 
	2374, 8, 196, 1, 197, 1, 197, 1, 197, 1, 198, 1, 198, 1, 198, 1, 198, 1, 
	198, 1, 198, 1, 198, 1, 198, 3, 198, 2387, 8, 198, 1, 199, 1, 199, 1, 199, 
	1, 199, 1, 200, 1, 200, 1, 200, 3, 200, 2396, 8, 200, 1, 201, 1, 201, 1, 
	201, 1, 201, 1, 201, 1, 201, 1, 201, 3, 201, 2405, 8, 201, 1, 202, 1, 202, 
	1, 202, 1, 202, 1, 202, 1, 202, 1, 202, 1, 202, 3, 202, 2415, 8, 202, 1, 
	203, 1, 203, 1, 203, 1, 203, 5, 203, 2421, 8, 203, 10, 203, 12, 203, 2424, 
	9, 203, 1, 204, 1, 204, 3, 204, 2428, 8, 204, 1, 204, 3, 204, 2431, 8, 
	204, 1, 204, 1, 204, 1, 205, 1, 205, 1, 205, 1, 206, 1, 206, 1, 206, 3, 
	206, 2441, 8, 206, 1, 207, 1, 207, 1, 207, 1, 208, 1, 208, 1, 208, 1, 208, 
	3, 208, 2450, 8, 208, 1, 208, 1, 208, 1, 208, 1, 208, 5, 208, 2456, 8, 
	208, 10, 208, 12, 208, 2459, 9, 208, 1, 209, 1, 209, 1, 209, 1, 209, 1, 
	209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 3, 209, 2471, 8, 209, 1, 210, 
	1, 210, 3, 210, 2475, 8, 210, 1, 211, 1, 211, 1, 212, 1, 212, 1, 212, 1, 
	212, 3, 212, 2483, 8, 212, 1, 212, 3, 212, 2486, 8, 212, 1, 212, 1, 212, 
	1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 3, 212, 2497, 8, 
	212, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 5, 213, 2505, 8, 213, 
	10, 213, 12, 213, 2508, 9, 213, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 
	1, 214, 1, 214, 1, 214, 1, 214, 3, 214, 2519, 8, 214, 1, 215, 1, 215, 1, 
	215, 1, 215, 5, 215, 2525, 8, 215, 10, 215, 12, 215, 2528, 9, 215, 1, 216, 
	1, 216, 1, 216, 1, 216, 1, 216, 5, 216, 2535, 8, 216, 10, 216, 12, 216, 
	2538, 9, 216, 1, 217, 1, 217, 1, 217, 1, 218, 1, 218, 3, 218, 2545, 8, 
	218, 1, 219, 1, 219, 3, 219, 2549, 8, 219, 1, 220, 1, 220, 1, 221, 1, 221, 
	1, 221, 1, 221, 3, 221, 2557, 8, 221, 1, 222, 1, 222, 1, 222, 1, 222, 1, 
	222, 1, 222, 1, 222, 1, 222, 1, 222, 1, 222, 3, 222, 2569, 8, 222, 1, 223, 
	1, 223, 1, 224, 1, 224, 1, 224, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 
	1, 225, 1, 225, 5, 225, 2583, 8, 225, 10, 225, 12, 225, 2586, 9, 225, 1, 
	226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 3, 226, 2596, 
	8, 226, 1, 227, 1, 227, 1, 227, 1, 227, 1, 227, 1, 227, 1, 227, 1, 227, 
	1, 227, 1, 227, 1, 227, 1, 227, 1, 227, 1, 227, 5, 227, 2612, 8, 227, 10, 
	227, 12, 227, 2615, 9, 227, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 
	228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 3, 
	228, 2631, 8, 228, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 
	1, 230, 1, 230, 1, 230, 5, 230, 2643, 8, 230, 10, 230, 12, 230, 2646, 9, 
	230, 1, 231, 1, 231, 1, 231, 1, 231, 1, 232, 1, 232, 1, 232, 1, 232, 1, 
	232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 3, 232, 2662, 8, 232, 1, 233, 
	1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 234, 1, 234, 1, 234, 3, 234, 
	2673, 8, 234, 1, 235, 1, 235, 1, 235, 1, 235, 1, 235, 1, 236, 1, 236, 1, 
	236, 1, 236, 1, 236, 3, 236, 2685, 8, 236, 1, 236, 1, 236, 1, 236, 1, 236, 
	1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 3, 236, 2698, 8, 
	236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 3, 236, 2706, 8, 236, 
	1, 237, 1, 237, 1, 237, 1, 237, 1, 237, 1, 237, 1, 237, 1, 237, 3, 237, 
	2716, 8, 237, 1, 238, 1, 238, 3, 238, 2720, 8, 238, 1, 239, 1, 239, 1, 
	239, 1, 239, 1, 239, 1, 239, 1, 239, 4, 239, 2729, 8, 239, 11, 239, 12, 
	239, 2730, 1, 240, 1, 240, 1, 240, 1, 240, 1, 240, 1, 240, 4, 240, 2739, 
	8, 240, 11, 240, 12, 240, 2740, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 
	3, 241, 2748, 8, 241, 1, 242, 1, 242, 1, 242, 1, 242, 1, 243, 1, 243, 1, 
	243, 1, 243, 1, 243, 1, 243, 1, 243, 1, 243, 3, 243, 2762, 8, 243, 1, 244, 
	1, 244, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 3, 245, 
	2773, 8, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 
	245, 5, 245, 2783, 8, 245, 10, 245, 12, 245, 2786, 9, 245, 1, 246, 1, 246, 
	1, 246, 1, 247, 1, 247, 1, 248, 1, 248, 1, 248, 3, 248, 2796, 8, 248, 1, 
	249, 1, 249, 1, 249, 1, 249, 1, 250, 1, 250, 1, 250, 1, 250, 1, 250, 1, 
	250, 3, 250, 2808, 8, 250, 1, 251, 1, 251, 1, 251, 1, 251, 5, 251, 2814, 
	8, 251, 10, 251, 12, 251, 2817, 9, 251, 1, 252, 1, 252, 1, 252, 1, 252, 
	1, 253, 1, 253, 1, 253, 1, 253, 1, 253, 1, 253, 1, 253, 1, 253, 1, 253, 
	1, 253, 1, 253, 3, 253, 2834, 8, 253, 1, 254, 1, 254, 1, 254, 1, 254, 1, 
	254, 1, 254, 3, 254, 2842, 8, 254, 1, 255, 1, 255, 1, 255, 1, 255, 5, 255, 
	2848, 8, 255, 10, 255, 12, 255, 2851, 9, 255, 1, 256, 1, 256, 1, 256, 1, 
	256, 3, 256, 2857, 8, 256, 1, 257, 1, 257, 1, 257, 1, 258, 1, 258, 1, 258, 
	1, 258, 1, 258, 1, 259, 1, 259, 3, 259, 2869, 8, 259, 1, 259, 3, 259, 2872, 
	8, 259, 1, 260, 1, 260, 1, 260, 1, 261, 1, 261, 1, 261, 3, 261, 2880, 8, 
	261, 1, 262, 1, 262, 1, 262, 1, 263, 1, 263, 3, 263, 2887, 8, 263, 1, 264, 
	1, 264, 1, 264, 1, 265, 1, 265, 1, 265, 1, 265, 1, 265, 1, 265, 1, 265, 
	1, 265, 3, 265, 2900, 8, 265, 1, 266, 1, 266, 1, 266, 1, 266, 5, 266, 2906, 
	8, 266, 10, 266, 12, 266, 2909, 9, 266, 1, 267, 1, 267, 1, 267, 1, 267, 
	1, 267, 1, 267, 3, 267, 2917, 8, 267, 1, 268, 1, 268, 1, 268, 1, 268, 1, 
	268, 1, 268, 3, 268, 2925, 8, 268, 1, 269, 1, 269, 1, 269, 1, 269, 1, 269, 
	1, 269, 1, 269, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 
	1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 
	1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 3, 270, 2955, 8, 270, 1, 271, 1, 
	271, 1, 271, 1, 271, 1, 271, 1, 271, 5, 271, 2963, 8, 271, 10, 271, 12, 
	271, 2966, 9, 271, 1, 272, 1, 272, 3, 272, 2970, 8, 272, 1, 273, 1, 273, 
	1, 273, 1, 273, 1, 273, 1, 273, 5, 273, 2978, 8, 273, 10, 273, 12, 273, 
	2981, 9, 273, 1, 274, 1, 274, 3, 274, 2985, 8, 274, 1, 275, 1, 275, 3, 
	275, 2989, 8, 275, 1, 276, 1, 276, 1, 277, 1, 277, 1, 278, 1, 278, 1, 278, 
	1, 278, 1, 279, 1, 279, 1, 279, 1, 279, 1, 279, 1, 280, 1, 280, 1, 281, 
	1, 281, 1, 282, 1, 282, 1, 282, 1, 283, 1, 283, 1, 284, 1, 284, 1, 285, 
	1, 285, 1, 285, 1, 286, 1, 286, 1, 286, 1, 287, 1, 287, 1, 288, 1, 288, 
	1, 288, 1, 289, 1, 289, 1, 290, 1, 290, 1, 291, 1, 291, 1, 291, 1, 291, 
	1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 5, 291, 3041, 8, 
	291, 10, 291, 12, 291, 3044, 9, 291, 1, 292, 1, 292, 1, 293, 1, 293, 1, 
	294, 1, 294, 1, 294, 1, 294, 1, 294, 1, 294, 1, 294, 1, 294, 1, 294, 1, 
	294, 1, 294, 5, 294, 3061, 8, 294, 10, 294, 12, 294, 3064, 9, 294, 1, 295, 
	1, 295, 1, 296, 1, 296, 1, 297, 1, 297, 1, 298, 1, 298, 1, 299, 1, 299, 
	1, 300, 1, 300, 1, 301, 1, 301, 1, 302, 1, 302, 1, 303, 1, 303, 1, 304, 
	1, 304, 3, 304, 3086, 8, 304, 1, 305, 1, 305, 1, 306, 1, 306, 1, 306, 0, 
	17, 24, 42, 98, 100, 126, 128, 162, 164, 166, 206, 260, 314, 454, 490, 
	546, 582, 588, 307, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 
	28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 
	64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 
	100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 
	130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 
	160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 
	190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 
	220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 
	250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 
	280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 
	310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 
	340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 
	370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390, 392, 394, 396, 398, 
	400, 402, 404, 406, 408, 410, 412, 414, 416, 418, 420, 422, 424, 426, 428, 
	430, 432, 434, 436, 438, 440, 442, 444, 446, 448, 450, 452, 454, 456, 458, 
	460, 462, 464, 466, 468, 470, 472, 474, 476, 478, 480, 482, 484, 486, 488, 
	490, 492, 494, 496, 498, 500, 502, 504, 506, 508, 510, 512, 514, 516, 518, 
	520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548, 
	550, 552, 554, 556, 558, 560, 562, 564, 566, 568, 570, 572, 574, 576, 578, 
	580, 582, 584, 586, 588, 590, 592, 594, 596, 598, 600, 602, 604, 606, 608, 
	610, 612, 0, 20, 3, 0, 40, 40, 251, 251, 273, 273, 5, 0, 13, 13, 21, 21, 
	23, 23, 31, 31, 45, 45, 2, 0, 16, 16, 40, 40, 2, 0, 2, 2, 11, 11, 3, 0, 
	13, 13, 21, 21, 45, 45, 2, 0, 4, 4, 9, 9, 2, 0, 33, 33, 259, 259, 2, 0, 
	254, 254, 272, 272, 2, 0, 2, 2, 278, 279, 1, 0, 264, 265, 2, 0, 64, 64, 
	259, 259, 2, 0, 284, 284, 307, 308, 1, 0, 254, 256, 4, 0, 22, 22, 36, 36, 
	64, 64, 247, 249, 10, 0, 19, 19, 28, 28, 30, 30, 33, 34, 38, 39, 42, 43, 
	48, 48, 52, 55, 59, 63, 67, 238, 1, 0, 60, 63, 1, 0, 54, 55, 1, 0, 52, 
	53, 1, 0, 50, 51, 1, 0, 310, 311, 3226, 0, 614, 1, 0, 0, 0, 2, 617, 1, 
	0, 0, 0, 4, 628, 1, 0, 0, 0, 6, 630, 1, 0, 0, 0, 8, 632, 1, 0, 0, 0, 10, 
	675, 1, 0, 0, 0, 12, 677, 1, 0, 0, 0, 14, 679, 1, 0, 0, 0, 16, 681, 1, 
	0, 0, 0, 18, 684, 1, 0, 0, 0, 20, 688, 1, 0, 0, 0, 22, 690, 1, 0, 0, 0, 
	24, 702, 1, 0, 0, 0, 26, 722, 1, 0, 0, 0, 28, 725, 1, 0, 0, 0, 30, 741, 
	1, 0, 0, 0, 32, 743, 1, 0, 0, 0, 34, 745, 1, 0, 0, 0, 36, 747, 1, 0, 0, 
	0, 38, 758, 1, 0, 0, 0, 40, 760, 1, 0, 0, 0, 42, 768, 1, 0, 0, 0, 44, 778, 
	1, 0, 0, 0, 46, 784, 1, 0, 0, 0, 48, 805, 1, 0, 0, 0, 50, 809, 1, 0, 0, 
	0, 52, 814, 1, 0, 0, 0, 54, 816, 1, 0, 0, 0, 56, 821, 1, 0, 0, 0, 58, 823, 
	1, 0, 0, 0, 60, 836, 1, 0, 0, 0, 62, 846, 1, 0, 0, 0, 64, 854, 1, 0, 0, 
	0, 66, 864, 1, 0, 0, 0, 68, 866, 1, 0, 0, 0, 70, 886, 1, 0, 0, 0, 72, 899, 
	1, 0, 0, 0, 74, 916, 1, 0, 0, 0, 76, 918, 1, 0, 0, 0, 78, 920, 1, 0, 0, 
	0, 80, 929, 1, 0, 0, 0, 82, 933, 1, 0, 0, 0, 84, 936, 1, 0, 0, 0, 86, 941, 
	1, 0, 0, 0, 88, 943, 1, 0, 0, 0, 90, 975, 1, 0, 0, 0, 92, 981, 1, 0, 0, 
	0, 94, 990, 1, 0, 0, 0, 96, 992, 1, 0, 0, 0, 98, 1003, 1, 0, 0, 0, 100, 
	1029, 1, 0, 0, 0, 102, 1056, 1, 0, 0, 0, 104, 1101, 1, 0, 0, 0, 106, 1103, 
	1, 0, 0, 0, 108, 1129, 1, 0, 0, 0, 110, 1131, 1, 0, 0, 0, 112, 1138, 1, 
	0, 0, 0, 114, 1140, 1, 0, 0, 0, 116, 1150, 1, 0, 0, 0, 118, 1157, 1, 0, 
	0, 0, 120, 1159, 1, 0, 0, 0, 122, 1161, 1, 0, 0, 0, 124, 1171, 1, 0, 0, 
	0, 126, 1189, 1, 0, 0, 0, 128, 1200, 1, 0, 0, 0, 130, 1215, 1, 0, 0, 0, 
	132, 1217, 1, 0, 0, 0, 134, 1225, 1, 0, 0, 0, 136, 1229, 1, 0, 0, 0, 138, 
	1233, 1, 0, 0, 0, 140, 1241, 1, 0, 0, 0, 142, 1256, 1, 0, 0, 0, 144, 1262, 
	1, 0, 0, 0, 146, 1264, 1, 0, 0, 0, 148, 1266, 1, 0, 0, 0, 150, 1290, 1, 
	0, 0, 0, 152, 1292, 1, 0, 0, 0, 154, 1342, 1, 0, 0, 0, 156, 1364, 1, 0, 
	0, 0, 158, 1368, 1, 0, 0, 0, 160, 1372, 1, 0, 0, 0, 162, 1374, 1, 0, 0, 
	0, 164, 1399, 1, 0, 0, 0, 166, 1417, 1, 0, 0, 0, 168, 1438, 1, 0, 0, 0, 
	170, 1440, 1, 0, 0, 0, 172, 1450, 1, 0, 0, 0, 174, 1462, 1, 0, 0, 0, 176, 
	1464, 1, 0, 0, 0, 178, 1474, 1, 0, 0, 0, 180, 1477, 1, 0, 0, 0, 182, 1481, 
	1, 0, 0, 0, 184, 1520, 1, 0, 0, 0, 186, 1522, 1, 0, 0, 0, 188, 1527, 1, 
	0, 0, 0, 190, 1529, 1, 0, 0, 0, 192, 1534, 1, 0, 0, 0, 194, 1542, 1, 0, 
	0, 0, 196, 1548, 1, 0, 0, 0, 198, 1550, 1, 0, 0, 0, 200, 1553, 1, 0, 0, 
	0, 202, 1556, 1, 0, 0, 0, 204, 1568, 1, 0, 0, 0, 206, 1571, 1, 0, 0, 0, 
	208, 1583, 1, 0, 0, 0, 210, 1595, 1, 0, 0, 0, 212, 1602, 1, 0, 0, 0, 214, 
	1604, 1, 0, 0, 0, 216, 1616, 1, 0, 0, 0, 218, 1618, 1, 0, 0, 0, 220, 1629, 
	1, 0, 0, 0, 222, 1637, 1, 0, 0, 0, 224, 1641, 1, 0, 0, 0, 226, 1649, 1, 
	0, 0, 0, 228, 1656, 1, 0, 0, 0, 230, 1672, 1, 0, 0, 0, 232, 1674, 1, 0, 
	0, 0, 234, 1676, 1, 0, 0, 0, 236, 1683, 1, 0, 0, 0, 238, 1698, 1, 0, 0, 
	0, 240, 1706, 1, 0, 0, 0, 242, 1714, 1, 0, 0, 0, 244, 1722, 1, 0, 0, 0, 
	246, 1730, 1, 0, 0, 0, 248, 1734, 1, 0, 0, 0, 250, 1738, 1, 0, 0, 0, 252, 
	1751, 1, 0, 0, 0, 254, 1759, 1, 0, 0, 0, 256, 1763, 1, 0, 0, 0, 258, 1772, 
	1, 0, 0, 0, 260, 1811, 1, 0, 0, 0, 262, 1834, 1, 0, 0, 0, 264, 1846, 1, 
	0, 0, 0, 266, 1867, 1, 0, 0, 0, 268, 1871, 1, 0, 0, 0, 270, 1873, 1, 0, 
	0, 0, 272, 1876, 1, 0, 0, 0, 274, 1881, 1, 0, 0, 0, 276, 1891, 1, 0, 0, 
	0, 278, 1893, 1, 0, 0, 0, 280, 1900, 1, 0, 0, 0, 282, 1909, 1, 0, 0, 0, 
	284, 1914, 1, 0, 0, 0, 286, 1919, 1, 0, 0, 0, 288, 1927, 1, 0, 0, 0, 290, 
	1935, 1, 0, 0, 0, 292, 1942, 1, 0, 0, 0, 294, 1946, 1, 0, 0, 0, 296, 1953, 
	1, 0, 0, 0, 298, 1972, 1, 0, 0, 0, 300, 1986, 1, 0, 0, 0, 302, 1988, 1, 
	0, 0, 0, 304, 1994, 1, 0, 0, 0, 306, 2000, 1, 0, 0, 0, 308, 2004, 1, 0, 
	0, 0, 310, 2006, 1, 0, 0, 0, 312, 2009, 1, 0, 0, 0, 314, 2014, 1, 0, 0, 
	0, 316, 2027, 1, 0, 0, 0, 318, 2029, 1, 0, 0, 0, 320, 2033, 1, 0, 0, 0, 
	322, 2044, 1, 0, 0, 0, 324, 2046, 1, 0, 0, 0, 326, 2121, 1, 0, 0, 0, 328, 
	2131, 1, 0, 0, 0, 330, 2133, 1, 0, 0, 0, 332, 2144, 1, 0, 0, 0, 334, 2149, 
	1, 0, 0, 0, 336, 2158, 1, 0, 0, 0, 338, 2169, 1, 0, 0, 0, 340, 2171, 1, 
	0, 0, 0, 342, 2180, 1, 0, 0, 0, 344, 2184, 1, 0, 0, 0, 346, 2200, 1, 0, 
	0, 0, 348, 2202, 1, 0, 0, 0, 350, 2209, 1, 0, 0, 0, 352, 2252, 1, 0, 0, 
	0, 354, 2254, 1, 0, 0, 0, 356, 2272, 1, 0, 0, 0, 358, 2283, 1, 0, 0, 0, 
	360, 2292, 1, 0, 0, 0, 362, 2294, 1, 0, 0, 0, 364, 2296, 1, 0, 0, 0, 366, 
	2298, 1, 0, 0, 0, 368, 2300, 1, 0, 0, 0, 370, 2313, 1, 0, 0, 0, 372, 2317, 
	1, 0, 0, 0, 374, 2321, 1, 0, 0, 0, 376, 2326, 1, 0, 0, 0, 378, 2333, 1, 
	0, 0, 0, 380, 2335, 1, 0, 0, 0, 382, 2344, 1, 0, 0, 0, 384, 2350, 1, 0, 
	0, 0, 386, 2352, 1, 0, 0, 0, 388, 2358, 1, 0, 0, 0, 390, 2360, 1, 0, 0, 
	0, 392, 2373, 1, 0, 0, 0, 394, 2375, 1, 0, 0, 0, 396, 2386, 1, 0, 0, 0, 
	398, 2388, 1, 0, 0, 0, 400, 2395, 1, 0, 0, 0, 402, 2404, 1, 0, 0, 0, 404, 
	2414, 1, 0, 0, 0, 406, 2416, 1, 0, 0, 0, 408, 2425, 1, 0, 0, 0, 410, 2434, 
	1, 0, 0, 0, 412, 2440, 1, 0, 0, 0, 414, 2442, 1, 0, 0, 0, 416, 2445, 1, 
	0, 0, 0, 418, 2470, 1, 0, 0, 0, 420, 2474, 1, 0, 0, 0, 422, 2476, 1, 0, 
	0, 0, 424, 2496, 1, 0, 0, 0, 426, 2498, 1, 0, 0, 0, 428, 2518, 1, 0, 0, 
	0, 430, 2520, 1, 0, 0, 0, 432, 2529, 1, 0, 0, 0, 434, 2539, 1, 0, 0, 0, 
	436, 2544, 1, 0, 0, 0, 438, 2546, 1, 0, 0, 0, 440, 2550, 1, 0, 0, 0, 442, 
	2556, 1, 0, 0, 0, 444, 2568, 1, 0, 0, 0, 446, 2570, 1, 0, 0, 0, 448, 2572, 
	1, 0, 0, 0, 450, 2575, 1, 0, 0, 0, 452, 2595, 1, 0, 0, 0, 454, 2597, 1, 
	0, 0, 0, 456, 2630, 1, 0, 0, 0, 458, 2632, 1, 0, 0, 0, 460, 2639, 1, 0, 
	0, 0, 462, 2647, 1, 0, 0, 0, 464, 2661, 1, 0, 0, 0, 466, 2663, 1, 0, 0, 
	0, 468, 2669, 1, 0, 0, 0, 470, 2674, 1, 0, 0, 0, 472, 2705, 1, 0, 0, 0, 
	474, 2715, 1, 0, 0, 0, 476, 2719, 1, 0, 0, 0, 478, 2721, 1, 0, 0, 0, 480, 
	2732, 1, 0, 0, 0, 482, 2747, 1, 0, 0, 0, 484, 2749, 1, 0, 0, 0, 486, 2761, 
	1, 0, 0, 0, 488, 2763, 1, 0, 0, 0, 490, 2772, 1, 0, 0, 0, 492, 2787, 1, 
	0, 0, 0, 494, 2790, 1, 0, 0, 0, 496, 2795, 1, 0, 0, 0, 498, 2797, 1, 0, 
	0, 0, 500, 2807, 1, 0, 0, 0, 502, 2809, 1, 0, 0, 0, 504, 2818, 1, 0, 0, 
	0, 506, 2833, 1, 0, 0, 0, 508, 2841, 1, 0, 0, 0, 510, 2843, 1, 0, 0, 0, 
	512, 2856, 1, 0, 0, 0, 514, 2858, 1, 0, 0, 0, 516, 2861, 1, 0, 0, 0, 518, 
	2866, 1, 0, 0, 0, 520, 2873, 1, 0, 0, 0, 522, 2879, 1, 0, 0, 0, 524, 2881, 
	1, 0, 0, 0, 526, 2886, 1, 0, 0, 0, 528, 2888, 1, 0, 0, 0, 530, 2899, 1, 
	0, 0, 0, 532, 2901, 1, 0, 0, 0, 534, 2916, 1, 0, 0, 0, 536, 2924, 1, 0, 
	0, 0, 538, 2926, 1, 0, 0, 0, 540, 2954, 1, 0, 0, 0, 542, 2956, 1, 0, 0, 
	0, 544, 2969, 1, 0, 0, 0, 546, 2971, 1, 0, 0, 0, 548, 2984, 1, 0, 0, 0, 
	550, 2988, 1, 0, 0, 0, 552, 2990, 1, 0, 0, 0, 554, 2992, 1, 0, 0, 0, 556, 
	2994, 1, 0, 0, 0, 558, 2998, 1, 0, 0, 0, 560, 3003, 1, 0, 0, 0, 562, 3005, 
	1, 0, 0, 0, 564, 3007, 1, 0, 0, 0, 566, 3010, 1, 0, 0, 0, 568, 3012, 1, 
	0, 0, 0, 570, 3014, 1, 0, 0, 0, 572, 3017, 1, 0, 0, 0, 574, 3020, 1, 0, 
	0, 0, 576, 3022, 1, 0, 0, 0, 578, 3025, 1, 0, 0, 0, 580, 3027, 1, 0, 0, 
	0, 582, 3029, 1, 0, 0, 0, 584, 3045, 1, 0, 0, 0, 586, 3047, 1, 0, 0, 0, 
	588, 3049, 1, 0, 0, 0, 590, 3065, 1, 0, 0, 0, 592, 3067, 1, 0, 0, 0, 594, 
	3069, 1, 0, 0, 0, 596, 3071, 1, 0, 0, 0, 598, 3073, 1, 0, 0, 0, 600, 3075, 
	1, 0, 0, 0, 602, 3077, 1, 0, 0, 0, 604, 3079, 1, 0, 0, 0, 606, 3081, 1, 
	0, 0, 0, 608, 3085, 1, 0, 0, 0, 610, 3087, 1, 0, 0, 0, 612, 3089, 1, 0, 
	0, 0, 614, 615, 3, 2, 1, 0, 615, 616, 5, 0, 0, 1, 616, 1, 1, 0, 0, 0, 617, 
	622, 3, 4, 2, 0, 618, 619, 5, 295, 0, 0, 619, 621, 3, 4, 2, 0, 620, 618, 
	1, 0, 0, 0, 621, 624, 1, 0, 0, 0, 622, 620, 1, 0, 0, 0, 622, 623, 1, 0, 
	0, 0, 623, 626, 1, 0, 0, 0, 624, 622, 1, 0, 0, 0, 625, 627, 5, 295, 0, 
	0, 626, 625, 1, 0, 0, 0, 626, 627, 1, 0, 0, 0, 627, 3, 1, 0, 0, 0, 628, 
	629, 3, 6, 3, 0, 629, 5, 1, 0, 0, 0, 630, 631, 3, 8, 4, 0, 631, 7, 1, 0, 
	0, 0, 632, 633, 3, 10, 5, 0, 633, 9, 1, 0, 0, 0, 634, 635, 3, 42, 21, 0, 
	635, 637, 3, 20, 10, 0, 636, 638, 3, 56, 28, 0, 637, 636, 1, 0, 0, 0, 637, 
	638, 1, 0, 0, 0, 638, 640, 1, 0, 0, 0, 639, 641, 3, 402, 201, 0, 640, 639, 
	1, 0, 0, 0, 640, 641, 1, 0, 0, 0, 641, 676, 1, 0, 0, 0, 642, 643, 3, 16, 
	8, 0, 643, 644, 3, 18, 9, 0, 644, 645, 6, 5, -1, 0, 645, 676, 1, 0, 0, 
	0, 646, 647, 3, 42, 21, 0, 647, 648, 5, 309, 0, 0, 648, 649, 6, 5, -1, 
	0, 649, 676, 1, 0, 0, 0, 650, 652, 3, 20, 10, 0, 651, 653, 3, 56, 28, 0, 
	652, 651, 1, 0, 0, 0, 652, 653, 1, 0, 0, 0, 653, 655, 1, 0, 0, 0, 654, 
	656, 3, 402, 201, 0, 655, 654, 1, 0, 0, 0, 655, 656, 1, 0, 0, 0, 656, 676, 
	1, 0, 0, 0, 657, 659, 3, 42, 21, 0, 658, 657, 1, 0, 0, 0, 658, 659, 1, 
	0, 0, 0, 659, 660, 1, 0, 0, 0, 660, 676, 3, 96, 48, 0, 661, 663, 3, 42, 
	21, 0, 662, 661, 1, 0, 0, 0, 662, 663, 1, 0, 0, 0, 663, 664, 1, 0, 0, 0, 
	664, 665, 3, 96, 48, 0, 665, 666, 3, 12, 6, 0, 666, 667, 6, 5, -1, 0, 667, 
	676, 1, 0, 0, 0, 668, 670, 3, 42, 21, 0, 669, 668, 1, 0, 0, 0, 669, 670, 
	1, 0, 0, 0, 670, 671, 1, 0, 0, 0, 671, 672, 3, 96, 48, 0, 672, 673, 3, 
	14, 7, 0, 673, 674, 6, 5, -1, 0, 674, 676, 1, 0, 0, 0, 675, 634, 1, 0, 
	0, 0, 675, 642, 1, 0, 0, 0, 675, 646, 1, 0, 0, 0, 675, 650, 1, 0, 0, 0, 
	675, 658, 1, 0, 0, 0, 675, 662, 1, 0, 0, 0, 675, 669, 1, 0, 0, 0, 676, 
	11, 1, 0, 0, 0, 677, 678, 7, 0, 0, 0, 678, 13, 1, 0, 0, 0, 679, 680, 7, 
	1, 0, 0, 680, 15, 1, 0, 0, 0, 681, 682, 3, 42, 21, 0, 682, 683, 5, 282, 
	0, 0, 683, 17, 1, 0, 0, 0, 684, 685, 7, 2, 0, 0, 685, 19, 1, 0, 0, 0, 686, 
	689, 3, 26, 13, 0, 687, 689, 3, 22, 11, 0, 688, 686, 1, 0, 0, 0, 688, 687, 
	1, 0, 0, 0, 689, 21, 1, 0, 0, 0, 690, 691, 3, 24, 12, 0, 691, 23, 1, 0, 
	0, 0, 692, 693, 6, 12, -1, 0, 693, 694, 3, 26, 13, 0, 694, 695, 3, 28, 
	14, 0, 695, 696, 3, 26, 13, 0, 696, 703, 1, 0, 0, 0, 697, 698, 3, 26, 13, 
	0, 698, 699, 3, 28, 14, 0, 699, 700, 5, 16, 0, 0, 700, 701, 6, 12, -1, 
	0, 701, 703, 1, 0, 0, 0, 702, 692, 1, 0, 0, 0, 702, 697, 1, 0, 0, 0, 703, 
	715, 1, 0, 0, 0, 704, 705, 10, 3, 0, 0, 705, 706, 3, 28, 14, 0, 706, 707, 
	3, 26, 13, 0, 707, 714, 1, 0, 0, 0, 708, 709, 10, 1, 0, 0, 709, 710, 3, 
	28, 14, 0, 710, 711, 5, 16, 0, 0, 711, 712, 6, 12, -1, 0, 712, 714, 1, 
	0, 0, 0, 713, 704, 1, 0, 0, 0, 713, 708, 1, 0, 0, 0, 714, 717, 1, 0, 0, 
	0, 715, 713, 1, 0, 0, 0, 715, 716, 1, 0, 0, 0, 716, 25, 1, 0, 0, 0, 717, 
	715, 1, 0, 0, 0, 718, 723, 3, 68, 34, 0, 719, 720, 3, 318, 159, 0, 720, 
	721, 3, 434, 217, 0, 721, 723, 1, 0, 0, 0, 722, 718, 1, 0, 0, 0, 722, 719, 
	1, 0, 0, 0, 723, 27, 1, 0, 0, 0, 724, 726, 3, 38, 19, 0, 725, 724, 1, 0, 
	0, 0, 725, 726, 1, 0, 0, 0, 726, 727, 1, 0, 0, 0, 727, 729, 3, 36, 18, 
	0, 728, 730, 3, 412, 206, 0, 729, 728, 1, 0, 0, 0, 729, 730, 1, 0, 0, 0, 
	730, 731, 1, 0, 0, 0, 731, 733, 3, 34, 17, 0, 732, 734, 3, 32, 16, 0, 733, 
	732, 1, 0, 0, 0, 733, 734, 1, 0, 0, 0, 734, 736, 1, 0, 0, 0, 735, 737, 
	3, 30, 15, 0, 736, 735, 1, 0, 0, 0, 736, 737, 1, 0, 0, 0, 737, 29, 1, 0, 
	0, 0, 738, 742, 5, 95, 0, 0, 739, 740, 5, 95, 0, 0, 740, 742, 5, 5, 0, 
	0, 741, 738, 1, 0, 0, 0, 741, 739, 1, 0, 0, 0, 742, 31, 1, 0, 0, 0, 743, 
	744, 5, 211, 0, 0, 744, 33, 1, 0, 0, 0, 745, 746, 7, 3, 0, 0, 746, 35, 
	1, 0, 0, 0, 747, 748, 7, 4, 0, 0, 748, 37, 1, 0, 0, 0, 749, 751, 5, 17, 
	0, 0, 750, 752, 3, 40, 20, 0, 751, 750, 1, 0, 0, 0, 751, 752, 1, 0, 0, 
	0, 752, 759, 1, 0, 0, 0, 753, 759, 5, 32, 0, 0, 754, 756, 5, 22, 0, 0, 
	755, 757, 3, 40, 20, 0, 756, 755, 1, 0, 0, 0, 756, 757, 1, 0, 0, 0, 757, 
	759, 1, 0, 0, 0, 758, 749, 1, 0, 0, 0, 758, 753, 1, 0, 0, 0, 758, 754, 
	1, 0, 0, 0, 759, 39, 1, 0, 0, 0, 760, 761, 5, 32, 0, 0, 761, 41, 1, 0, 
	0, 0, 762, 763, 6, 21, -1, 0, 763, 764, 5, 49, 0, 0, 764, 769, 3, 44, 22, 
	0, 765, 766, 5, 49, 0, 0, 766, 767, 5, 37, 0, 0, 767, 769, 3, 44, 22, 0, 
	768, 762, 1, 0, 0, 0, 768, 765, 1, 0, 0, 0, 769, 775, 1, 0, 0, 0, 770, 
	771, 10, 1, 0, 0, 771, 772, 5, 282, 0, 0, 772, 774, 3, 44, 22, 0, 773, 
	770, 1, 0, 0, 0, 774, 777, 1, 0, 0, 0, 775, 773, 1, 0, 0, 0, 775, 776, 
	1, 0, 0, 0, 776, 43, 1, 0, 0, 0, 777, 775, 1, 0, 0, 0, 778, 779, 3, 548, 
	274, 0, 779, 780, 5, 3, 0, 0, 780, 782, 3, 318, 159, 0, 781, 783, 3, 46, 
	23, 0, 782, 781, 1, 0, 0, 0, 782, 783, 1, 0, 0, 0, 783, 45, 1, 0, 0, 0, 
	784, 785, 3, 48, 24, 0, 785, 47, 1, 0, 0, 0, 786, 787, 5, 49, 0, 0, 787, 
	789, 5, 103, 0, 0, 788, 790, 3, 434, 217, 0, 789, 788, 1, 0, 0, 0, 789, 
	790, 1, 0, 0, 0, 790, 806, 1, 0, 0, 0, 791, 792, 5, 49, 0, 0, 792, 793, 
	5, 103, 0, 0, 793, 794, 3, 434, 217, 0, 794, 795, 5, 261, 0, 0, 795, 796, 
	3, 50, 25, 0, 796, 797, 5, 57, 0, 0, 797, 798, 3, 50, 25, 0, 798, 806, 
	1, 0, 0, 0, 799, 800, 5, 49, 0, 0, 800, 801, 5, 103, 0, 0, 801, 802, 3, 
	434, 217, 0, 802, 803, 5, 153, 0, 0, 803, 804, 3, 50, 25, 0, 804, 806, 
	1, 0, 0, 0, 805, 786, 1, 0, 0, 0, 805, 791, 1, 0, 0, 0, 805, 799, 1, 0, 
	0, 0, 806, 49, 1, 0, 0, 0, 807, 810, 3, 52, 26, 0, 808, 810, 5, 262, 0, 
	0, 809, 807, 1, 0, 0, 0, 809, 808, 1, 0, 0, 0, 810, 51, 1, 0, 0, 0, 811, 
	815, 3, 580, 290, 0, 812, 815, 3, 526, 263, 0, 813, 815, 3, 524, 262, 0, 
	814, 811, 1, 0, 0, 0, 814, 812, 1, 0, 0, 0, 814, 813, 1, 0, 0, 0, 815, 
	53, 1, 0, 0, 0, 816, 817, 5, 23, 0, 0, 817, 818, 3, 594, 297, 0, 818, 819, 
	5, 28, 0, 0, 819, 820, 3, 596, 298, 0, 820, 55, 1, 0, 0, 0, 821, 822, 3, 
	58, 29, 0, 822, 57, 1, 0, 0, 0, 823, 825, 5, 31, 0, 0, 824, 826, 3, 412, 
	206, 0, 825, 824, 1, 0, 0, 0, 825, 826, 1, 0, 0, 0, 826, 827, 1, 0, 0, 
	0, 827, 828, 5, 5, 0, 0, 828, 833, 3, 60, 30, 0, 829, 830, 5, 282, 0, 0, 
	830, 832, 3, 60, 30, 0, 831, 829, 1, 0, 0, 0, 832, 835, 1, 0, 0, 0, 833, 
	831, 1, 0, 0, 0, 833, 834, 1, 0, 0, 0, 834, 59, 1, 0, 0, 0, 835, 833, 1, 
	0, 0, 0, 836, 838, 3, 314, 157, 0, 837, 839, 3, 520, 260, 0, 838, 837, 
	1, 0, 0, 0, 838, 839, 1, 0, 0, 0, 839, 841, 1, 0, 0, 0, 840, 842, 3, 440, 
	220, 0, 841, 840, 1, 0, 0, 0, 841, 842, 1, 0, 0, 0, 842, 844, 1, 0, 0, 
	0, 843, 845, 3, 442, 221, 0, 844, 843, 1, 0, 0, 0, 844, 845, 1, 0, 0, 0, 
	845, 61, 1, 0, 0, 0, 846, 851, 3, 64, 32, 0, 847, 848, 5, 282, 0, 0, 848, 
	850, 3, 64, 32, 0, 849, 847, 1, 0, 0, 0, 850, 853, 1, 0, 0, 0, 851, 849, 
	1, 0, 0, 0, 851, 852, 1, 0, 0, 0, 852, 63, 1, 0, 0, 0, 853, 851, 1, 0, 
	0, 0, 854, 856, 3, 314, 157, 0, 855, 857, 7, 5, 0, 0, 856, 855, 1, 0, 0, 
	0, 856, 857, 1, 0, 0, 0, 857, 65, 1, 0, 0, 0, 858, 859, 5, 45, 0, 0, 859, 
	865, 7, 3, 0, 0, 860, 861, 5, 21, 0, 0, 861, 865, 5, 11, 0, 0, 862, 863, 
	5, 13, 0, 0, 863, 865, 5, 11, 0, 0, 864, 858, 1, 0, 0, 0, 864, 860, 1, 
	0, 0, 0, 864, 862, 1, 0, 0, 0, 865, 67, 1, 0, 0, 0, 866, 868, 3, 90, 45, 
	0, 867, 869, 3, 96, 48, 0, 868, 867, 1, 0, 0, 0, 868, 869, 1, 0, 0, 0, 
	869, 870, 1, 0, 0, 0, 870, 871, 3, 70, 35, 0, 871, 69, 1, 0, 0, 0, 872, 
	874, 3, 82, 41, 0, 873, 875, 3, 86, 43, 0, 874, 873, 1, 0, 0, 0, 874, 875, 
	1, 0, 0, 0, 875, 877, 1, 0, 0, 0, 876, 878, 3, 84, 42, 0, 877, 876, 1, 
	0, 0, 0, 877, 878, 1, 0, 0, 0, 878, 880, 1, 0, 0, 0, 879, 881, 3, 200, 
	100, 0, 880, 879, 1, 0, 0, 0, 880, 881, 1, 0, 0, 0, 881, 883, 1, 0, 0, 
	0, 882, 884, 3, 76, 38, 0, 883, 882, 1, 0, 0, 0, 883, 884, 1, 0, 0, 0, 
	884, 887, 1, 0, 0, 0, 885, 887, 3, 72, 36, 0, 886, 872, 1, 0, 0, 0, 886, 
	885, 1, 0, 0, 0, 887, 71, 1, 0, 0, 0, 888, 890, 3, 86, 43, 0, 889, 891, 
	3, 84, 42, 0, 890, 889, 1, 0, 0, 0, 890, 891, 1, 0, 0, 0, 891, 893, 1, 
	0, 0, 0, 892, 894, 3, 200, 100, 0, 893, 892, 1, 0, 0, 0, 893, 894, 1, 0, 
	0, 0, 894, 896, 1, 0, 0, 0, 895, 897, 3, 76, 38, 0, 896, 895, 1, 0, 0, 
	0, 896, 897, 1, 0, 0, 0, 897, 900, 1, 0, 0, 0, 898, 900, 3, 74, 37, 0, 
	899, 888, 1, 0, 0, 0, 899, 898, 1, 0, 0, 0, 900, 73, 1, 0, 0, 0, 901, 903, 
	3, 84, 42, 0, 902, 901, 1, 0, 0, 0, 902, 903, 1, 0, 0, 0, 903, 905, 1, 
	0, 0, 0, 904, 906, 3, 200, 100, 0, 905, 904, 1, 0, 0, 0, 905, 906, 1, 0, 
	0, 0, 906, 908, 1, 0, 0, 0, 907, 909, 3, 76, 38, 0, 908, 907, 1, 0, 0, 
	0, 908, 909, 1, 0, 0, 0, 909, 917, 1, 0, 0, 0, 910, 912, 3, 200, 100, 0, 
	911, 910, 1, 0, 0, 0, 911, 912, 1, 0, 0, 0, 912, 914, 1, 0, 0, 0, 913, 
	915, 3, 76, 38, 0, 914, 913, 1, 0, 0, 0, 914, 915, 1, 0, 0, 0, 915, 917, 
	1, 0, 0, 0, 916, 902, 1, 0, 0, 0, 916, 911, 1, 0, 0, 0, 917, 75, 1, 0, 
	0, 0, 918, 919, 3, 78, 39, 0, 919, 77, 1, 0, 0, 0, 920, 921, 5, 274, 0, 
	0, 921, 926, 3, 80, 40, 0, 922, 923, 5, 282, 0, 0, 923, 925, 3, 80, 40, 
	0, 924, 922, 1, 0, 0, 0, 925, 928, 1, 0, 0, 0, 926, 924, 1, 0, 0, 0, 926, 
	927, 1, 0, 0, 0, 927, 79, 1, 0, 0, 0, 928, 926, 1, 0, 0, 0, 929, 930, 3, 
	548, 274, 0, 930, 931, 5, 3, 0, 0, 931, 932, 3, 356, 178, 0, 932, 81, 1, 
	0, 0, 0, 933, 934, 5, 273, 0, 0, 934, 935, 3, 314, 157, 0, 935, 83, 1, 
	0, 0, 0, 936, 937, 5, 250, 0, 0, 937, 938, 3, 314, 157, 0, 938, 85, 1, 
	0, 0, 0, 939, 942, 3, 88, 44, 0, 940, 942, 3, 406, 203, 0, 941, 939, 1, 
	0, 0, 0, 941, 940, 1, 0, 0, 0, 942, 87, 1, 0, 0, 0, 943, 944, 3, 408, 204, 
	0, 944, 945, 5, 2, 0, 0, 945, 89, 1, 0, 0, 0, 946, 948, 5, 40, 0, 0, 947, 
	949, 3, 412, 206, 0, 948, 947, 1, 0, 0, 0, 948, 949, 1, 0, 0, 0, 949, 951, 
	1, 0, 0, 0, 950, 952, 3, 94, 47, 0, 951, 950, 1, 0, 0, 0, 951, 952, 1, 
	0, 0, 0, 952, 954, 1, 0, 0, 0, 953, 955, 3, 34, 17, 0, 954, 953, 1, 0, 
	0, 0, 954, 955, 1, 0, 0, 0, 955, 957, 1, 0, 0, 0, 956, 958, 3, 92, 46, 
	0, 957, 956, 1, 0, 0, 0, 957, 958, 1, 0, 0, 0, 958, 959, 1, 0, 0, 0, 959, 
	976, 3, 274, 137, 0, 960, 962, 5, 40, 0, 0, 961, 963, 3, 412, 206, 0, 962, 
	961, 1, 0, 0, 0, 962, 963, 1, 0, 0, 0, 963, 965, 1, 0, 0, 0, 964, 966, 
	3, 94, 47, 0, 965, 964, 1, 0, 0, 0, 965, 966, 1, 0, 0, 0, 966, 968, 1, 
	0, 0, 0, 967, 969, 3, 34, 17, 0, 968, 967, 1, 0, 0, 0, 968, 969, 1, 0, 
	0, 0, 969, 971, 1, 0, 0, 0, 970, 972, 3, 92, 46, 0, 971, 970, 1, 0, 0, 
	0, 971, 972, 1, 0, 0, 0, 972, 973, 1, 0, 0, 0, 973, 974, 5, 16, 0, 0, 974, 
	976, 6, 45, -1, 0, 975, 946, 1, 0, 0, 0, 975, 960, 1, 0, 0, 0, 976, 91, 
	1, 0, 0, 0, 977, 978, 5, 3, 0, 0, 978, 982, 5, 41, 0, 0, 979, 980, 5, 3, 
	0, 0, 980, 982, 3, 546, 273, 0, 981, 977, 1, 0, 0, 0, 981, 979, 1, 0, 0, 
	0, 982, 93, 1, 0, 0, 0, 983, 984, 5, 49, 0, 0, 984, 991, 3, 548, 274, 0, 
	985, 986, 5, 49, 0, 0, 986, 987, 3, 548, 274, 0, 987, 988, 5, 30, 0, 0, 
	988, 989, 3, 378, 189, 0, 989, 991, 1, 0, 0, 0, 990, 983, 1, 0, 0, 0, 990, 
	985, 1, 0, 0, 0, 991, 95, 1, 0, 0, 0, 992, 993, 5, 16, 0, 0, 993, 994, 
	3, 98, 49, 0, 994, 97, 1, 0, 0, 0, 995, 996, 6, 49, -1, 0, 996, 1004, 3, 
	100, 50, 0, 997, 998, 5, 303, 0, 0, 998, 1004, 6, 49, -1, 0, 999, 1000, 
	5, 302, 0, 0, 1000, 1004, 6, 49, -1, 0, 1001, 1002, 5, 304, 0, 0, 1002, 
	1004, 6, 49, -1, 0, 1003, 995, 1, 0, 0, 0, 1003, 997, 1, 0, 0, 0, 1003, 
	999, 1, 0, 0, 0, 1003, 1001, 1, 0, 0, 0, 1004, 1018, 1, 0, 0, 0, 1005, 
	1006, 10, 5, 0, 0, 1006, 1007, 5, 282, 0, 0, 1007, 1017, 3, 100, 50, 0, 
	1008, 1010, 10, 4, 0, 0, 1009, 1011, 3, 232, 116, 0, 1010, 1009, 1, 0, 
	0, 0, 1010, 1011, 1, 0, 0, 0, 1011, 1013, 1, 0, 0, 0, 1012, 1014, 3, 230, 
	115, 0, 1013, 1012, 1, 0, 0, 0, 1013, 1014, 1, 0, 0, 0, 1014, 1015, 1, 
	0, 0, 0, 1015, 1017, 3, 146, 73, 0, 1016, 1005, 1, 0, 0, 0, 1016, 1008, 
	1, 0, 0, 0, 1017, 1020, 1, 0, 0, 0, 1018, 1016, 1, 0, 0, 0, 1018, 1019, 
	1, 0, 0, 0, 1019, 99, 1, 0, 0, 0, 1020, 1018, 1, 0, 0, 0, 1021, 1022, 6, 
	50, -1, 0, 1022, 1030, 3, 102, 51, 0, 1023, 1030, 3, 148, 74, 0, 1024, 
	1025, 5, 289, 0, 0, 1025, 1026, 3, 138, 69, 0, 1026, 1027, 5, 290, 0, 0, 
	1027, 1030, 1, 0, 0, 0, 1028, 1030, 3, 136, 68, 0, 1029, 1021, 1, 0, 0, 
	0, 1029, 1023, 1, 0, 0, 0, 1029, 1024, 1, 0, 0, 0, 1029, 1028, 1, 0, 0, 
	0, 1030, 1037, 1, 0, 0, 0, 1031, 1032, 10, 2, 0, 0, 1032, 1036, 3, 124, 
	62, 0, 1033, 1034, 10, 1, 0, 0, 1034, 1036, 3, 106, 53, 0, 1035, 1031, 
	1, 0, 0, 0, 1035, 1033, 1, 0, 0, 0, 1036, 1039, 1, 0, 0, 0, 1037, 1035, 
	1, 0, 0, 0, 1037, 1038, 1, 0, 0, 0, 1038, 101, 1, 0, 0, 0, 1039, 1037, 
	1, 0, 0, 0, 1040, 1041, 3, 228, 114, 0, 1041, 1043, 5, 290, 0, 0, 1042, 
	1044, 3, 412, 206, 0, 1043, 1042, 1, 0, 0, 0, 1043, 1044, 1, 0, 0, 0, 1044, 
	1046, 1, 0, 0, 0, 1045, 1047, 3, 104, 52, 0, 1046, 1045, 1, 0, 0, 0, 1046, 
	1047, 1, 0, 0, 0, 1047, 1057, 1, 0, 0, 0, 1048, 1049, 3, 182, 91, 0, 1049, 
	1051, 5, 290, 0, 0, 1050, 1052, 3, 412, 206, 0, 1051, 1050, 1, 0, 0, 0, 
	1051, 1052, 1, 0, 0, 0, 1052, 1054, 1, 0, 0, 0, 1053, 1055, 3, 104, 52, 
	0, 1054, 1053, 1, 0, 0, 0, 1054, 1055, 1, 0, 0, 0, 1055, 1057, 1, 0, 0, 
	0, 1056, 1040, 1, 0, 0, 0, 1056, 1048, 1, 0, 0, 0, 1057, 103, 1, 0, 0, 
	0, 1058, 1059, 5, 3, 0, 0, 1059, 1102, 3, 548, 274, 0, 1060, 1102, 3, 548, 
	274, 0, 1061, 1062, 5, 3, 0, 0, 1062, 1063, 3, 548, 274, 0, 1063, 1065, 
	3, 218, 109, 0, 1064, 1066, 3, 292, 146, 0, 1065, 1064, 1, 0, 0, 0, 1065, 
	1066, 1, 0, 0, 0, 1066, 1102, 1, 0, 0, 0, 1067, 1068, 5, 3, 0, 0, 1068, 
	1069, 3, 548, 274, 0, 1069, 1071, 3, 202, 101, 0, 1070, 1072, 3, 292, 146, 
	0, 1071, 1070, 1, 0, 0, 0, 1071, 1072, 1, 0, 0, 0, 1072, 1102, 1, 0, 0, 
	0, 1073, 1074, 5, 3, 0, 0, 1074, 1075, 3, 548, 274, 0, 1075, 1076, 3, 200, 
	100, 0, 1076, 1077, 6, 52, -1, 0, 1077, 1102, 1, 0, 0, 0, 1078, 1079, 3, 
	548, 274, 0, 1079, 1080, 3, 218, 109, 0, 1080, 1081, 3, 292, 146, 0, 1081, 
	1102, 1, 0, 0, 0, 1082, 1083, 3, 548, 274, 0, 1083, 1084, 3, 202, 101, 
	0, 1084, 1085, 3, 292, 146, 0, 1085, 1102, 1, 0, 0, 0, 1086, 1087, 3, 548, 
	274, 0, 1087, 1088, 3, 200, 100, 0, 1088, 1089, 6, 52, -1, 0, 1089, 1102, 
	1, 0, 0, 0, 1090, 1092, 3, 218, 109, 0, 1091, 1093, 3, 292, 146, 0, 1092, 
	1091, 1, 0, 0, 0, 1092, 1093, 1, 0, 0, 0, 1093, 1102, 1, 0, 0, 0, 1094, 
	1096, 3, 202, 101, 0, 1095, 1097, 3, 292, 146, 0, 1096, 1095, 1, 0, 0, 
	0, 1096, 1097, 1, 0, 0, 0, 1097, 1102, 1, 0, 0, 0, 1098, 1099, 3, 200, 
	100, 0, 1099, 1100, 6, 52, -1, 0, 1100, 1102, 1, 0, 0, 0, 1101, 1058, 1, 
	0, 0, 0, 1101, 1060, 1, 0, 0, 0, 1101, 1061, 1, 0, 0, 0, 1101, 1067, 1, 
	0, 0, 0, 1101, 1073, 1, 0, 0, 0, 1101, 1078, 1, 0, 0, 0, 1101, 1082, 1, 
	0, 0, 0, 1101, 1086, 1, 0, 0, 0, 1101, 1090, 1, 0, 0, 0, 1101, 1094, 1, 
	0, 0, 0, 1101, 1098, 1, 0, 0, 0, 1102, 105, 1, 0, 0, 0, 1103, 1104, 5, 
	44, 0, 0, 1104, 1105, 3, 548, 274, 0, 1105, 1106, 5, 289, 0, 0, 1106, 1107, 
	3, 116, 58, 0, 1107, 1108, 5, 290, 0, 0, 1108, 1109, 3, 108, 54, 0, 1109, 
	107, 1, 0, 0, 0, 1110, 1130, 3, 110, 55, 0, 1111, 1112, 5, 49, 0, 0, 1112, 
	1114, 5, 231, 0, 0, 1113, 1115, 3, 110, 55, 0, 1114, 1113, 1, 0, 0, 0, 
	1114, 1115, 1, 0, 0, 0, 1115, 1130, 1, 0, 0, 0, 1116, 1117, 5, 49, 0, 0, 
	1117, 1118, 5, 231, 0, 0, 1118, 1120, 3, 548, 274, 0, 1119, 1121, 3, 110, 
	55, 0, 1120, 1119, 1, 0, 0, 0, 1120, 1121, 1, 0, 0, 0, 1121, 1130, 1, 0, 
	0, 0, 1122, 1123, 5, 49, 0, 0, 1123, 1124, 5, 231, 0, 0, 1124, 1125, 5, 
	3, 0, 0, 1125, 1127, 3, 548, 274, 0, 1126, 1128, 3, 110, 55, 0, 1127, 1126, 
	1, 0, 0, 0, 1127, 1128, 1, 0, 0, 0, 1128, 1130, 1, 0, 0, 0, 1129, 1110, 
	1, 0, 0, 0, 1129, 1111, 1, 0, 0, 0, 1129, 1116, 1, 0, 0, 0, 1129, 1122, 
	1, 0, 0, 0, 1130, 109, 1, 0, 0, 0, 1131, 1132, 5, 184, 0, 0, 1132, 1133, 
	5, 289, 0, 0, 1133, 1134, 3, 112, 56, 0, 1134, 1135, 5, 290, 0, 0, 1135, 
	111, 1, 0, 0, 0, 1136, 1139, 3, 114, 57, 0, 1137, 1139, 3, 52, 26, 0, 1138, 
	1136, 1, 0, 0, 0, 1138, 1137, 1, 0, 0, 0, 1139, 113, 1, 0, 0, 0, 1140, 
	1141, 5, 245, 0, 0, 1141, 1142, 5, 289, 0, 0, 1142, 1143, 3, 52, 26, 0, 
	1143, 1144, 5, 3, 0, 0, 1144, 1146, 3, 518, 259, 0, 1145, 1147, 3, 468, 
	234, 0, 1146, 1145, 1, 0, 0, 0, 1146, 1147, 1, 0, 0, 0, 1147, 1148, 1, 
	0, 0, 0, 1148, 1149, 5, 290, 0, 0, 1149, 115, 1, 0, 0, 0, 1150, 1151, 3, 
	118, 59, 0, 1151, 1153, 3, 120, 60, 0, 1152, 1154, 3, 122, 61, 0, 1153, 
	1152, 1, 0, 0, 0, 1153, 1154, 1, 0, 0, 0, 1154, 117, 1, 0, 0, 0, 1155, 
	1158, 3, 112, 56, 0, 1156, 1158, 3, 568, 284, 0, 1157, 1155, 1, 0, 0, 0, 
	1157, 1156, 1, 0, 0, 0, 1158, 119, 1, 0, 0, 0, 1159, 1160, 7, 6, 0, 0, 
	1160, 121, 1, 0, 0, 0, 1161, 1162, 5, 256, 0, 0, 1162, 1163, 5, 5, 0, 0, 
	1163, 1168, 3, 314, 157, 0, 1164, 1165, 5, 282, 0, 0, 1165, 1167, 3, 314, 
	157, 0, 1166, 1164, 1, 0, 0, 0, 1167, 1170, 1, 0, 0, 0, 1168, 1166, 1, 
	0, 0, 0, 1168, 1169, 1, 0, 0, 0, 1169, 123, 1, 0, 0, 0, 1170, 1168, 1, 
	0, 0, 0, 1171, 1172, 5, 270, 0, 0, 1172, 1174, 5, 289, 0, 0, 1173, 1175, 
	3, 368, 184, 0, 1174, 1173, 1, 0, 0, 0, 1174, 1175, 1, 0, 0, 0, 1175, 1176, 
	1, 0, 0, 0, 1176, 1177, 3, 56, 28, 0, 1177, 1178, 5, 155, 0, 0, 1178, 1179, 
	3, 132, 66, 0, 1179, 1180, 5, 167, 0, 0, 1180, 1181, 5, 289, 0, 0, 1181, 
	1182, 3, 126, 63, 0, 1182, 1183, 5, 290, 0, 0, 1183, 1184, 5, 271, 0, 0, 
	1184, 1185, 3, 460, 230, 0, 1185, 1187, 5, 290, 0, 0, 1186, 1188, 3, 292, 
	146, 0, 1187, 1186, 1, 0, 0, 0, 1187, 1188, 1, 0, 0, 0, 1188, 125, 1, 0, 
	0, 0, 1189, 1190, 6, 63, -1, 0, 1190, 1191, 3, 128, 64, 0, 1191, 1197, 
	1, 0, 0, 0, 1192, 1193, 10, 1, 0, 0, 1193, 1194, 5, 293, 0, 0, 1194, 1196, 
	3, 128, 64, 0, 1195, 1192, 1, 0, 0, 0, 1196, 1199, 1, 0, 0, 0, 1197, 1195, 
	1, 0, 0, 0, 1197, 1198, 1, 0, 0, 0, 1198, 127, 1, 0, 0, 0, 1199, 1197, 
	1, 0, 0, 0, 1200, 1201, 6, 64, -1, 0, 1201, 1202, 3, 130, 65, 0, 1202, 
	1207, 1, 0, 0, 0, 1203, 1204, 10, 1, 0, 0, 1204, 1206, 3, 130, 65, 0, 1205, 
	1203, 1, 0, 0, 0, 1206, 1209, 1, 0, 0, 0, 1207, 1205, 1, 0, 0, 0, 1207, 
	1208, 1, 0, 0, 0, 1208, 129, 1, 0, 0, 0, 1209, 1207, 1, 0, 0, 0, 1210, 
	1216, 3, 548, 274, 0, 1211, 1212, 5, 289, 0, 0, 1212, 1213, 3, 126, 63, 
	0, 1213, 1214, 5, 290, 0, 0, 1214, 1216, 1, 0, 0, 0, 1215, 1210, 1, 0, 
	0, 0, 1215, 1211, 1, 0, 0, 0, 1216, 131, 1, 0, 0, 0, 1217, 1222, 3, 134, 
	67, 0, 1218, 1219, 5, 282, 0, 0, 1219, 1221, 3, 134, 67, 0, 1220, 1218, 
	1, 0, 0, 0, 1221, 1224, 1, 0, 0, 0, 1222, 1220, 1, 0, 0, 0, 1222, 1223, 
	1, 0, 0, 0, 1223, 133, 1, 0, 0, 0, 1224, 1222, 1, 0, 0, 0, 1225, 1226, 
	3, 314, 157, 0, 1226, 1227, 5, 3, 0, 0, 1227, 1228, 3, 548, 274, 0, 1228, 
	135, 1, 0, 0, 0, 1229, 1231, 3, 318, 159, 0, 1230, 1232, 3, 154, 77, 0, 
	1231, 1230, 1, 0, 0, 0, 1231, 1232, 1, 0, 0, 0, 1232, 137, 1, 0, 0, 0, 
	1233, 1237, 3, 100, 50, 0, 1234, 1236, 3, 140, 70, 0, 1235, 1234, 1, 0, 
	0, 0, 1236, 1239, 1, 0, 0, 0, 1237, 1235, 1, 0, 0, 0, 1237, 1238, 1, 0, 
	0, 0, 1238, 139, 1, 0, 0, 0, 1239, 1237, 1, 0, 0, 0, 1240, 1242, 3, 232, 
	116, 0, 1241, 1240, 1, 0, 0, 0, 1241, 1242, 1, 0, 0, 0, 1242, 1243, 1, 
	0, 0, 0, 1243, 1245, 3, 230, 115, 0, 1244, 1246, 3, 146, 73, 0, 1245, 1244, 
	1, 0, 0, 0, 1245, 1246, 1, 0, 0, 0, 1246, 1247, 1, 0, 0, 0, 1247, 1249, 
	5, 7, 0, 0, 1248, 1250, 3, 412, 206, 0, 1249, 1248, 1, 0, 0, 0, 1249, 1250, 
	1, 0, 0, 0, 1250, 1251, 1, 0, 0, 0, 1251, 1253, 3, 100, 50, 0, 1252, 1254, 
	3, 142, 71, 0, 1253, 1252, 1, 0, 0, 0, 1253, 1254, 1, 0, 0, 0, 1254, 141, 
	1, 0, 0, 0, 1255, 1257, 3, 144, 72, 0, 1256, 1255, 1, 0, 0, 0, 1257, 1258, 
	1, 0, 0, 0, 1258, 1256, 1, 0, 0, 0, 1258, 1259, 1, 0, 0, 0, 1259, 143, 
	1, 0, 0, 0, 1260, 1263, 3, 270, 135, 0, 1261, 1263, 3, 272, 136, 0, 1262, 
	1260, 1, 0, 0, 0, 1262, 1261, 1, 0, 0, 0, 1263, 145, 1, 0, 0, 0, 1264, 
	1265, 7, 7, 0, 0, 1265, 147, 1, 0, 0, 0, 1266, 1268, 3, 156, 78, 0, 1267, 
	1269, 3, 412, 206, 0, 1268, 1267, 1, 0, 0, 0, 1268, 1269, 1, 0, 0, 0, 1269, 
	1271, 1, 0, 0, 0, 1270, 1272, 3, 154, 77, 0, 1271, 1270, 1, 0, 0, 0, 1271, 
	1272, 1, 0, 0, 0, 1272, 1274, 1, 0, 0, 0, 1273, 1275, 3, 152, 76, 0, 1274, 
	1273, 1, 0, 0, 0, 1274, 1275, 1, 0, 0, 0, 1275, 1277, 1, 0, 0, 0, 1276, 
	1278, 3, 150, 75, 0, 1277, 1276, 1, 0, 0, 0, 1277, 1278, 1, 0, 0, 0, 1278, 
	149, 1, 0, 0, 0, 1279, 1280, 5, 15, 0, 0, 1280, 1281, 5, 42, 0, 0, 1281, 
	1282, 5, 61, 0, 0, 1282, 1283, 5, 3, 0, 0, 1283, 1284, 5, 27, 0, 0, 1284, 
	1291, 3, 314, 157, 0, 1285, 1286, 5, 15, 0, 0, 1286, 1287, 5, 43, 0, 0, 
	1287, 1288, 5, 3, 0, 0, 1288, 1289, 5, 27, 0, 0, 1289, 1291, 3, 314, 157, 
	0, 1290, 1279, 1, 0, 0, 0, 1290, 1285, 1, 0, 0, 0, 1291, 151, 1, 0, 0, 
	0, 1292, 1293, 5, 49, 0, 0, 1293, 1295, 5, 28, 0, 0, 1294, 1296, 3, 292, 
	146, 0, 1295, 1294, 1, 0, 0, 0, 1295, 1296, 1, 0, 0, 0, 1296, 153, 1, 0, 
	0, 0, 1297, 1298, 5, 3, 0, 0, 1298, 1343, 3, 548, 274, 0, 1299, 1343, 3, 
	548, 274, 0, 1300, 1301, 5, 3, 0, 0, 1301, 1302, 3, 548, 274, 0, 1302, 
	1304, 3, 218, 109, 0, 1303, 1305, 3, 292, 146, 0, 1304, 1303, 1, 0, 0, 
	0, 1304, 1305, 1, 0, 0, 0, 1305, 1343, 1, 0, 0, 0, 1306, 1307, 5, 3, 0, 
	0, 1307, 1308, 3, 548, 274, 0, 1308, 1310, 3, 202, 101, 0, 1309, 1311, 
	3, 292, 146, 0, 1310, 1309, 1, 0, 0, 0, 1310, 1311, 1, 0, 0, 0, 1311, 1343, 
	1, 0, 0, 0, 1312, 1313, 5, 3, 0, 0, 1313, 1314, 3, 548, 274, 0, 1314, 1315, 
	3, 200, 100, 0, 1315, 1316, 6, 77, -1, 0, 1316, 1343, 1, 0, 0, 0, 1317, 
	1318, 3, 548, 274, 0, 1318, 1320, 3, 218, 109, 0, 1319, 1321, 3, 292, 146, 
	0, 1320, 1319, 1, 0, 0, 0, 1320, 1321, 1, 0, 0, 0, 1321, 1343, 1, 0, 0, 
	0, 1322, 1323, 3, 548, 274, 0, 1323, 1325, 3, 202, 101, 0, 1324, 1326, 
	3, 292, 146, 0, 1325, 1324, 1, 0, 0, 0, 1325, 1326, 1, 0, 0, 0, 1326, 1343, 
	1, 0, 0, 0, 1327, 1328, 3, 548, 274, 0, 1328, 1329, 3, 200, 100, 0, 1329, 
	1330, 6, 77, -1, 0, 1330, 1343, 1, 0, 0, 0, 1331, 1333, 3, 218, 109, 0, 
	1332, 1334, 3, 292, 146, 0, 1333, 1332, 1, 0, 0, 0, 1333, 1334, 1, 0, 0, 
	0, 1334, 1343, 1, 0, 0, 0, 1335, 1337, 3, 202, 101, 0, 1336, 1338, 3, 292, 
	146, 0, 1337, 1336, 1, 0, 0, 0, 1337, 1338, 1, 0, 0, 0, 1338, 1343, 1, 
	0, 0, 0, 1339, 1340, 3, 200, 100, 0, 1340, 1341, 6, 77, -1, 0, 1341, 1343, 
	1, 0, 0, 0, 1342, 1297, 1, 0, 0, 0, 1342, 1299, 1, 0, 0, 0, 1342, 1300, 
	1, 0, 0, 0, 1342, 1306, 1, 0, 0, 0, 1342, 1312, 1, 0, 0, 0, 1342, 1317, 
	1, 0, 0, 0, 1342, 1322, 1, 0, 0, 0, 1342, 1327, 1, 0, 0, 0, 1342, 1331, 
	1, 0, 0, 0, 1342, 1335, 1, 0, 0, 0, 1342, 1339, 1, 0, 0, 0, 1343, 155, 
	1, 0, 0, 0, 1344, 1365, 3, 174, 87, 0, 1345, 1365, 3, 158, 79, 0, 1346, 
	1347, 3, 546, 273, 0, 1347, 1348, 5, 291, 0, 0, 1348, 1349, 6, 78, -1, 
	0, 1349, 1365, 1, 0, 0, 0, 1350, 1351, 3, 546, 273, 0, 1351, 1352, 5, 283, 
	0, 0, 1352, 1353, 5, 289, 0, 0, 1353, 1354, 6, 78, -1, 0, 1354, 1365, 1, 
	0, 0, 0, 1355, 1356, 3, 174, 87, 0, 1356, 1357, 5, 291, 0, 0, 1357, 1358, 
	6, 78, -1, 0, 1358, 1365, 1, 0, 0, 0, 1359, 1360, 3, 174, 87, 0, 1360, 
	1361, 5, 283, 0, 0, 1361, 1362, 5, 289, 0, 0, 1362, 1363, 6, 78, -1, 0, 
	1363, 1365, 1, 0, 0, 0, 1364, 1344, 1, 0, 0, 0, 1364, 1345, 1, 0, 0, 0, 
	1364, 1346, 1, 0, 0, 0, 1364, 1350, 1, 0, 0, 0, 1364, 1355, 1, 0, 0, 0, 
	1364, 1359, 1, 0, 0, 0, 1365, 157, 1, 0, 0, 0, 1366, 1369, 3, 160, 80, 
	0, 1367, 1369, 3, 172, 86, 0, 1368, 1366, 1, 0, 0, 0, 1368, 1367, 1, 0, 
	0, 0, 1369, 159, 1, 0, 0, 0, 1370, 1373, 3, 546, 273, 0, 1371, 1373, 3, 
	162, 81, 0, 1372, 1370, 1, 0, 0, 0, 1372, 1371, 1, 0, 0, 0, 1373, 161, 
	1, 0, 0, 0, 1374, 1375, 6, 81, -1, 0, 1375, 1376, 3, 164, 82, 0, 1376, 
	1382, 1, 0, 0, 0, 1377, 1378, 10, 1, 0, 0, 1378, 1379, 5, 283, 0, 0, 1379, 
	1381, 3, 548, 274, 0, 1380, 1377, 1, 0, 0, 0, 1381, 1384, 1, 0, 0, 0, 1382, 
	1380, 1, 0, 0, 0, 1382, 1383, 1, 0, 0, 0, 1383, 163, 1, 0, 0, 0, 1384, 
	1382, 1, 0, 0, 0, 1385, 1386, 6, 82, -1, 0, 1386, 1387, 3, 548, 274, 0, 
	1387, 1388, 5, 301, 0, 0, 1388, 1389, 3, 548, 274, 0, 1389, 1400, 1, 0, 
	0, 0, 1390, 1391, 3, 548, 274, 0, 1391, 1392, 5, 301, 0, 0, 1392, 1393, 
	5, 324, 0, 0, 1393, 1400, 1, 0, 0, 0, 1394, 1395, 3, 548, 274, 0, 1395, 
	1396, 5, 301, 0, 0, 1396, 1397, 3, 568, 284, 0, 1397, 1398, 3, 548, 274, 
	0, 1398, 1400, 1, 0, 0, 0, 1399, 1385, 1, 0, 0, 0, 1399, 1390, 1, 0, 0, 
	0, 1399, 1394, 1, 0, 0, 0, 1400, 1414, 1, 0, 0, 0, 1401, 1402, 10, 5, 0, 
	0, 1402, 1403, 5, 301, 0, 0, 1403, 1413, 3, 164, 82, 6, 1404, 1405, 10, 
	3, 0, 0, 1405, 1406, 5, 301, 0, 0, 1406, 1413, 5, 324, 0, 0, 1407, 1408, 
	10, 1, 0, 0, 1408, 1409, 5, 301, 0, 0, 1409, 1410, 3, 568, 284, 0, 1410, 
	1411, 3, 548, 274, 0, 1411, 1413, 1, 0, 0, 0, 1412, 1401, 1, 0, 0, 0, 1412, 
	1404, 1, 0, 0, 0, 1412, 1407, 1, 0, 0, 0, 1413, 1416, 1, 0, 0, 0, 1414, 
	1412, 1, 0, 0, 0, 1414, 1415, 1, 0, 0, 0, 1415, 165, 1, 0, 0, 0, 1416, 
	1414, 1, 0, 0, 0, 1417, 1418, 6, 83, -1, 0, 1418, 1419, 5, 269, 0, 0, 1419, 
	1420, 3, 168, 84, 0, 1420, 1433, 1, 0, 0, 0, 1421, 1422, 10, 2, 0, 0, 1422, 
	1423, 3, 170, 85, 0, 1423, 1424, 3, 168, 84, 0, 1424, 1432, 1, 0, 0, 0, 
	1425, 1426, 10, 1, 0, 0, 1426, 1427, 3, 170, 85, 0, 1427, 1428, 3, 568, 
	284, 0, 1428, 1429, 3, 170, 85, 0, 1429, 1430, 3, 168, 84, 0, 1430, 1432, 
	1, 0, 0, 0, 1431, 1421, 1, 0, 0, 0, 1431, 1425, 1, 0, 0, 0, 1432, 1435, 
	1, 0, 0, 0, 1433, 1431, 1, 0, 0, 0, 1433, 1434, 1, 0, 0, 0, 1434, 167, 
	1, 0, 0, 0, 1435, 1433, 1, 0, 0, 0, 1436, 1439, 3, 548, 274, 0, 1437, 1439, 
	5, 324, 0, 0, 1438, 1436, 1, 0, 0, 0, 1438, 1437, 1, 0, 0, 0, 1439, 169, 
	1, 0, 0, 0, 1440, 1441, 5, 301, 0, 0, 1441, 1442, 5, 269, 0, 0, 1442, 1443, 
	5, 294, 0, 0, 1443, 171, 1, 0, 0, 0, 1444, 1451, 3, 166, 83, 0, 1445, 1446, 
	3, 166, 83, 0, 1446, 1447, 3, 170, 85, 0, 1447, 1448, 3, 568, 284, 0, 1448, 
	1449, 3, 548, 274, 0, 1449, 1451, 1, 0, 0, 0, 1450, 1444, 1, 0, 0, 0, 1450, 
	1445, 1, 0, 0, 0, 1451, 173, 1, 0, 0, 0, 1452, 1454, 3, 176, 88, 0, 1453, 
	1455, 3, 178, 89, 0, 1454, 1453, 1, 0, 0, 0, 1454, 1455, 1, 0, 0, 0, 1455, 
	1456, 1, 0, 0, 0, 1456, 1457, 5, 290, 0, 0, 1457, 1463, 1, 0, 0, 0, 1458, 
	1459, 5, 46, 0, 0, 1459, 1460, 5, 289, 0, 0, 1460, 1461, 5, 40, 0, 0, 1461, 
	1463, 6, 87, -1, 0, 1462, 1452, 1, 0, 0, 0, 1462, 1458, 1, 0, 0, 0, 1463, 
	175, 1, 0, 0, 0, 1464, 1465, 5, 46, 0, 0, 1465, 1466, 5, 289, 0, 0, 1466, 
	1471, 3, 180, 90, 0, 1467, 1468, 5, 282, 0, 0, 1468, 1470, 3, 180, 90, 
	0, 1469, 1467, 1, 0, 0, 0, 1470, 1473, 1, 0, 0, 0, 1471, 1469, 1, 0, 0, 
	0, 1471, 1472, 1, 0, 0, 0, 1472, 177, 1, 0, 0, 0, 1473, 1471, 1, 0, 0, 
	0, 1474, 1475, 5, 282, 0, 0, 1475, 1476, 3, 396, 198, 0, 1476, 179, 1, 
	0, 0, 0, 1477, 1479, 3, 314, 157, 0, 1478, 1480, 3, 434, 217, 0, 1479, 
	1478, 1, 0, 0, 0, 1479, 1480, 1, 0, 0, 0, 1480, 181, 1, 0, 0, 0, 1481, 
	1482, 3, 228, 114, 0, 1482, 1487, 3, 184, 92, 0, 1483, 1484, 5, 282, 0, 
	0, 1484, 1486, 3, 184, 92, 0, 1485, 1483, 1, 0, 0, 0, 1486, 1489, 1, 0, 
	0, 0, 1487, 1485, 1, 0, 0, 0, 1487, 1488, 1, 0, 0, 0, 1488, 183, 1, 0, 
	0, 0, 1489, 1487, 1, 0, 0, 0, 1490, 1521, 3, 314, 157, 0, 1491, 1521, 3, 
	190, 95, 0, 1492, 1521, 3, 196, 98, 0, 1493, 1521, 3, 198, 99, 0, 1494, 
	1521, 3, 186, 93, 0, 1495, 1521, 3, 396, 198, 0, 1496, 1497, 5, 289, 0, 
	0, 1497, 1498, 3, 196, 98, 0, 1498, 1499, 5, 290, 0, 0, 1499, 1500, 6, 
	92, -1, 0, 1500, 1521, 1, 0, 0, 0, 1501, 1502, 5, 289, 0, 0, 1502, 1503, 
	3, 198, 99, 0, 1503, 1504, 5, 290, 0, 0, 1504, 1505, 6, 92, -1, 0, 1505, 
	1521, 1, 0, 0, 0, 1506, 1507, 5, 289, 0, 0, 1507, 1508, 3, 186, 93, 0, 
	1508, 1509, 5, 290, 0, 0, 1509, 1510, 6, 92, -1, 0, 1510, 1521, 1, 0, 0, 
	0, 1511, 1512, 5, 289, 0, 0, 1512, 1513, 3, 396, 198, 0, 1513, 1514, 5, 
	290, 0, 0, 1514, 1515, 6, 92, -1, 0, 1515, 1521, 1, 0, 0, 0, 1516, 1517, 
	5, 40, 0, 0, 1517, 1521, 6, 92, -1, 0, 1518, 1519, 5, 49, 0, 0, 1519, 1521, 
	6, 92, -1, 0, 1520, 1490, 1, 0, 0, 0, 1520, 1491, 1, 0, 0, 0, 1520, 1492, 
	1, 0, 0, 0, 1520, 1493, 1, 0, 0, 0, 1520, 1494, 1, 0, 0, 0, 1520, 1495, 
	1, 0, 0, 0, 1520, 1496, 1, 0, 0, 0, 1520, 1501, 1, 0, 0, 0, 1520, 1506, 
	1, 0, 0, 0, 1520, 1511, 1, 0, 0, 0, 1520, 1516, 1, 0, 0, 0, 1520, 1518, 
	1, 0, 0, 0, 1521, 185, 1, 0, 0, 0, 1522, 1523, 5, 91, 0, 0, 1523, 1524, 
	3, 188, 94, 0, 1524, 187, 1, 0, 0, 0, 1525, 1528, 3, 546, 273, 0, 1526, 
	1528, 5, 268, 0, 0, 1527, 1525, 1, 0, 0, 0, 1527, 1526, 1, 0, 0, 0, 1528, 
	189, 1, 0, 0, 0, 1529, 1530, 5, 235, 0, 0, 1530, 1531, 5, 289, 0, 0, 1531, 
	1532, 3, 192, 96, 0, 1532, 1533, 5, 290, 0, 0, 1533, 191, 1, 0, 0, 0, 1534, 
	1539, 3, 194, 97, 0, 1535, 1536, 5, 282, 0, 0, 1536, 1538, 3, 194, 97, 
	0, 1537, 1535, 1, 0, 0, 0, 1538, 1541, 1, 0, 0, 0, 1539, 1537, 1, 0, 0, 
	0, 1539, 1540, 1, 0, 0, 0, 1540, 193, 1, 0, 0, 0, 1541, 1539, 1, 0, 0, 
	0, 1542, 1543, 3, 548, 274, 0, 1543, 195, 1, 0, 0, 0, 1544, 1545, 5, 212, 
	0, 0, 1545, 1549, 3, 102, 51, 0, 1546, 1547, 5, 212, 0, 0, 1547, 1549, 
	3, 546, 273, 0, 1548, 1544, 1, 0, 0, 0, 1548, 1546, 1, 0, 0, 0, 1549, 197, 
	1, 0, 0, 0, 1550, 1551, 5, 160, 0, 0, 1551, 1552, 3, 546, 273, 0, 1552, 
	199, 1, 0, 0, 0, 1553, 1554, 5, 267, 0, 0, 1554, 1555, 3, 314, 157, 0, 
	1555, 201, 1, 0, 0, 0, 1556, 1558, 5, 39, 0, 0, 1557, 1559, 3, 216, 108, 
	0, 1558, 1557, 1, 0, 0, 0, 1558, 1559, 1, 0, 0, 0, 1559, 1560, 1, 0, 0, 
	0, 1560, 1561, 5, 289, 0, 0, 1561, 1562, 3, 212, 106, 0, 1562, 1563, 5, 
	15, 0, 0, 1563, 1564, 3, 546, 273, 0, 1564, 1565, 5, 18, 0, 0, 1565, 1566, 
	3, 204, 102, 0, 1566, 1567, 5, 290, 0, 0, 1567, 203, 1, 0, 0, 0, 1568, 
	1569, 3, 206, 103, 0, 1569, 1570, 5, 290, 0, 0, 1570, 205, 1, 0, 0, 0, 
	1571, 1572, 6, 103, -1, 0, 1572, 1573, 5, 289, 0, 0, 1573, 1574, 3, 208, 
	104, 0, 1574, 1580, 1, 0, 0, 0, 1575, 1576, 10, 1, 0, 0, 1576, 1577, 5, 
	282, 0, 0, 1577, 1579, 3, 208, 104, 0, 1578, 1575, 1, 0, 0, 0, 1579, 1582, 
	1, 0, 0, 0, 1580, 1578, 1, 0, 0, 0, 1580, 1581, 1, 0, 0, 0, 1581, 207, 
	1, 0, 0, 0, 1582, 1580, 1, 0, 0, 0, 1583, 1585, 3, 212, 106, 0, 1584, 1586, 
	3, 210, 105, 0, 1585, 1584, 1, 0, 0, 0, 1585, 1586, 1, 0, 0, 0, 1586, 209, 
	1, 0, 0, 0, 1587, 1589, 5, 3, 0, 0, 1588, 1587, 1, 0, 0, 0, 1588, 1589, 
	1, 0, 0, 0, 1589, 1590, 1, 0, 0, 0, 1590, 1596, 3, 588, 294, 0, 1591, 1593, 
	5, 3, 0, 0, 1592, 1591, 1, 0, 0, 0, 1592, 1593, 1, 0, 0, 0, 1593, 1594, 
	1, 0, 0, 0, 1594, 1596, 3, 580, 290, 0, 1595, 1588, 1, 0, 0, 0, 1595, 1592, 
	1, 0, 0, 0, 1596, 211, 1, 0, 0, 0, 1597, 1598, 5, 289, 0, 0, 1598, 1599, 
	3, 214, 107, 0, 1599, 1600, 5, 290, 0, 0, 1600, 1603, 1, 0, 0, 0, 1601, 
	1603, 3, 214, 107, 0, 1602, 1597, 1, 0, 0, 0, 1602, 1601, 1, 0, 0, 0, 1603, 
	213, 1, 0, 0, 0, 1604, 1609, 3, 546, 273, 0, 1605, 1606, 5, 282, 0, 0, 
	1606, 1608, 3, 546, 273, 0, 1607, 1605, 1, 0, 0, 0, 1608, 1611, 1, 0, 0, 
	0, 1609, 1607, 1, 0, 0, 0, 1609, 1610, 1, 0, 0, 0, 1610, 215, 1, 0, 0, 
	0, 1611, 1609, 1, 0, 0, 0, 1612, 1613, 5, 14, 0, 0, 1613, 1617, 5, 26, 
	0, 0, 1614, 1615, 5, 19, 0, 0, 1615, 1617, 5, 26, 0, 0, 1616, 1612, 1, 
	0, 0, 0, 1616, 1614, 1, 0, 0, 0, 1617, 217, 1, 0, 0, 0, 1618, 1619, 5, 
	34, 0, 0, 1619, 1620, 5, 289, 0, 0, 1620, 1621, 3, 220, 110, 0, 1621, 1622, 
	5, 15, 0, 0, 1622, 1623, 3, 316, 158, 0, 1623, 1624, 5, 18, 0, 0, 1624, 
	1625, 5, 289, 0, 0, 1625, 1626, 3, 224, 112, 0, 1626, 1627, 5, 290, 0, 
	0, 1627, 1628, 5, 290, 0, 0, 1628, 219, 1, 0, 0, 0, 1629, 1634, 3, 222, 
	111, 0, 1630, 1631, 5, 282, 0, 0, 1631, 1633, 3, 222, 111, 0, 1632, 1630, 
	1, 0, 0, 0, 1633, 1636, 1, 0, 0, 0, 1634, 1632, 1, 0, 0, 0, 1634, 1635, 
	1, 0, 0, 0, 1635, 221, 1, 0, 0, 0, 1636, 1634, 1, 0, 0, 0, 1637, 1639, 
	3, 314, 157, 0, 1638, 1640, 3, 292, 146, 0, 1639, 1638, 1, 0, 0, 0, 1639, 
	1640, 1, 0, 0, 0, 1640, 223, 1, 0, 0, 0, 1641, 1646, 3, 226, 113, 0, 1642, 
	1643, 5, 282, 0, 0, 1643, 1645, 3, 226, 113, 0, 1644, 1642, 1, 0, 0, 0, 
	1645, 1648, 1, 0, 0, 0, 1646, 1644, 1, 0, 0, 0, 1646, 1647, 1, 0, 0, 0, 
	1647, 225, 1, 0, 0, 0, 1648, 1646, 1, 0, 0, 0, 1649, 1651, 3, 314, 157, 
	0, 1650, 1652, 3, 292, 146, 0, 1651, 1650, 1, 0, 0, 0, 1651, 1652, 1, 0, 
	0, 0, 1652, 227, 1, 0, 0, 0, 1653, 1657, 3, 546, 273, 0, 1654, 1655, 5, 
	248, 0, 0, 1655, 1657, 5, 289, 0, 0, 1656, 1653, 1, 0, 0, 0, 1656, 1654, 
	1, 0, 0, 0, 1657, 229, 1, 0, 0, 0, 1658, 1673, 5, 6, 0, 0, 1659, 1661, 
	5, 17, 0, 0, 1660, 1662, 3, 40, 20, 0, 1661, 1660, 1, 0, 0, 0, 1661, 1662, 
	1, 0, 0, 0, 1662, 1673, 1, 0, 0, 0, 1663, 1673, 5, 20, 0, 0, 1664, 1666, 
	5, 22, 0, 0, 1665, 1667, 3, 40, 20, 0, 1666, 1665, 1, 0, 0, 0, 1666, 1667, 
	1, 0, 0, 0, 1667, 1673, 1, 0, 0, 0, 1668, 1670, 5, 36, 0, 0, 1669, 1671, 
	3, 40, 20, 0, 1670, 1669, 1, 0, 0, 0, 1670, 1671, 1, 0, 0, 0, 1671, 1673, 
	1, 0, 0, 0, 1672, 1658, 1, 0, 0, 0, 1672, 1659, 1, 0, 0, 0, 1672, 1663, 
	1, 0, 0, 0, 1672, 1664, 1, 0, 0, 0, 1672, 1668, 1, 0, 0, 0, 1673, 231, 
	1, 0, 0, 0, 1674, 1675, 5, 266, 0, 0, 1675, 233, 1, 0, 0, 0, 1676, 1677, 
	5, 44, 0, 0, 1677, 1678, 5, 42, 0, 0, 1678, 1679, 5, 289, 0, 0, 1679, 1680, 
	3, 610, 305, 0, 1680, 1681, 5, 33, 0, 0, 1681, 1682, 5, 290, 0, 0, 1682, 
	235, 1, 0, 0, 0, 1683, 1688, 5, 39, 0, 0, 1684, 1685, 5, 19, 0, 0, 1685, 
	1689, 5, 26, 0, 0, 1686, 1687, 5, 14, 0, 0, 1687, 1689, 5, 26, 0, 0, 1688, 
	1684, 1, 0, 0, 0, 1688, 1686, 1, 0, 0, 0, 1688, 1689, 1, 0, 0, 0, 1689, 
	1690, 1, 0, 0, 0, 1690, 1693, 5, 289, 0, 0, 1691, 1694, 3, 238, 119, 0, 
	1692, 1694, 3, 240, 120, 0, 1693, 1691, 1, 0, 0, 0, 1693, 1692, 1, 0, 0, 
	0, 1694, 1696, 1, 0, 0, 0, 1695, 1697, 3, 292, 146, 0, 1696, 1695, 1, 0, 
	0, 0, 1696, 1697, 1, 0, 0, 0, 1697, 237, 1, 0, 0, 0, 1698, 1699, 3, 602, 
	301, 0, 1699, 1700, 5, 15, 0, 0, 1700, 1701, 3, 602, 301, 0, 1701, 1702, 
	5, 18, 0, 0, 1702, 1703, 5, 289, 0, 0, 1703, 1704, 3, 244, 122, 0, 1704, 
	1705, 5, 290, 0, 0, 1705, 239, 1, 0, 0, 0, 1706, 1707, 3, 242, 121, 0, 
	1707, 1708, 5, 15, 0, 0, 1708, 1709, 3, 602, 301, 0, 1709, 1710, 5, 18, 
	0, 0, 1710, 1711, 5, 289, 0, 0, 1711, 1712, 3, 248, 124, 0, 1712, 1713, 
	5, 290, 0, 0, 1713, 241, 1, 0, 0, 0, 1714, 1719, 3, 602, 301, 0, 1715, 
	1716, 5, 282, 0, 0, 1716, 1718, 3, 602, 301, 0, 1717, 1715, 1, 0, 0, 0, 
	1718, 1721, 1, 0, 0, 0, 1719, 1717, 1, 0, 0, 0, 1719, 1720, 1, 0, 0, 0, 
	1720, 243, 1, 0, 0, 0, 1721, 1719, 1, 0, 0, 0, 1722, 1727, 3, 246, 123, 
	0, 1723, 1724, 5, 282, 0, 0, 1724, 1726, 3, 246, 123, 0, 1725, 1723, 1, 
	0, 0, 0, 1726, 1729, 1, 0, 0, 0, 1727, 1725, 1, 0, 0, 0, 1727, 1728, 1, 
	0, 0, 0, 1728, 245, 1, 0, 0, 0, 1729, 1727, 1, 0, 0, 0, 1730, 1732, 3, 
	602, 301, 0, 1731, 1733, 3, 292, 146, 0, 1732, 1731, 1, 0, 0, 0, 1732, 
	1733, 1, 0, 0, 0, 1733, 247, 1, 0, 0, 0, 1734, 1735, 5, 289, 0, 0, 1735, 
	1736, 3, 244, 122, 0, 1736, 1737, 5, 290, 0, 0, 1737, 249, 1, 0, 0, 0, 
	1738, 1739, 5, 34, 0, 0, 1739, 1740, 5, 289, 0, 0, 1740, 1741, 3, 256, 
	128, 0, 1741, 1742, 5, 15, 0, 0, 1742, 1743, 3, 602, 301, 0, 1743, 1744, 
	5, 18, 0, 0, 1744, 1745, 5, 289, 0, 0, 1745, 1746, 3, 252, 126, 0, 1746, 
	1747, 5, 290, 0, 0, 1747, 1749, 5, 290, 0, 0, 1748, 1750, 3, 292, 146, 
	0, 1749, 1748, 1, 0, 0, 0, 1749, 1750, 1, 0, 0, 0, 1750, 251, 1, 0, 0, 
	0, 1751, 1756, 3, 254, 127, 0, 1752, 1753, 5, 282, 0, 0, 1753, 1755, 3, 
	254, 127, 0, 1754, 1752, 1, 0, 0, 0, 1755, 1758, 1, 0, 0, 0, 1756, 1754, 
	1, 0, 0, 0, 1756, 1757, 1, 0, 0, 0, 1757, 253, 1, 0, 0, 0, 1758, 1756, 
	1, 0, 0, 0, 1759, 1761, 3, 602, 301, 0, 1760, 1762, 3, 292, 146, 0, 1761, 
	1760, 1, 0, 0, 0, 1761, 1762, 1, 0, 0, 0, 1762, 255, 1, 0, 0, 0, 1763, 
	1768, 3, 258, 129, 0, 1764, 1765, 5, 282, 0, 0, 1765, 1767, 3, 258, 129, 
	0, 1766, 1764, 1, 0, 0, 0, 1767, 1770, 1, 0, 0, 0, 1768, 1766, 1, 0, 0, 
	0, 1768, 1769, 1, 0, 0, 0, 1769, 257, 1, 0, 0, 0, 1770, 1768, 1, 0, 0, 
	0, 1771, 1773, 3, 292, 146, 0, 1772, 1771, 1, 0, 0, 0, 1772, 1773, 1, 0, 
	0, 0, 1773, 259, 1, 0, 0, 0, 1774, 1775, 6, 130, -1, 0, 1775, 1777, 3, 
	606, 303, 0, 1776, 1778, 3, 292, 146, 0, 1777, 1776, 1, 0, 0, 0, 1777, 
	1778, 1, 0, 0, 0, 1778, 1784, 1, 0, 0, 0, 1779, 1780, 5, 15, 0, 0, 1780, 
	1781, 5, 43, 0, 0, 1781, 1782, 5, 3, 0, 0, 1782, 1783, 5, 27, 0, 0, 1783, 
	1785, 3, 314, 157, 0, 1784, 1779, 1, 0, 0, 0, 1784, 1785, 1, 0, 0, 0, 1785, 
	1812, 1, 0, 0, 0, 1786, 1796, 5, 289, 0, 0, 1787, 1788, 3, 260, 130, 0, 
	1788, 1789, 3, 264, 132, 0, 1789, 1790, 3, 260, 130, 0, 1790, 1797, 1, 
	0, 0, 0, 1791, 1792, 3, 260, 130, 0, 1792, 1793, 3, 266, 133, 0, 1793, 
	1794, 3, 260, 130, 0, 1794, 1795, 3, 268, 134, 0, 1795, 1797, 1, 0, 0, 
	0, 1796, 1787, 1, 0, 0, 0, 1796, 1791, 1, 0, 0, 0, 1797, 1798, 1, 0, 0, 
	0, 1798, 1799, 5, 290, 0, 0, 1799, 1812, 1, 0, 0, 0, 1800, 1801, 5, 289, 
	0, 0, 1801, 1802, 3, 8, 4, 0, 1802, 1804, 5, 290, 0, 0, 1803, 1805, 3, 
	292, 146, 0, 1804, 1803, 1, 0, 0, 0, 1804, 1805, 1, 0, 0, 0, 1805, 1812, 
	1, 0, 0, 0, 1806, 1812, 3, 262, 131, 0, 1807, 1809, 3, 600, 300, 0, 1808, 
	1810, 3, 292, 146, 0, 1809, 1808, 1, 0, 0, 0, 1809, 1810, 1, 0, 0, 0, 1810, 
	1812, 1, 0, 0, 0, 1811, 1774, 1, 0, 0, 0, 1811, 1786, 1, 0, 0, 0, 1811, 
	1800, 1, 0, 0, 0, 1811, 1806, 1, 0, 0, 0, 1811, 1807, 1, 0, 0, 0, 1812, 
	1824, 1, 0, 0, 0, 1813, 1814, 10, 6, 0, 0, 1814, 1815, 3, 264, 132, 0, 
	1815, 1816, 3, 260, 130, 7, 1816, 1823, 1, 0, 0, 0, 1817, 1818, 10, 5, 
	0, 0, 1818, 1819, 3, 266, 133, 0, 1819, 1820, 3, 260, 130, 0, 1820, 1821, 
	3, 268, 134, 0, 1821, 1823, 1, 0, 0, 0, 1822, 1813, 1, 0, 0, 0, 1822, 1817, 
	1, 0, 0, 0, 1823, 1826, 1, 0, 0, 0, 1824, 1822, 1, 0, 0, 0, 1824, 1825, 
	1, 0, 0, 0, 1825, 261, 1, 0, 0, 0, 1826, 1824, 1, 0, 0, 0, 1827, 1828, 
	5, 46, 0, 0, 1828, 1829, 5, 289, 0, 0, 1829, 1831, 5, 290, 0, 0, 1830, 
	1832, 3, 292, 146, 0, 1831, 1830, 1, 0, 0, 0, 1831, 1832, 1, 0, 0, 0, 1832, 
	1835, 1, 0, 0, 0, 1833, 1835, 3, 292, 146, 0, 1834, 1827, 1, 0, 0, 0, 1834, 
	1833, 1, 0, 0, 0, 1835, 1841, 1, 0, 0, 0, 1836, 1837, 5, 49, 0, 0, 1837, 
	1839, 5, 28, 0, 0, 1838, 1840, 3, 292, 146, 0, 1839, 1838, 1, 0, 0, 0, 
	1839, 1840, 1, 0, 0, 0, 1840, 1842, 1, 0, 0, 0, 1841, 1836, 1, 0, 0, 0, 
	1841, 1842, 1, 0, 0, 0, 1842, 263, 1, 0, 0, 0, 1843, 1844, 5, 6, 0, 0, 
	1844, 1847, 5, 7, 0, 0, 1845, 1847, 5, 282, 0, 0, 1846, 1843, 1, 0, 0, 
	0, 1846, 1845, 1, 0, 0, 0, 1847, 265, 1, 0, 0, 0, 1848, 1850, 5, 20, 0, 
	0, 1849, 1848, 1, 0, 0, 0, 1849, 1850, 1, 0, 0, 0, 1850, 1851, 1, 0, 0, 
	0, 1851, 1868, 5, 7, 0, 0, 1852, 1854, 5, 17, 0, 0, 1853, 1855, 5, 32, 
	0, 0, 1854, 1853, 1, 0, 0, 0, 1854, 1855, 1, 0, 0, 0, 1855, 1856, 1, 0, 
	0, 0, 1856, 1868, 5, 7, 0, 0, 1857, 1859, 5, 22, 0, 0, 1858, 1860, 5, 32, 
	0, 0, 1859, 1858, 1, 0, 0, 0, 1859, 1860, 1, 0, 0, 0, 1860, 1861, 1, 0, 
	0, 0, 1861, 1868, 5, 7, 0, 0, 1862, 1864, 5, 36, 0, 0, 1863, 1865, 5, 32, 
	0, 0, 1864, 1863, 1, 0, 0, 0, 1864, 1865, 1, 0, 0, 0, 1865, 1866, 1, 0, 
	0, 0, 1866, 1868, 5, 7, 0, 0, 1867, 1849, 1, 0, 0, 0, 1867, 1852, 1, 0, 
	0, 0, 1867, 1857, 1, 0, 0, 0, 1867, 1862, 1, 0, 0, 0, 1868, 267, 1, 0, 
	0, 0, 1869, 1872, 3, 270, 135, 0, 1870, 1872, 3, 272, 136, 0, 1871, 1869, 
	1, 0, 0, 0, 1871, 1870, 1, 0, 0, 0, 1872, 269, 1, 0, 0, 0, 1873, 1874, 
	5, 29, 0, 0, 1874, 1875, 3, 314, 157, 0, 1875, 271, 1, 0, 0, 0, 1876, 1877, 
	5, 47, 0, 0, 1877, 1878, 5, 289, 0, 0, 1878, 1879, 3, 286, 143, 0, 1879, 
	1880, 5, 290, 0, 0, 1880, 273, 1, 0, 0, 0, 1881, 1886, 3, 276, 138, 0, 
	1882, 1883, 5, 282, 0, 0, 1883, 1885, 3, 276, 138, 0, 1884, 1882, 1, 0, 
	0, 0, 1885, 1888, 1, 0, 0, 0, 1886, 1884, 1, 0, 0, 0, 1886, 1887, 1, 0, 
	0, 0, 1887, 275, 1, 0, 0, 0, 1888, 1886, 1, 0, 0, 0, 1889, 1892, 3, 280, 
	140, 0, 1890, 1892, 3, 278, 139, 0, 1891, 1889, 1, 0, 0, 0, 1891, 1890, 
	1, 0, 0, 0, 1892, 277, 1, 0, 0, 0, 1893, 1895, 3, 314, 157, 0, 1894, 1896, 
	3, 292, 146, 0, 1895, 1894, 1, 0, 0, 0, 1895, 1896, 1, 0, 0, 0, 1896, 279, 
	1, 0, 0, 0, 1897, 1898, 3, 314, 157, 0, 1898, 1899, 5, 283, 0, 0, 1899, 
	1901, 1, 0, 0, 0, 1900, 1897, 1, 0, 0, 0, 1900, 1901, 1, 0, 0, 0, 1901, 
	1902, 1, 0, 0, 0, 1902, 1904, 5, 281, 0, 0, 1903, 1905, 3, 282, 141, 0, 
	1904, 1903, 1, 0, 0, 0, 1904, 1905, 1, 0, 0, 0, 1905, 1907, 1, 0, 0, 0, 
	1906, 1908, 3, 284, 142, 0, 1907, 1906, 1, 0, 0, 0, 1907, 1908, 1, 0, 0, 
	0, 1908, 281, 1, 0, 0, 0, 1909, 1910, 5, 13, 0, 0, 1910, 1911, 5, 289, 
	0, 0, 1911, 1912, 3, 286, 143, 0, 1912, 1913, 5, 290, 0, 0, 1913, 283, 
	1, 0, 0, 0, 1914, 1915, 5, 38, 0, 0, 1915, 1916, 5, 289, 0, 0, 1916, 1917, 
	3, 288, 144, 0, 1917, 1918, 5, 290, 0, 0, 1918, 285, 1, 0, 0, 0, 1919, 
	1924, 3, 602, 301, 0, 1920, 1921, 5, 282, 0, 0, 1921, 1923, 3, 602, 301, 
	0, 1922, 1920, 1, 0, 0, 0, 1923, 1926, 1, 0, 0, 0, 1924, 1922, 1, 0, 0, 
	0, 1924, 1925, 1, 0, 0, 0, 1925, 287, 1, 0, 0, 0, 1926, 1924, 1, 0, 0, 
	0, 1927, 1932, 3, 290, 145, 0, 1928, 1929, 5, 282, 0, 0, 1929, 1931, 3, 
	290, 145, 0, 1930, 1928, 1, 0, 0, 0, 1931, 1934, 1, 0, 0, 0, 1932, 1930, 
	1, 0, 0, 0, 1932, 1933, 1, 0, 0, 0, 1933, 289, 1, 0, 0, 0, 1934, 1932, 
	1, 0, 0, 0, 1935, 1937, 3, 314, 157, 0, 1936, 1938, 5, 3, 0, 0, 1937, 1936, 
	1, 0, 0, 0, 1937, 1938, 1, 0, 0, 0, 1938, 1939, 1, 0, 0, 0, 1939, 1940, 
	3, 602, 301, 0, 1940, 291, 1, 0, 0, 0, 1941, 1943, 5, 3, 0, 0, 1942, 1941, 
	1, 0, 0, 0, 1942, 1943, 1, 0, 0, 0, 1943, 1944, 1, 0, 0, 0, 1944, 1945, 
	3, 604, 302, 0, 1945, 293, 1, 0, 0, 0, 1946, 1947, 5, 49, 0, 0, 1947, 1948, 
	5, 10, 0, 0, 1948, 1949, 5, 30, 0, 0, 1949, 1950, 5, 289, 0, 0, 1950, 1951, 
	3, 296, 148, 0, 1951, 1952, 5, 290, 0, 0, 1952, 295, 1, 0, 0, 0, 1953, 
	1954, 5, 12, 0, 0, 1954, 1955, 5, 284, 0, 0, 1955, 1956, 3, 314, 157, 0, 
	1956, 1957, 5, 282, 0, 0, 1957, 1958, 5, 8, 0, 0, 1958, 1959, 5, 284, 0, 
	0, 1959, 1960, 3, 314, 157, 0, 1960, 1966, 5, 282, 0, 0, 1961, 1962, 5, 
	24, 0, 0, 1962, 1963, 5, 284, 0, 0, 1963, 1964, 3, 314, 157, 0, 1964, 1965, 
	5, 282, 0, 0, 1965, 1967, 1, 0, 0, 0, 1966, 1961, 1, 0, 0, 0, 1966, 1967, 
	1, 0, 0, 0, 1967, 1968, 1, 0, 0, 0, 1968, 1969, 5, 35, 0, 0, 1969, 1970, 
	5, 284, 0, 0, 1970, 1971, 3, 314, 157, 0, 1971, 297, 1, 0, 0, 0, 1972, 
	1974, 5, 49, 0, 0, 1973, 1975, 5, 37, 0, 0, 1974, 1973, 1, 0, 0, 0, 1974, 
	1975, 1, 0, 0, 0, 1975, 1976, 1, 0, 0, 0, 1976, 1981, 3, 300, 150, 0, 1977, 
	1978, 5, 282, 0, 0, 1978, 1980, 3, 300, 150, 0, 1979, 1977, 1, 0, 0, 0, 
	1980, 1983, 1, 0, 0, 0, 1981, 1979, 1, 0, 0, 0, 1981, 1982, 1, 0, 0, 0, 
	1982, 299, 1, 0, 0, 0, 1983, 1981, 1, 0, 0, 0, 1984, 1987, 3, 302, 151, 
	0, 1985, 1987, 3, 304, 152, 0, 1986, 1984, 1, 0, 0, 0, 1986, 1985, 1, 0, 
	0, 0, 1987, 301, 1, 0, 0, 0, 1988, 1989, 3, 600, 300, 0, 1989, 1990, 5, 
	3, 0, 0, 1990, 1991, 5, 289, 0, 0, 1991, 1992, 3, 8, 4, 0, 1992, 1993, 
	5, 290, 0, 0, 1993, 303, 1, 0, 0, 0, 1994, 1995, 3, 600, 300, 0, 1995, 
	1996, 5, 3, 0, 0, 1996, 1997, 5, 289, 0, 0, 1997, 1998, 3, 306, 153, 0, 
	1998, 1999, 5, 290, 0, 0, 1999, 305, 1, 0, 0, 0, 2000, 2001, 3, 308, 154, 
	0, 2001, 2002, 3, 310, 155, 0, 2002, 2003, 3, 312, 156, 0, 2003, 307, 1, 
	0, 0, 0, 2004, 2005, 3, 8, 4, 0, 2005, 309, 1, 0, 0, 0, 2006, 2007, 5, 
	45, 0, 0, 2007, 2008, 5, 2, 0, 0, 2008, 311, 1, 0, 0, 0, 2009, 2010, 3, 
	8, 4, 0, 2010, 313, 1, 0, 0, 0, 2011, 2012, 6, 157, -1, 0, 2012, 2015, 
	3, 316, 158, 0, 2013, 2015, 3, 324, 162, 0, 2014, 2011, 1, 0, 0, 0, 2014, 
	2013, 1, 0, 0, 0, 2015, 2021, 1, 0, 0, 0, 2016, 2017, 10, 1, 0, 0, 2017, 
	2018, 5, 58, 0, 0, 2018, 2020, 3, 314, 157, 2, 2019, 2016, 1, 0, 0, 0, 
	2020, 2023, 1, 0, 0, 0, 2021, 2019, 1, 0, 0, 0, 2021, 2022, 1, 0, 0, 0, 
	2022, 315, 1, 0, 0, 0, 2023, 2021, 1, 0, 0, 0, 2024, 2028, 1, 0, 0, 0, 
	2025, 2028, 3, 320, 160, 0, 2026, 2028, 3, 318, 159, 0, 2027, 2024, 1, 
	0, 0, 0, 2027, 2025, 1, 0, 0, 0, 2027, 2026, 1, 0, 0, 0, 2028, 317, 1, 
	0, 0, 0, 2029, 2030, 5, 289, 0, 0, 2030, 2031, 3, 8, 4, 0, 2031, 2032, 
	5, 290, 0, 0, 2032, 319, 1, 0, 0, 0, 2033, 2034, 5, 289, 0, 0, 2034, 2035, 
	3, 322, 161, 0, 2035, 2036, 5, 290, 0, 0, 2036, 321, 1, 0, 0, 0, 2037, 
	2045, 3, 320, 160, 0, 2038, 2045, 3, 326, 163, 0, 2039, 2045, 3, 324, 162, 
	0, 2040, 2041, 3, 314, 157, 0, 2041, 2042, 5, 58, 0, 0, 2042, 2043, 3, 
	314, 157, 0, 2043, 2045, 1, 0, 0, 0, 2044, 2037, 1, 0, 0, 0, 2044, 2038, 
	1, 0, 0, 0, 2044, 2039, 1, 0, 0, 0, 2044, 2040, 1, 0, 0, 0, 2045, 323, 
	1, 0, 0, 0, 2046, 2047, 3, 316, 158, 0, 2047, 2048, 5, 57, 0, 0, 2048, 
	2053, 3, 316, 158, 0, 2049, 2050, 5, 57, 0, 0, 2050, 2052, 3, 316, 158, 
	0, 2051, 2049, 1, 0, 0, 0, 2052, 2055, 1, 0, 0, 0, 2053, 2051, 1, 0, 0, 
	0, 2053, 2054, 1, 0, 0, 0, 2054, 325, 1, 0, 0, 0, 2055, 2053, 1, 0, 0, 
	0, 2056, 2122, 3, 584, 292, 0, 2057, 2122, 3, 586, 293, 0, 2058, 2122, 
	3, 588, 294, 0, 2059, 2122, 3, 582, 291, 0, 2060, 2122, 3, 580, 290, 0, 
	2061, 2122, 3, 576, 288, 0, 2062, 2122, 3, 572, 286, 0, 2063, 2122, 3, 
	570, 285, 0, 2064, 2122, 3, 568, 284, 0, 2065, 2122, 3, 564, 282, 0, 2066, 
	2122, 3, 514, 257, 0, 2067, 2122, 3, 526, 263, 0, 2068, 2122, 3, 524, 262, 
	0, 2069, 2122, 3, 508, 254, 0, 2070, 2122, 3, 500, 250, 0, 2071, 2122, 
	3, 486, 243, 0, 2072, 2122, 3, 484, 242, 0, 2073, 2122, 3, 482, 241, 0, 
	2074, 2122, 3, 474, 237, 0, 2075, 2122, 3, 472, 236, 0, 2076, 2122, 3, 
	464, 232, 0, 2077, 2122, 3, 458, 229, 0, 2078, 2122, 3, 448, 224, 0, 2079, 
	2122, 3, 350, 175, 0, 2080, 2122, 3, 348, 174, 0, 2081, 2122, 3, 548, 274, 
	0, 2082, 2122, 3, 338, 169, 0, 2083, 2122, 3, 336, 168, 0, 2084, 2085, 
	3, 316, 158, 0, 2085, 2086, 5, 291, 0, 0, 2086, 2087, 3, 314, 157, 0, 2087, 
	2088, 5, 292, 0, 0, 2088, 2122, 1, 0, 0, 0, 2089, 2090, 3, 316, 158, 0, 
	2090, 2091, 5, 283, 0, 0, 2091, 2092, 5, 289, 0, 0, 2092, 2093, 3, 546, 
	273, 0, 2093, 2094, 5, 290, 0, 0, 2094, 2122, 1, 0, 0, 0, 2095, 2096, 3, 
	316, 158, 0, 2096, 2097, 5, 283, 0, 0, 2097, 2098, 3, 548, 274, 0, 2098, 
	2122, 1, 0, 0, 0, 2099, 2100, 5, 56, 0, 0, 2100, 2122, 3, 316, 158, 0, 
	2101, 2102, 3, 316, 158, 0, 2102, 2103, 3, 334, 167, 0, 2103, 2105, 3, 
	332, 166, 0, 2104, 2106, 3, 412, 206, 0, 2105, 2104, 1, 0, 0, 0, 2105, 
	2106, 1, 0, 0, 0, 2106, 2107, 1, 0, 0, 0, 2107, 2108, 3, 174, 87, 0, 2108, 
	2122, 1, 0, 0, 0, 2109, 2110, 3, 316, 158, 0, 2110, 2111, 3, 334, 167, 
	0, 2111, 2113, 3, 332, 166, 0, 2112, 2114, 3, 412, 206, 0, 2113, 2112, 
	1, 0, 0, 0, 2113, 2114, 1, 0, 0, 0, 2114, 2115, 1, 0, 0, 0, 2115, 2116, 
	3, 328, 164, 0, 2116, 2122, 1, 0, 0, 0, 2117, 2118, 3, 316, 158, 0, 2118, 
	2119, 3, 334, 167, 0, 2119, 2120, 3, 316, 158, 0, 2120, 2122, 1, 0, 0, 
	0, 2121, 2056, 1, 0, 0, 0, 2121, 2057, 1, 0, 0, 0, 2121, 2058, 1, 0, 0, 
	0, 2121, 2059, 1, 0, 0, 0, 2121, 2060, 1, 0, 0, 0, 2121, 2061, 1, 0, 0, 
	0, 2121, 2062, 1, 0, 0, 0, 2121, 2063, 1, 0, 0, 0, 2121, 2064, 1, 0, 0, 
	0, 2121, 2065, 1, 0, 0, 0, 2121, 2066, 1, 0, 0, 0, 2121, 2067, 1, 0, 0, 
	0, 2121, 2068, 1, 0, 0, 0, 2121, 2069, 1, 0, 0, 0, 2121, 2070, 1, 0, 0, 
	0, 2121, 2071, 1, 0, 0, 0, 2121, 2072, 1, 0, 0, 0, 2121, 2073, 1, 0, 0, 
	0, 2121, 2074, 1, 0, 0, 0, 2121, 2075, 1, 0, 0, 0, 2121, 2076, 1, 0, 0, 
	0, 2121, 2077, 1, 0, 0, 0, 2121, 2078, 1, 0, 0, 0, 2121, 2079, 1, 0, 0, 
	0, 2121, 2080, 1, 0, 0, 0, 2121, 2081, 1, 0, 0, 0, 2121, 2082, 1, 0, 0, 
	0, 2121, 2083, 1, 0, 0, 0, 2121, 2084, 1, 0, 0, 0, 2121, 2089, 1, 0, 0, 
	0, 2121, 2095, 1, 0, 0, 0, 2121, 2099, 1, 0, 0, 0, 2121, 2101, 1, 0, 0, 
	0, 2121, 2109, 1, 0, 0, 0, 2121, 2117, 1, 0, 0, 0, 2122, 327, 1, 0, 0, 
	0, 2123, 2132, 3, 318, 159, 0, 2124, 2125, 5, 289, 0, 0, 2125, 2126, 3, 
	322, 161, 0, 2126, 2127, 5, 290, 0, 0, 2127, 2132, 1, 0, 0, 0, 2128, 2129, 
	3, 330, 165, 0, 2129, 2130, 5, 290, 0, 0, 2130, 2132, 1, 0, 0, 0, 2131, 
	2123, 1, 0, 0, 0, 2131, 2124, 1, 0, 0, 0, 2131, 2128, 1, 0, 0, 0, 2132, 
	329, 1, 0, 0, 0, 2133, 2134, 5, 289, 0, 0, 2134, 2135, 3, 314, 157, 0, 
	2135, 2136, 5, 282, 0, 0, 2136, 2141, 3, 314, 157, 0, 2137, 2138, 5, 282, 
	0, 0, 2138, 2140, 3, 314, 157, 0, 2139, 2137, 1, 0, 0, 0, 2140, 2143, 1, 
	0, 0, 0, 2141, 2139, 1, 0, 0, 0, 2141, 2142, 1, 0, 0, 0, 2142, 331, 1, 
	0, 0, 0, 2143, 2141, 1, 0, 0, 0, 2144, 2145, 7, 8, 0, 0, 2145, 333, 1, 
	0, 0, 0, 2146, 2150, 5, 280, 0, 0, 2147, 2148, 5, 277, 0, 0, 2148, 2150, 
	5, 280, 0, 0, 2149, 2146, 1, 0, 0, 0, 2149, 2147, 1, 0, 0, 0, 2150, 335, 
	1, 0, 0, 0, 2151, 2152, 5, 1, 0, 0, 2152, 2159, 3, 318, 159, 0, 2153, 2155, 
	5, 276, 0, 0, 2154, 2156, 3, 412, 206, 0, 2155, 2154, 1, 0, 0, 0, 2155, 
	2156, 1, 0, 0, 0, 2156, 2157, 1, 0, 0, 0, 2157, 2159, 3, 318, 159, 0, 2158, 
	2151, 1, 0, 0, 0, 2158, 2153, 1, 0, 0, 0, 2159, 337, 1, 0, 0, 0, 2160, 
	2161, 3, 340, 170, 0, 2161, 2162, 5, 290, 0, 0, 2162, 2170, 1, 0, 0, 0, 
	2163, 2164, 3, 346, 173, 0, 2164, 2165, 5, 290, 0, 0, 2165, 2170, 1, 0, 
	0, 0, 2166, 2167, 3, 344, 172, 0, 2167, 2168, 5, 290, 0, 0, 2168, 2170, 
	1, 0, 0, 0, 2169, 2160, 1, 0, 0, 0, 2169, 2163, 1, 0, 0, 0, 2169, 2166, 
	1, 0, 0, 0, 2170, 339, 1, 0, 0, 0, 2171, 2172, 3, 346, 173, 0, 2172, 2177, 
	3, 342, 171, 0, 2173, 2174, 5, 282, 0, 0, 2174, 2176, 3, 342, 171, 0, 2175, 
	2173, 1, 0, 0, 0, 2176, 2179, 1, 0, 0, 0, 2177, 2175, 1, 0, 0, 0, 2177, 
	2178, 1, 0, 0, 0, 2178, 341, 1, 0, 0, 0, 2179, 2177, 1, 0, 0, 0, 2180, 
	2182, 3, 314, 157, 0, 2181, 2183, 3, 434, 217, 0, 2182, 2181, 1, 0, 0, 
	0, 2182, 2183, 1, 0, 0, 0, 2183, 343, 1, 0, 0, 0, 2184, 2185, 5, 289, 0, 
	0, 2185, 2186, 3, 314, 157, 0, 2186, 2187, 5, 282, 0, 0, 2187, 2192, 3, 
	314, 157, 0, 2188, 2189, 5, 282, 0, 0, 2189, 2191, 3, 314, 157, 0, 2190, 
	2188, 1, 0, 0, 0, 2191, 2194, 1, 0, 0, 0, 2192, 2190, 1, 0, 0, 0, 2192, 
	2193, 1, 0, 0, 0, 2193, 345, 1, 0, 0, 0, 2194, 2192, 1, 0, 0, 0, 2195, 
	2196, 3, 556, 278, 0, 2196, 2197, 5, 289, 0, 0, 2197, 2201, 1, 0, 0, 0, 
	2198, 2199, 5, 41, 0, 0, 2199, 2201, 5, 289, 0, 0, 2200, 2195, 1, 0, 0, 
	0, 2200, 2198, 1, 0, 0, 0, 2201, 347, 1, 0, 0, 0, 2202, 2203, 5, 65, 0, 
	0, 2203, 2204, 3, 314, 157, 0, 2204, 2207, 3, 548, 274, 0, 2205, 2206, 
	5, 275, 0, 0, 2206, 2208, 3, 548, 274, 0, 2207, 2205, 1, 0, 0, 0, 2207, 
	2208, 1, 0, 0, 0, 2208, 349, 1, 0, 0, 0, 2209, 2211, 3, 352, 176, 0, 2210, 
	2212, 3, 412, 206, 0, 2211, 2210, 1, 0, 0, 0, 2211, 2212, 1, 0, 0, 0, 2212, 
	2214, 1, 0, 0, 0, 2213, 2215, 3, 370, 185, 0, 2214, 2213, 1, 0, 0, 0, 2214, 
	2215, 1, 0, 0, 0, 2215, 2217, 1, 0, 0, 0, 2216, 2218, 3, 354, 177, 0, 2217, 
	2216, 1, 0, 0, 0, 2217, 2218, 1, 0, 0, 0, 2218, 351, 1, 0, 0, 0, 2219, 
	2221, 3, 444, 222, 0, 2220, 2222, 3, 404, 202, 0, 2221, 2220, 1, 0, 0, 
	0, 2221, 2222, 1, 0, 0, 0, 2222, 2224, 1, 0, 0, 0, 2223, 2225, 3, 56, 28, 
	0, 2224, 2223, 1, 0, 0, 0, 2224, 2225, 1, 0, 0, 0, 2225, 2227, 1, 0, 0, 
	0, 2226, 2228, 3, 402, 201, 0, 2227, 2226, 1, 0, 0, 0, 2227, 2228, 1, 0, 
	0, 0, 2228, 2229, 1, 0, 0, 0, 2229, 2230, 5, 290, 0, 0, 2230, 2253, 1, 
	0, 0, 0, 2231, 2233, 3, 390, 195, 0, 2232, 2234, 3, 388, 194, 0, 2233, 
	2232, 1, 0, 0, 0, 2233, 2234, 1, 0, 0, 0, 2234, 2236, 1, 0, 0, 0, 2235, 
	2237, 3, 404, 202, 0, 2236, 2235, 1, 0, 0, 0, 2236, 2237, 1, 0, 0, 0, 2237, 
	2239, 1, 0, 0, 0, 2238, 2240, 3, 374, 187, 0, 2239, 2238, 1, 0, 0, 0, 2239, 
	2240, 1, 0, 0, 0, 2240, 2242, 1, 0, 0, 0, 2241, 2243, 3, 372, 186, 0, 2242, 
	2241, 1, 0, 0, 0, 2242, 2243, 1, 0, 0, 0, 2243, 2245, 1, 0, 0, 0, 2244, 
	2246, 3, 56, 28, 0, 2245, 2244, 1, 0, 0, 0, 2245, 2246, 1, 0, 0, 0, 2246, 
	2248, 1, 0, 0, 0, 2247, 2249, 3, 402, 201, 0, 2248, 2247, 1, 0, 0, 0, 2248, 
	2249, 1, 0, 0, 0, 2249, 2250, 1, 0, 0, 0, 2250, 2251, 5, 290, 0, 0, 2251, 
	2253, 1, 0, 0, 0, 2252, 2219, 1, 0, 0, 0, 2252, 2231, 1, 0, 0, 0, 2253, 
	353, 1, 0, 0, 0, 2254, 2255, 5, 260, 0, 0, 2255, 2256, 3, 356, 178, 0, 
	2256, 355, 1, 0, 0, 0, 2257, 2273, 3, 548, 274, 0, 2258, 2260, 5, 289, 
	0, 0, 2259, 2261, 3, 548, 274, 0, 2260, 2259, 1, 0, 0, 0, 2260, 2261, 1, 
	0, 0, 0, 2261, 2263, 1, 0, 0, 0, 2262, 2264, 3, 366, 183, 0, 2263, 2262, 
	1, 0, 0, 0, 2263, 2264, 1, 0, 0, 0, 2264, 2266, 1, 0, 0, 0, 2265, 2267, 
	3, 56, 28, 0, 2266, 2265, 1, 0, 0, 0, 2266, 2267, 1, 0, 0, 0, 2267, 2269, 
	1, 0, 0, 0, 2268, 2270, 3, 358, 179, 0, 2269, 2268, 1, 0, 0, 0, 2269, 2270, 
	1, 0, 0, 0, 2270, 2271, 1, 0, 0, 0, 2271, 2273, 5, 290, 0, 0, 2272, 2257, 
	1, 0, 0, 0, 2272, 2258, 1, 0, 0, 0, 2273, 357, 1, 0, 0, 0, 2274, 2275, 
	3, 364, 182, 0, 2275, 2276, 5, 261, 0, 0, 2276, 2277, 3, 360, 180, 0, 2277, 
	2278, 5, 57, 0, 0, 2278, 2279, 3, 360, 180, 0, 2279, 2284, 1, 0, 0, 0, 
	2280, 2281, 3, 364, 182, 0, 2281, 2282, 3, 360, 180, 0, 2282, 2284, 1, 
	0, 0, 0, 2283, 2274, 1, 0, 0, 0, 2283, 2280, 1, 0, 0, 0, 2284, 359, 1, 
	0, 0, 0, 2285, 2286, 5, 262, 0, 0, 2286, 2293, 3, 362, 181, 0, 2287, 2288, 
	5, 263, 0, 0, 2288, 2293, 5, 194, 0, 0, 2289, 2290, 3, 314, 157, 0, 2290, 
	2291, 3, 362, 181, 0, 2291, 2293, 1, 0, 0, 0, 2292, 2285, 1, 0, 0, 0, 2292, 
	2287, 1, 0, 0, 0, 2292, 2289, 1, 0, 0, 0, 2293, 361, 1, 0, 0, 0, 2294, 
	2295, 7, 9, 0, 0, 2295, 363, 1, 0, 0, 0, 2296, 2297, 7, 10, 0, 0, 2297, 
	365, 1, 0, 0, 0, 2298, 2299, 3, 368, 184, 0, 2299, 367, 1, 0, 0, 0, 2300, 
	2302, 5, 256, 0, 0, 2301, 2303, 3, 412, 206, 0, 2302, 2301, 1, 0, 0, 0, 
	2302, 2303, 1, 0, 0, 0, 2303, 2304, 1, 0, 0, 0, 2304, 2305, 5, 5, 0, 0, 
	2305, 2310, 3, 314, 157, 0, 2306, 2307, 5, 282, 0, 0, 2307, 2309, 3, 314, 
	157, 0, 2308, 2306, 1, 0, 0, 0, 2309, 2312, 1, 0, 0, 0, 2310, 2308, 1, 
	0, 0, 0, 2310, 2311, 1, 0, 0, 0, 2311, 369, 1, 0, 0, 0, 2312, 2310, 1, 
	0, 0, 0, 2313, 2314, 5, 49, 0, 0, 2314, 2315, 5, 251, 0, 0, 2315, 2316, 
	5, 259, 0, 0, 2316, 371, 1, 0, 0, 0, 2317, 2318, 5, 49, 0, 0, 2318, 2319, 
	5, 187, 0, 0, 2319, 2320, 3, 376, 188, 0, 2320, 373, 1, 0, 0, 0, 2321, 
	2322, 5, 84, 0, 0, 2322, 2323, 3, 316, 158, 0, 2323, 2324, 5, 57, 0, 0, 
	2324, 2325, 3, 314, 157, 0, 2325, 375, 1, 0, 0, 0, 2326, 2327, 3, 378, 
	189, 0, 2327, 377, 1, 0, 0, 0, 2328, 2329, 3, 380, 190, 0, 2329, 2330, 
	5, 290, 0, 0, 2330, 2334, 1, 0, 0, 0, 2331, 2332, 5, 289, 0, 0, 2332, 2334, 
	5, 290, 0, 0, 2333, 2328, 1, 0, 0, 0, 2333, 2331, 1, 0, 0, 0, 2334, 379, 
	1, 0, 0, 0, 2335, 2336, 5, 289, 0, 0, 2336, 2341, 3, 382, 191, 0, 2337, 
	2338, 5, 282, 0, 0, 2338, 2340, 3, 382, 191, 0, 2339, 2337, 1, 0, 0, 0, 
	2340, 2343, 1, 0, 0, 0, 2341, 2339, 1, 0, 0, 0, 2341, 2342, 1, 0, 0, 0, 
	2342, 381, 1, 0, 0, 0, 2343, 2341, 1, 0, 0, 0, 2344, 2345, 3, 420, 210, 
	0, 2345, 2346, 3, 386, 193, 0, 2346, 2347, 3, 384, 192, 0, 2347, 383, 1, 
	0, 0, 0, 2348, 2351, 5, 255, 0, 0, 2349, 2351, 3, 314, 157, 0, 2350, 2348, 
	1, 0, 0, 0, 2350, 2349, 1, 0, 0, 0, 2351, 385, 1, 0, 0, 0, 2352, 2353, 
	7, 11, 0, 0, 2353, 387, 1, 0, 0, 0, 2354, 2355, 5, 257, 0, 0, 2355, 2359, 
	5, 26, 0, 0, 2356, 2357, 5, 258, 0, 0, 2357, 2359, 5, 26, 0, 0, 2358, 2354, 
	1, 0, 0, 0, 2358, 2356, 1, 0, 0, 0, 2359, 389, 1, 0, 0, 0, 2360, 2361, 
	5, 282, 0, 0, 2361, 2362, 3, 392, 196, 0, 2362, 391, 1, 0, 0, 0, 2363, 
	2365, 3, 314, 157, 0, 2364, 2366, 3, 434, 217, 0, 2365, 2364, 1, 0, 0, 
	0, 2365, 2366, 1, 0, 0, 0, 2366, 2367, 1, 0, 0, 0, 2367, 2368, 3, 396, 
	198, 0, 2368, 2374, 1, 0, 0, 0, 2369, 2374, 3, 398, 199, 0, 2370, 2374, 
	3, 394, 197, 0, 2371, 2372, 5, 40, 0, 0, 2372, 2374, 6, 196, -1, 0, 2373, 
	2363, 1, 0, 0, 0, 2373, 2369, 1, 0, 0, 0, 2373, 2370, 1, 0, 0, 0, 2373, 
	2371, 1, 0, 0, 0, 2374, 393, 1, 0, 0, 0, 2375, 2376, 5, 200, 0, 0, 2376, 
	2377, 3, 546, 273, 0, 2377, 395, 1, 0, 0, 0, 2378, 2379, 3, 548, 274, 0, 
	2379, 2380, 5, 305, 0, 0, 2380, 2381, 3, 314, 157, 0, 2381, 2387, 1, 0, 
	0, 0, 2382, 2383, 3, 548, 274, 0, 2383, 2384, 5, 305, 0, 0, 2384, 2385, 
	3, 398, 199, 0, 2385, 2387, 1, 0, 0, 0, 2386, 2378, 1, 0, 0, 0, 2386, 2382, 
	1, 0, 0, 0, 2387, 397, 1, 0, 0, 0, 2388, 2389, 3, 400, 200, 0, 2389, 2390, 
	5, 306, 0, 0, 2390, 2391, 3, 314, 157, 0, 2391, 399, 1, 0, 0, 0, 2392, 
	2396, 3, 314, 157, 0, 2393, 2394, 5, 289, 0, 0, 2394, 2396, 5, 290, 0, 
	0, 2395, 2392, 1, 0, 0, 0, 2395, 2393, 1, 0, 0, 0, 2396, 401, 1, 0, 0, 
	0, 2397, 2398, 5, 23, 0, 0, 2398, 2399, 3, 314, 157, 0, 2399, 2400, 5, 
	28, 0, 0, 2400, 2401, 3, 314, 157, 0, 2401, 2405, 1, 0, 0, 0, 2402, 2403, 
	5, 23, 0, 0, 2403, 2405, 3, 314, 157, 0, 2404, 2397, 1, 0, 0, 0, 2404, 
	2402, 1, 0, 0, 0, 2405, 403, 1, 0, 0, 0, 2406, 2407, 5, 250, 0, 0, 2407, 
	2408, 5, 153, 0, 0, 2408, 2415, 3, 314, 157, 0, 2409, 2410, 5, 250, 0, 
	0, 2410, 2411, 5, 158, 0, 0, 2411, 2412, 3, 314, 157, 0, 2412, 2413, 3, 
	406, 203, 0, 2413, 2415, 1, 0, 0, 0, 2414, 2406, 1, 0, 0, 0, 2414, 2409, 
	1, 0, 0, 0, 2415, 405, 1, 0, 0, 0, 2416, 2417, 3, 408, 204, 0, 2417, 2422, 
	3, 424, 212, 0, 2418, 2419, 5, 282, 0, 0, 2419, 2421, 3, 424, 212, 0, 2420, 
	2418, 1, 0, 0, 0, 2421, 2424, 1, 0, 0, 0, 2422, 2420, 1, 0, 0, 0, 2422, 
	2423, 1, 0, 0, 0, 2423, 407, 1, 0, 0, 0, 2424, 2422, 1, 0, 0, 0, 2425, 
	2427, 5, 251, 0, 0, 2426, 2428, 3, 412, 206, 0, 2427, 2426, 1, 0, 0, 0, 
	2427, 2428, 1, 0, 0, 0, 2428, 2430, 1, 0, 0, 0, 2429, 2431, 3, 410, 205, 
	0, 2430, 2429, 1, 0, 0, 0, 2430, 2431, 1, 0, 0, 0, 2431, 2432, 1, 0, 0, 
	0, 2432, 2433, 5, 5, 0, 0, 2433, 409, 1, 0, 0, 0, 2434, 2435, 5, 57, 0, 
	0, 2435, 2436, 5, 31, 0, 0, 2436, 411, 1, 0, 0, 0, 2437, 2438, 5, 303, 
	0, 0, 2438, 2441, 3, 580, 290, 0, 2439, 2441, 3, 414, 207, 0, 2440, 2437, 
	1, 0, 0, 0, 2440, 2439, 1, 0, 0, 0, 2441, 413, 1, 0, 0, 0, 2442, 2443, 
	3, 416, 208, 0, 2443, 2444, 5, 286, 0, 0, 2444, 415, 1, 0, 0, 0, 2445, 
	2449, 5, 303, 0, 0, 2446, 2447, 3, 580, 290, 0, 2447, 2448, 5, 303, 0, 
	0, 2448, 2450, 1, 0, 0, 0, 2449, 2446, 1, 0, 0, 0, 2449, 2450, 1, 0, 0, 
	0, 2450, 2451, 1, 0, 0, 0, 2451, 2452, 5, 285, 0, 0, 2452, 2457, 3, 418, 
	209, 0, 2453, 2454, 5, 282, 0, 0, 2454, 2456, 3, 418, 209, 0, 2455, 2453, 
	1, 0, 0, 0, 2456, 2459, 1, 0, 0, 0, 2457, 2455, 1, 0, 0, 0, 2457, 2458, 
	1, 0, 0, 0, 2458, 417, 1, 0, 0, 0, 2459, 2457, 1, 0, 0, 0, 2460, 2461, 
	3, 420, 210, 0, 2461, 2462, 5, 284, 0, 0, 2462, 2463, 3, 314, 157, 0, 2463, 
	2471, 1, 0, 0, 0, 2464, 2465, 3, 420, 210, 0, 2465, 2466, 5, 283, 0, 0, 
	2466, 2467, 3, 420, 210, 0, 2467, 2468, 5, 284, 0, 0, 2468, 2469, 3, 314, 
	157, 0, 2469, 2471, 1, 0, 0, 0, 2470, 2460, 1, 0, 0, 0, 2470, 2464, 1, 
	0, 0, 0, 2471, 419, 1, 0, 0, 0, 2472, 2475, 3, 548, 274, 0, 2473, 2475, 
	3, 422, 211, 0, 2474, 2472, 1, 0, 0, 0, 2474, 2473, 1, 0, 0, 0, 2475, 421, 
	1, 0, 0, 0, 2476, 2477, 7, 12, 0, 0, 2477, 423, 1, 0, 0, 0, 2478, 2479, 
	5, 289, 0, 0, 2479, 2497, 5, 290, 0, 0, 2480, 2482, 3, 314, 157, 0, 2481, 
	2483, 3, 434, 217, 0, 2482, 2481, 1, 0, 0, 0, 2482, 2483, 1, 0, 0, 0, 2483, 
	2485, 1, 0, 0, 0, 2484, 2486, 3, 436, 218, 0, 2485, 2484, 1, 0, 0, 0, 2485, 
	2486, 1, 0, 0, 0, 2486, 2497, 1, 0, 0, 0, 2487, 2488, 3, 432, 216, 0, 2488, 
	2489, 5, 290, 0, 0, 2489, 2497, 1, 0, 0, 0, 2490, 2491, 3, 430, 215, 0, 
	2491, 2492, 5, 290, 0, 0, 2492, 2497, 1, 0, 0, 0, 2493, 2494, 3, 426, 213, 
	0, 2494, 2495, 5, 290, 0, 0, 2495, 2497, 1, 0, 0, 0, 2496, 2478, 1, 0, 
	0, 0, 2496, 2480, 1, 0, 0, 0, 2496, 2487, 1, 0, 0, 0, 2496, 2490, 1, 0, 
	0, 0, 2496, 2493, 1, 0, 0, 0, 2497, 425, 1, 0, 0, 0, 2498, 2499, 5, 249, 
	0, 0, 2499, 2500, 5, 201, 0, 0, 2500, 2501, 5, 289, 0, 0, 2501, 2506, 3, 
	428, 214, 0, 2502, 2503, 5, 282, 0, 0, 2503, 2505, 3, 428, 214, 0, 2504, 
	2502, 1, 0, 0, 0, 2505, 2508, 1, 0, 0, 0, 2506, 2504, 1, 0, 0, 0, 2506, 
	2507, 1, 0, 0, 0, 2507, 427, 1, 0, 0, 0, 2508, 2506, 1, 0, 0, 0, 2509, 
	2510, 5, 289, 0, 0, 2510, 2519, 5, 290, 0, 0, 2511, 2519, 3, 314, 157, 
	0, 2512, 2513, 3, 432, 216, 0, 2513, 2514, 5, 290, 0, 0, 2514, 2519, 1, 
	0, 0, 0, 2515, 2516, 3, 430, 215, 0, 2516, 2517, 5, 290, 0, 0, 2517, 2519, 
	1, 0, 0, 0, 2518, 2509, 1, 0, 0, 0, 2518, 2511, 1, 0, 0, 0, 2518, 2512, 
	1, 0, 0, 0, 2518, 2515, 1, 0, 0, 0, 2519, 429, 1, 0, 0, 0, 2520, 2521, 
	5, 253, 0, 0, 2521, 2526, 5, 289, 0, 0, 2522, 2523, 5, 282, 0, 0, 2523, 
	2525, 3, 314, 157, 0, 2524, 2522, 1, 0, 0, 0, 2525, 2528, 1, 0, 0, 0, 2526, 
	2524, 1, 0, 0, 0, 2526, 2527, 1, 0, 0, 0, 2527, 431, 1, 0, 0, 0, 2528, 
	2526, 1, 0, 0, 0, 2529, 2530, 5, 252, 0, 0, 2530, 2531, 5, 289, 0, 0, 2531, 
	2536, 3, 314, 157, 0, 2532, 2533, 5, 282, 0, 0, 2533, 2535, 3, 314, 157, 
	0, 2534, 2532, 1, 0, 0, 0, 2535, 2538, 1, 0, 0, 0, 2536, 2534, 1, 0, 0, 
	0, 2536, 2537, 1, 0, 0, 0, 2537, 433, 1, 0, 0, 0, 2538, 2536, 1, 0, 0, 
	0, 2539, 2540, 5, 3, 0, 0, 2540, 2541, 3, 548, 274, 0, 2541, 435, 1, 0, 
	0, 0, 2542, 2545, 3, 438, 219, 0, 2543, 2545, 3, 442, 221, 0, 2544, 2542, 
	1, 0, 0, 0, 2544, 2543, 1, 0, 0, 0, 2545, 437, 1, 0, 0, 0, 2546, 2548, 
	3, 440, 220, 0, 2547, 2549, 3, 442, 221, 0, 2548, 2547, 1, 0, 0, 0, 2548, 
	2549, 1, 0, 0, 0, 2549, 439, 1, 0, 0, 0, 2550, 2551, 7, 5, 0, 0, 2551, 
	441, 1, 0, 0, 0, 2552, 2553, 5, 26, 0, 0, 2553, 2557, 5, 120, 0, 0, 2554, 
	2555, 5, 26, 0, 0, 2555, 2557, 5, 142, 0, 0, 2556, 2552, 1, 0, 0, 0, 2556, 
	2554, 1, 0, 0, 0, 2557, 443, 1, 0, 0, 0, 2558, 2559, 3, 316, 158, 0, 2559, 
	2560, 5, 289, 0, 0, 2560, 2561, 5, 11, 0, 0, 2561, 2569, 1, 0, 0, 0, 2562, 
	2563, 3, 316, 158, 0, 2563, 2564, 5, 289, 0, 0, 2564, 2569, 1, 0, 0, 0, 
	2565, 2566, 3, 446, 223, 0, 2566, 2567, 5, 289, 0, 0, 2567, 2569, 1, 0, 
	0, 0, 2568, 2558, 1, 0, 0, 0, 2568, 2562, 1, 0, 0, 0, 2568, 2565, 1, 0, 
	0, 0, 2569, 445, 1, 0, 0, 0, 2570, 2571, 7, 13, 0, 0, 2571, 447, 1, 0, 
	0, 0, 2572, 2573, 3, 450, 225, 0, 2573, 2574, 5, 290, 0, 0, 2574, 449, 
	1, 0, 0, 0, 2575, 2576, 5, 185, 0, 0, 2576, 2577, 5, 289, 0, 0, 2577, 2578, 
	3, 314, 157, 0, 2578, 2579, 5, 282, 0, 0, 2579, 2584, 3, 452, 226, 0, 2580, 
	2581, 5, 282, 0, 0, 2581, 2583, 3, 452, 226, 0, 2582, 2580, 1, 0, 0, 0, 
	2583, 2586, 1, 0, 0, 0, 2584, 2582, 1, 0, 0, 0, 2584, 2585, 1, 0, 0, 0, 
	2585, 451, 1, 0, 0, 0, 2586, 2584, 1, 0, 0, 0, 2587, 2588, 3, 314, 157, 
	0, 2588, 2589, 5, 3, 0, 0, 2589, 2590, 3, 454, 227, 0, 2590, 2596, 1, 0, 
	0, 0, 2591, 2592, 3, 314, 157, 0, 2592, 2593, 5, 3, 0, 0, 2593, 2594, 3, 
	456, 228, 0, 2594, 2596, 1, 0, 0, 0, 2595, 2587, 1, 0, 0, 0, 2595, 2591, 
	1, 0, 0, 0, 2596, 453, 1, 0, 0, 0, 2597, 2598, 6, 227, -1, 0, 2598, 2599, 
	3, 548, 274, 0, 2599, 2613, 1, 0, 0, 0, 2600, 2601, 10, 3, 0, 0, 2601, 
	2602, 5, 283, 0, 0, 2602, 2612, 3, 456, 228, 0, 2603, 2604, 10, 2, 0, 0, 
	2604, 2605, 5, 283, 0, 0, 2605, 2612, 3, 548, 274, 0, 2606, 2607, 10, 1, 
	0, 0, 2607, 2608, 5, 291, 0, 0, 2608, 2609, 3, 314, 157, 0, 2609, 2610, 
	5, 292, 0, 0, 2610, 2612, 1, 0, 0, 0, 2611, 2600, 1, 0, 0, 0, 2611, 2603, 
	1, 0, 0, 0, 2611, 2606, 1, 0, 0, 0, 2612, 2615, 1, 0, 0, 0, 2613, 2611, 
	1, 0, 0, 0, 2613, 2614, 1, 0, 0, 0, 2614, 455, 1, 0, 0, 0, 2615, 2613, 
	1, 0, 0, 0, 2616, 2631, 3, 548, 274, 0, 2617, 2618, 3, 454, 227, 0, 2618, 
	2619, 5, 283, 0, 0, 2619, 2620, 3, 456, 228, 0, 2620, 2631, 1, 0, 0, 0, 
	2621, 2622, 3, 454, 227, 0, 2622, 2623, 5, 283, 0, 0, 2623, 2624, 3, 548, 
	274, 0, 2624, 2631, 1, 0, 0, 0, 2625, 2626, 3, 454, 227, 0, 2626, 2627, 
	5, 291, 0, 0, 2627, 2628, 3, 314, 157, 0, 2628, 2629, 5, 292, 0, 0, 2629, 
	2631, 1, 0, 0, 0, 2630, 2616, 1, 0, 0, 0, 2630, 2617, 1, 0, 0, 0, 2630, 
	2621, 1, 0, 0, 0, 2630, 2625, 1, 0, 0, 0, 2631, 457, 1, 0, 0, 0, 2632, 
	2633, 5, 49, 0, 0, 2633, 2634, 5, 289, 0, 0, 2634, 2635, 3, 460, 230, 0, 
	2635, 2636, 5, 282, 0, 0, 2636, 2637, 3, 314, 157, 0, 2637, 2638, 5, 290, 
	0, 0, 2638, 459, 1, 0, 0, 0, 2639, 2644, 3, 462, 231, 0, 2640, 2641, 5, 
	282, 0, 0, 2641, 2643, 3, 462, 231, 0, 2642, 2640, 1, 0, 0, 0, 2643, 2646, 
	1, 0, 0, 0, 2644, 2642, 1, 0, 0, 0, 2644, 2645, 1, 0, 0, 0, 2645, 461, 
	1, 0, 0, 0, 2646, 2644, 1, 0, 0, 0, 2647, 2648, 3, 548, 274, 0, 2648, 2649, 
	5, 3, 0, 0, 2649, 2650, 3, 314, 157, 0, 2650, 463, 1, 0, 0, 0, 2651, 2652, 
	3, 466, 233, 0, 2652, 2653, 5, 290, 0, 0, 2653, 2662, 1, 0, 0, 0, 2654, 
	2655, 3, 466, 233, 0, 2655, 2656, 5, 303, 0, 0, 2656, 2657, 5, 61, 0, 0, 
	2657, 2658, 5, 234, 0, 0, 2658, 2659, 3, 314, 157, 0, 2659, 2660, 5, 290, 
	0, 0, 2660, 2662, 1, 0, 0, 0, 2661, 2651, 1, 0, 0, 0, 2661, 2654, 1, 0, 
	0, 0, 2662, 465, 1, 0, 0, 0, 2663, 2664, 5, 246, 0, 0, 2664, 2665, 5, 289, 
	0, 0, 2665, 2666, 3, 314, 157, 0, 2666, 2667, 5, 16, 0, 0, 2667, 2668, 
	3, 314, 157, 0, 2668, 467, 1, 0, 0, 0, 2669, 2670, 5, 122, 0, 0, 2670, 
	2672, 3, 314, 157, 0, 2671, 2673, 3, 470, 235, 0, 2672, 2671, 1, 0, 0, 
	0, 2672, 2673, 1, 0, 0, 0, 2673, 469, 1, 0, 0, 0, 2674, 2675, 5, 303, 0, 
	0, 2675, 2676, 5, 61, 0, 0, 2676, 2677, 5, 234, 0, 0, 2677, 2678, 3, 314, 
	157, 0, 2678, 471, 1, 0, 0, 0, 2679, 2680, 5, 245, 0, 0, 2680, 2681, 5, 
	289, 0, 0, 2681, 2682, 5, 3, 0, 0, 2682, 2684, 3, 518, 259, 0, 2683, 2685, 
	3, 468, 234, 0, 2684, 2683, 1, 0, 0, 0, 2684, 2685, 1, 0, 0, 0, 2685, 2686, 
	1, 0, 0, 0, 2686, 2687, 5, 290, 0, 0, 2687, 2706, 1, 0, 0, 0, 2688, 2689, 
	5, 245, 0, 0, 2689, 2690, 5, 289, 0, 0, 2690, 2691, 5, 245, 0, 0, 2691, 
	2706, 6, 236, -1, 0, 2692, 2693, 5, 196, 0, 0, 2693, 2694, 5, 289, 0, 0, 
	2694, 2695, 5, 3, 0, 0, 2695, 2697, 3, 518, 259, 0, 2696, 2698, 3, 468, 
	234, 0, 2697, 2696, 1, 0, 0, 0, 2697, 2698, 1, 0, 0, 0, 2698, 2699, 1, 
	0, 0, 0, 2699, 2700, 5, 290, 0, 0, 2700, 2706, 1, 0, 0, 0, 2701, 2702, 
	5, 196, 0, 0, 2702, 2703, 5, 289, 0, 0, 2703, 2704, 5, 196, 0, 0, 2704, 
	2706, 6, 236, -1, 0, 2705, 2679, 1, 0, 0, 0, 2705, 2688, 1, 0, 0, 0, 2705, 
	2692, 1, 0, 0, 0, 2705, 2701, 1, 0, 0, 0, 2706, 473, 1, 0, 0, 0, 2707, 
	2708, 3, 476, 238, 0, 2708, 2709, 5, 240, 0, 0, 2709, 2716, 1, 0, 0, 0, 
	2710, 2711, 3, 476, 238, 0, 2711, 2712, 5, 244, 0, 0, 2712, 2713, 3, 314, 
	157, 0, 2713, 2714, 5, 240, 0, 0, 2714, 2716, 1, 0, 0, 0, 2715, 2707, 1, 
	0, 0, 0, 2715, 2710, 1, 0, 0, 0, 2716, 475, 1, 0, 0, 0, 2717, 2720, 3, 
	480, 240, 0, 2718, 2720, 3, 478, 239, 0, 2719, 2717, 1, 0, 0, 0, 2719, 
	2718, 1, 0, 0, 0, 2720, 477, 1, 0, 0, 0, 2721, 2722, 5, 241, 0, 0, 2722, 
	2728, 3, 314, 157, 0, 2723, 2724, 5, 242, 0, 0, 2724, 2725, 3, 314, 157, 
	0, 2725, 2726, 5, 243, 0, 0, 2726, 2727, 3, 314, 157, 0, 2727, 2729, 1, 
	0, 0, 0, 2728, 2723, 1, 0, 0, 0, 2729, 2730, 1, 0, 0, 0, 2730, 2728, 1, 
	0, 0, 0, 2730, 2731, 1, 0, 0, 0, 2731, 479, 1, 0, 0, 0, 2732, 2738, 5, 
	241, 0, 0, 2733, 2734, 5, 242, 0, 0, 2734, 2735, 3, 314, 157, 0, 2735, 
	2736, 5, 243, 0, 0, 2736, 2737, 3, 314, 157, 0, 2737, 2739, 1, 0, 0, 0, 
	2738, 2733, 1, 0, 0, 0, 2739, 2740, 1, 0, 0, 0, 2740, 2738, 1, 0, 0, 0, 
	2740, 2741, 1, 0, 0, 0, 2741, 481, 1, 0, 0, 0, 2742, 2743, 3, 556, 278, 
	0, 2743, 2744, 3, 486, 243, 0, 2744, 2748, 1, 0, 0, 0, 2745, 2746, 5, 41, 
	0, 0, 2746, 2748, 3, 486, 243, 0, 2747, 2742, 1, 0, 0, 0, 2747, 2745, 1, 
	0, 0, 0, 2748, 483, 1, 0, 0, 0, 2749, 2750, 5, 239, 0, 0, 2750, 2751, 3, 
	544, 272, 0, 2751, 2752, 3, 500, 250, 0, 2752, 485, 1, 0, 0, 0, 2753, 2754, 
	3, 488, 244, 0, 2754, 2755, 5, 286, 0, 0, 2755, 2762, 1, 0, 0, 0, 2756, 
	2757, 3, 490, 245, 0, 2757, 2758, 5, 286, 0, 0, 2758, 2759, 5, 282, 0, 
	0, 2759, 2760, 5, 286, 0, 0, 2760, 2762, 1, 0, 0, 0, 2761, 2753, 1, 0, 
	0, 0, 2761, 2756, 1, 0, 0, 0, 2762, 487, 1, 0, 0, 0, 2763, 2764, 5, 286, 
	0, 0, 2764, 489, 1, 0, 0, 0, 2765, 2766, 6, 245, -1, 0, 2766, 2767, 3, 
	488, 244, 0, 2767, 2768, 3, 492, 246, 0, 2768, 2773, 1, 0, 0, 0, 2769, 
	2770, 3, 488, 244, 0, 2770, 2771, 3, 498, 249, 0, 2771, 2773, 1, 0, 0, 
	0, 2772, 2765, 1, 0, 0, 0, 2772, 2769, 1, 0, 0, 0, 2773, 2784, 1, 0, 0, 
	0, 2774, 2775, 10, 3, 0, 0, 2775, 2776, 5, 282, 0, 0, 2776, 2783, 3, 492, 
	246, 0, 2777, 2778, 10, 2, 0, 0, 2778, 2783, 3, 492, 246, 0, 2779, 2780, 
	10, 1, 0, 0, 2780, 2781, 5, 282, 0, 0, 2781, 2783, 3, 498, 249, 0, 2782, 
	2774, 1, 0, 0, 0, 2782, 2777, 1, 0, 0, 0, 2782, 2779, 1, 0, 0, 0, 2783, 
	2786, 1, 0, 0, 0, 2784, 2782, 1, 0, 0, 0, 2784, 2785, 1, 0, 0, 0, 2785, 
	491, 1, 0, 0, 0, 2786, 2784, 1, 0, 0, 0, 2787, 2788, 3, 494, 247, 0, 2788, 
	2789, 3, 496, 248, 0, 2789, 493, 1, 0, 0, 0, 2790, 2791, 3, 454, 227, 0, 
	2791, 495, 1, 0, 0, 0, 2792, 2793, 5, 294, 0, 0, 2793, 2796, 3, 314, 157, 
	0, 2794, 2796, 3, 486, 243, 0, 2795, 2792, 1, 0, 0, 0, 2795, 2794, 1, 0, 
	0, 0, 2796, 497, 1, 0, 0, 0, 2797, 2798, 5, 289, 0, 0, 2798, 2799, 3, 546, 
	273, 0, 2799, 2800, 5, 290, 0, 0, 2800, 499, 1, 0, 0, 0, 2801, 2802, 3, 
	502, 251, 0, 2802, 2803, 5, 290, 0, 0, 2803, 2808, 1, 0, 0, 0, 2804, 2805, 
	3, 504, 252, 0, 2805, 2806, 5, 290, 0, 0, 2806, 2808, 1, 0, 0, 0, 2807, 
	2801, 1, 0, 0, 0, 2807, 2804, 1, 0, 0, 0, 2808, 501, 1, 0, 0, 0, 2809, 
	2810, 3, 504, 252, 0, 2810, 2815, 3, 506, 253, 0, 2811, 2812, 5, 282, 0, 
	0, 2812, 2814, 3, 506, 253, 0, 2813, 2811, 1, 0, 0, 0, 2814, 2817, 1, 0, 
	0, 0, 2815, 2813, 1, 0, 0, 0, 2815, 2816, 1, 0, 0, 0, 2816, 503, 1, 0, 
	0, 0, 2817, 2815, 1, 0, 0, 0, 2818, 2819, 5, 239, 0, 0, 2819, 2820, 3, 
	544, 272, 0, 2820, 2821, 5, 289, 0, 0, 2821, 505, 1, 0, 0, 0, 2822, 2834, 
	3, 314, 157, 0, 2823, 2824, 3, 314, 157, 0, 2824, 2825, 5, 3, 0, 0, 2825, 
	2826, 3, 548, 274, 0, 2826, 2834, 1, 0, 0, 0, 2827, 2828, 3, 314, 157, 
	0, 2828, 2829, 5, 3, 0, 0, 2829, 2830, 5, 289, 0, 0, 2830, 2831, 3, 546, 
	273, 0, 2831, 2832, 5, 290, 0, 0, 2832, 2834, 1, 0, 0, 0, 2833, 2822, 1, 
	0, 0, 0, 2833, 2823, 1, 0, 0, 0, 2833, 2827, 1, 0, 0, 0, 2834, 507, 1, 
	0, 0, 0, 2835, 2836, 3, 512, 256, 0, 2836, 2837, 5, 292, 0, 0, 2837, 2842, 
	1, 0, 0, 0, 2838, 2839, 3, 510, 255, 0, 2839, 2840, 5, 292, 0, 0, 2840, 
	2842, 1, 0, 0, 0, 2841, 2835, 1, 0, 0, 0, 2841, 2838, 1, 0, 0, 0, 2842, 
	509, 1, 0, 0, 0, 2843, 2844, 3, 512, 256, 0, 2844, 2849, 3, 314, 157, 0, 
	2845, 2846, 5, 282, 0, 0, 2846, 2848, 3, 314, 157, 0, 2847, 2845, 1, 0, 
	0, 0, 2848, 2851, 1, 0, 0, 0, 2849, 2847, 1, 0, 0, 0, 2849, 2850, 1, 0, 
	0, 0, 2850, 511, 1, 0, 0, 0, 2851, 2849, 1, 0, 0, 0, 2852, 2853, 5, 1, 
	0, 0, 2853, 2857, 5, 291, 0, 0, 2854, 2857, 5, 291, 0, 0, 2855, 2857, 3, 
	558, 279, 0, 2856, 2852, 1, 0, 0, 0, 2856, 2854, 1, 0, 0, 0, 2856, 2855, 
	1, 0, 0, 0, 2857, 513, 1, 0, 0, 0, 2858, 2859, 3, 516, 258, 0, 2859, 2860, 
	3, 588, 294, 0, 2860, 515, 1, 0, 0, 0, 2861, 2862, 5, 64, 0, 0, 2862, 2863, 
	3, 560, 280, 0, 2863, 2864, 3, 518, 259, 0, 2864, 2865, 3, 562, 281, 0, 
	2865, 517, 1, 0, 0, 0, 2866, 2868, 3, 536, 268, 0, 2867, 2869, 3, 530, 
	265, 0, 2868, 2867, 1, 0, 0, 0, 2868, 2869, 1, 0, 0, 0, 2869, 2871, 1, 
	0, 0, 0, 2870, 2872, 3, 520, 260, 0, 2871, 2870, 1, 0, 0, 0, 2871, 2872, 
	1, 0, 0, 0, 2872, 519, 1, 0, 0, 0, 2873, 2874, 5, 247, 0, 0, 2874, 2875, 
	3, 522, 261, 0, 2875, 521, 1, 0, 0, 0, 2876, 2880, 3, 588, 294, 0, 2877, 
	2880, 3, 526, 263, 0, 2878, 2880, 3, 524, 262, 0, 2879, 2876, 1, 0, 0, 
	0, 2879, 2877, 1, 0, 0, 0, 2879, 2878, 1, 0, 0, 0, 2880, 523, 1, 0, 0, 
	0, 2881, 2882, 5, 304, 0, 0, 2882, 2883, 3, 546, 273, 0, 2883, 525, 1, 
	0, 0, 0, 2884, 2887, 3, 528, 264, 0, 2885, 2887, 5, 302, 0, 0, 2886, 2884, 
	1, 0, 0, 0, 2886, 2885, 1, 0, 0, 0, 2887, 527, 1, 0, 0, 0, 2888, 2889, 
	5, 303, 0, 0, 2889, 2890, 3, 548, 274, 0, 2890, 529, 1, 0, 0, 0, 2891, 
	2892, 3, 532, 266, 0, 2892, 2893, 5, 290, 0, 0, 2893, 2900, 1, 0, 0, 0, 
	2894, 2895, 3, 532, 266, 0, 2895, 2896, 5, 282, 0, 0, 2896, 2897, 5, 290, 
	0, 0, 2897, 2898, 6, 265, -1, 0, 2898, 2900, 1, 0, 0, 0, 2899, 2891, 1, 
	0, 0, 0, 2899, 2894, 1, 0, 0, 0, 2900, 531, 1, 0, 0, 0, 2901, 2902, 5, 
	289, 0, 0, 2902, 2907, 3, 534, 267, 0, 2903, 2904, 5, 282, 0, 0, 2904, 
	2906, 3, 534, 267, 0, 2905, 2903, 1, 0, 0, 0, 2906, 2909, 1, 0, 0, 0, 2907, 
	2905, 1, 0, 0, 0, 2907, 2908, 1, 0, 0, 0, 2908, 533, 1, 0, 0, 0, 2909, 
	2907, 1, 0, 0, 0, 2910, 2917, 3, 580, 290, 0, 2911, 2917, 3, 586, 293, 
	0, 2912, 2917, 3, 588, 294, 0, 2913, 2917, 3, 582, 291, 0, 2914, 2917, 
	3, 568, 284, 0, 2915, 2917, 5, 153, 0, 0, 2916, 2910, 1, 0, 0, 0, 2916, 
	2911, 1, 0, 0, 0, 2916, 2912, 1, 0, 0, 0, 2916, 2913, 1, 0, 0, 0, 2916, 
	2914, 1, 0, 0, 0, 2916, 2915, 1, 0, 0, 0, 2917, 535, 1, 0, 0, 0, 2918, 
	2925, 3, 558, 279, 0, 2919, 2925, 3, 556, 278, 0, 2920, 2925, 3, 544, 272, 
	0, 2921, 2925, 3, 516, 258, 0, 2922, 2925, 3, 540, 270, 0, 2923, 2925, 
	3, 538, 269, 0, 2924, 2918, 1, 0, 0, 0, 2924, 2919, 1, 0, 0, 0, 2924, 2920, 
	1, 0, 0, 0, 2924, 2921, 1, 0, 0, 0, 2924, 2922, 1, 0, 0, 0, 2924, 2923, 
	1, 0, 0, 0, 2925, 537, 1, 0, 0, 0, 2926, 2927, 5, 148, 0, 0, 2927, 2928, 
	3, 560, 280, 0, 2928, 2929, 3, 518, 259, 0, 2929, 2930, 5, 282, 0, 0, 2930, 
	2931, 3, 518, 259, 0, 2931, 2932, 3, 562, 281, 0, 2932, 539, 1, 0, 0, 0, 
	2933, 2934, 5, 123, 0, 0, 2934, 2935, 3, 560, 280, 0, 2935, 2936, 5, 289, 
	0, 0, 2936, 2937, 5, 290, 0, 0, 2937, 2938, 5, 306, 0, 0, 2938, 2939, 3, 
	518, 259, 0, 2939, 2940, 3, 562, 281, 0, 2940, 2955, 1, 0, 0, 0, 2941, 
	2942, 5, 123, 0, 0, 2942, 2943, 3, 560, 280, 0, 2943, 2944, 3, 518, 259, 
	0, 2944, 2945, 5, 306, 0, 0, 2945, 2946, 3, 518, 259, 0, 2946, 2947, 3, 
	562, 281, 0, 2947, 2955, 1, 0, 0, 0, 2948, 2949, 3, 542, 271, 0, 2949, 
	2950, 5, 290, 0, 0, 2950, 2951, 5, 306, 0, 0, 2951, 2952, 3, 518, 259, 
	0, 2952, 2953, 3, 562, 281, 0, 2953, 2955, 1, 0, 0, 0, 2954, 2933, 1, 0, 
	0, 0, 2954, 2941, 1, 0, 0, 0, 2954, 2948, 1, 0, 0, 0, 2955, 541, 1, 0, 
	0, 0, 2956, 2957, 5, 123, 0, 0, 2957, 2958, 3, 560, 280, 0, 2958, 2959, 
	5, 289, 0, 0, 2959, 2964, 3, 518, 259, 0, 2960, 2961, 5, 282, 0, 0, 2961, 
	2963, 3, 518, 259, 0, 2962, 2960, 1, 0, 0, 0, 2963, 2966, 1, 0, 0, 0, 2964, 
	2962, 1, 0, 0, 0, 2964, 2965, 1, 0, 0, 0, 2965, 543, 1, 0, 0, 0, 2966, 
	2964, 1, 0, 0, 0, 2967, 2970, 3, 546, 273, 0, 2968, 2970, 5, 65, 0, 0, 
	2969, 2967, 1, 0, 0, 0, 2969, 2968, 1, 0, 0, 0, 2970, 545, 1, 0, 0, 0, 
	2971, 2972, 6, 273, -1, 0, 2972, 2973, 3, 548, 274, 0, 2973, 2979, 1, 0, 
	0, 0, 2974, 2975, 10, 1, 0, 0, 2975, 2976, 5, 283, 0, 0, 2976, 2978, 3, 
	548, 274, 0, 2977, 2974, 1, 0, 0, 0, 2978, 2981, 1, 0, 0, 0, 2979, 2977, 
	1, 0, 0, 0, 2979, 2980, 1, 0, 0, 0, 2980, 547, 1, 0, 0, 0, 2981, 2979, 
	1, 0, 0, 0, 2982, 2985, 3, 554, 277, 0, 2983, 2985, 3, 550, 275, 0, 2984, 
	2982, 1, 0, 0, 0, 2984, 2983, 1, 0, 0, 0, 2985, 549, 1, 0, 0, 0, 2986, 
	2989, 3, 552, 276, 0, 2987, 2989, 5, 66, 0, 0, 2988, 2986, 1, 0, 0, 0, 
	2988, 2987, 1, 0, 0, 0, 2989, 551, 1, 0, 0, 0, 2990, 2991, 7, 14, 0, 0, 
	2991, 553, 1, 0, 0, 0, 2992, 2993, 5, 325, 0, 0, 2993, 555, 1, 0, 0, 0, 
	2994, 2995, 5, 41, 0, 0, 2995, 2996, 3, 560, 280, 0, 2996, 2997, 3, 562, 
	281, 0, 2997, 557, 1, 0, 0, 0, 2998, 2999, 5, 1, 0, 0, 2999, 3000, 3, 560, 
	280, 0, 3000, 3001, 3, 518, 259, 0, 3001, 3002, 3, 562, 281, 0, 3002, 559, 
	1, 0, 0, 0, 3003, 3004, 5, 287, 0, 0, 3004, 561, 1, 0, 0, 0, 3005, 3006, 
	5, 288, 0, 0, 3006, 563, 1, 0, 0, 0, 3007, 3008, 3, 566, 283, 0, 3008, 
	3009, 3, 588, 294, 0, 3009, 565, 1, 0, 0, 0, 3010, 3011, 7, 15, 0, 0, 3011, 
	567, 1, 0, 0, 0, 3012, 3013, 5, 313, 0, 0, 3013, 569, 1, 0, 0, 0, 3014, 
	3015, 5, 59, 0, 0, 3015, 3016, 3, 588, 294, 0, 3016, 571, 1, 0, 0, 0, 3017, 
	3018, 3, 574, 287, 0, 3018, 3019, 3, 588, 294, 0, 3019, 573, 1, 0, 0, 0, 
	3020, 3021, 7, 16, 0, 0, 3021, 575, 1, 0, 0, 0, 3022, 3023, 3, 578, 289, 
	0, 3023, 3024, 3, 588, 294, 0, 3024, 577, 1, 0, 0, 0, 3025, 3026, 7, 17, 
	0, 0, 3026, 579, 1, 0, 0, 0, 3027, 3028, 5, 324, 0, 0, 3028, 581, 1, 0, 
	0, 0, 3029, 3030, 6, 291, -1, 0, 3030, 3031, 3, 592, 296, 0, 3031, 3042, 
	1, 0, 0, 0, 3032, 3033, 10, 2, 0, 0, 3033, 3034, 3, 592, 296, 0, 3034, 
	3035, 6, 291, -1, 0, 3035, 3041, 1, 0, 0, 0, 3036, 3037, 10, 1, 0, 0, 3037, 
	3038, 3, 590, 295, 0, 3038, 3039, 6, 291, -1, 0, 3039, 3041, 1, 0, 0, 0, 
	3040, 3032, 1, 0, 0, 0, 3040, 3036, 1, 0, 0, 0, 3041, 3044, 1, 0, 0, 0, 
	3042, 3040, 1, 0, 0, 0, 3042, 3043, 1, 0, 0, 0, 3043, 583, 1, 0, 0, 0, 
	3044, 3042, 1, 0, 0, 0, 3045, 3046, 5, 25, 0, 0, 3046, 585, 1, 0, 0, 0, 
	3047, 3048, 7, 18, 0, 0, 3048, 587, 1, 0, 0, 0, 3049, 3050, 6, 294, -1, 
	0, 3050, 3051, 3, 590, 295, 0, 3051, 3062, 1, 0, 0, 0, 3052, 3053, 10, 
	2, 0, 0, 3053, 3054, 3, 590, 295, 0, 3054, 3055, 6, 294, -1, 0, 3055, 3061, 
	1, 0, 0, 0, 3056, 3057, 10, 1, 0, 0, 3057, 3058, 3, 592, 296, 0, 3058, 
	3059, 6, 294, -1, 0, 3059, 3061, 1, 0, 0, 0, 3060, 3052, 1, 0, 0, 0, 3060, 
	3056, 1, 0, 0, 0, 3061, 3064, 1, 0, 0, 0, 3062, 3060, 1, 0, 0, 0, 3062, 
	3063, 1, 0, 0, 0, 3063, 589, 1, 0, 0, 0, 3064, 3062, 1, 0, 0, 0, 3065, 
	3066, 5, 314, 0, 0, 3066, 591, 1, 0, 0, 0, 3067, 3068, 5, 315, 0, 0, 3068, 
	593, 1, 0, 0, 0, 3069, 3070, 3, 608, 304, 0, 3070, 595, 1, 0, 0, 0, 3071, 
	3072, 3, 608, 304, 0, 3072, 597, 1, 0, 0, 0, 3073, 3074, 7, 19, 0, 0, 3074, 
	599, 1, 0, 0, 0, 3075, 3076, 3, 598, 299, 0, 3076, 601, 1, 0, 0, 0, 3077, 
	3078, 3, 598, 299, 0, 3078, 603, 1, 0, 0, 0, 3079, 3080, 3, 598, 299, 0, 
	3080, 605, 1, 0, 0, 0, 3081, 3082, 3, 598, 299, 0, 3082, 607, 1, 0, 0, 
	0, 3083, 3086, 3, 610, 305, 0, 3084, 3086, 3, 612, 306, 0, 3085, 3083, 
	1, 0, 0, 0, 3085, 3084, 1, 0, 0, 0, 3086, 609, 1, 0, 0, 0, 3087, 3088, 
	5, 312, 0, 0, 3088, 611, 1, 0, 0, 0, 3089, 3090, 5, 313, 0, 0, 3090, 613, 
	1, 0, 0, 0, 319, 622, 626, 637, 640, 652, 655, 658, 662, 669, 675, 688, 
	702, 713, 715, 722, 725, 729, 733, 736, 741, 751, 756, 758, 768, 775, 782, 
	789, 805, 809, 814, 825, 833, 838, 841, 844, 851, 856, 864, 868, 874, 877, 
	880, 883, 886, 890, 893, 896, 899, 902, 905, 908, 911, 914, 916, 926, 941, 
	948, 951, 954, 957, 962, 965, 968, 971, 975, 981, 990, 1003, 1010, 1013, 
	1016, 1018, 1029, 1035, 1037, 1043, 1046, 1051, 1054, 1056, 1065, 1071, 
	1092, 1096, 1101, 1114, 1120, 1127, 1129, 1138, 1146, 1153, 1157, 1168, 
	1174, 1187, 1197, 1207, 1215, 1222, 1231, 1237, 1241, 1245, 1249, 1253, 
	1258, 1262, 1268, 1271, 1274, 1277, 1290, 1295, 1304, 1310, 1320, 1325, 
	1333, 1337, 1342, 1364, 1368, 1372, 1382, 1399, 1412, 1414, 1431, 1433, 
	1438, 1450, 1454, 1462, 1471, 1479, 1487, 1520, 1527, 1539, 1548, 1558, 
	1580, 1585, 1588, 1592, 1595, 1602, 1609, 1616, 1634, 1639, 1646, 1651, 
	1656, 1661, 1666, 1670, 1672, 1688, 1693, 1696, 1719, 1727, 1732, 1749, 
	1756, 1761, 1768, 1772, 1777, 1784, 1796, 1804, 1809, 1811, 1822, 1824, 
	1831, 1834, 1839, 1841, 1846, 1849, 1854, 1859, 1864, 1867, 1871, 1886, 
	1891, 1895, 1900, 1904, 1907, 1924, 1932, 1937, 1942, 1966, 1974, 1981, 
	1986, 2014, 2021, 2027, 2044, 2053, 2105, 2113, 2121, 2131, 2141, 2149, 
	2155, 2158, 2169, 2177, 2182, 2192, 2200, 2207, 2211, 2214, 2217, 2221, 
	2224, 2227, 2233, 2236, 2239, 2242, 2245, 2248, 2252, 2260, 2263, 2266, 
	2269, 2272, 2283, 2292, 2302, 2310, 2333, 2341, 2350, 2358, 2365, 2373, 
	2386, 2395, 2404, 2414, 2422, 2427, 2430, 2440, 2449, 2457, 2470, 2474, 
	2482, 2485, 2496, 2506, 2518, 2526, 2536, 2544, 2548, 2556, 2568, 2584, 
	2595, 2611, 2613, 2630, 2644, 2661, 2672, 2684, 2697, 2705, 2715, 2719, 
	2730, 2740, 2747, 2761, 2772, 2782, 2784, 2795, 2807, 2815, 2833, 2841, 
	2849, 2856, 2868, 2871, 2879, 2886, 2899, 2907, 2916, 2924, 2954, 2964, 
	2969, 2979, 2984, 2988, 3040, 3042, 3060, 3062, 3085,
}
  deserializer := antlr.NewATNDeserializer(nil)
  staticData.atn = deserializer.Deserialize(staticData.serializedATN)
  atn := staticData.atn
  staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
  decisionToDFA := staticData.decisionToDFA
  for index, state := range atn.DecisionToState {
    decisionToDFA[index] = antlr.NewDFA(state, index)
  }
}

// GoogleSQLParserInit initializes any static state used to implement GoogleSQLParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewGoogleSQLParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func GoogleSQLParserInit() {
  staticData := &GoogleSQLParserParserStaticData
  staticData.once.Do(googlesqlparserParserInit)
}

// NewGoogleSQLParser produces a new parser instance for the optional input antlr.TokenStream.
func NewGoogleSQLParser(input antlr.TokenStream) *GoogleSQLParser {
	GoogleSQLParserInit()
	this := new(GoogleSQLParser)
	this.BaseParser = antlr.NewBaseParser(input)
  staticData := &GoogleSQLParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "GoogleSQLParser.g4"

	return this
}


// GoogleSQLParser tokens.
const (
	GoogleSQLParserEOF = antlr.TokenEOF
	GoogleSQLParserARRAY_SYMBOL = 1
	GoogleSQLParserALL_SYMBOL = 2
	GoogleSQLParserAS_SYMBOL = 3
	GoogleSQLParserASC_SYMBOL = 4
	GoogleSQLParserBY_SYMBOL = 5
	GoogleSQLParserCROSS_SYMBOL = 6
	GoogleSQLParserJOIN_SYMBOL = 7
	GoogleSQLParserDELTA_SYMBOL = 8
	GoogleSQLParserDESC_SYMBOL = 9
	GoogleSQLParserDIFFERENTIAL_PRIVACY_SYMBOL = 10
	GoogleSQLParserDISTINCT_SYMBOL = 11
	GoogleSQLParserEPSILON_SYMBOL = 12
	GoogleSQLParserEXCEPT_SYMBOL = 13
	GoogleSQLParserEXCLUDE_SYMBOL = 14
	GoogleSQLParserFOR_SYMBOL = 15
	GoogleSQLParserFROM_SYMBOL = 16
	GoogleSQLParserFULL_SYMBOL = 17
	GoogleSQLParserIN_SYMBOL = 18
	GoogleSQLParserINCLUDE_SYMBOL = 19
	GoogleSQLParserINNER_SYMBOL = 20
	GoogleSQLParserINTERSECT_SYMBOL = 21
	GoogleSQLParserLEFT_SYMBOL = 22
	GoogleSQLParserLIMIT_SYMBOL = 23
	GoogleSQLParserMAX_GROUPS_CONTRIBUTED_SYMBOL = 24
	GoogleSQLParserNULL_SYMBOL = 25
	GoogleSQLParserNULLS_SYMBOL = 26
	GoogleSQLParserOF_SYMBOL = 27
	GoogleSQLParserOFFSET_SYMBOL = 28
	GoogleSQLParserON_SYMBOL = 29
	GoogleSQLParserOPTIONS_SYMBOL = 30
	GoogleSQLParserORDER_SYMBOL = 31
	GoogleSQLParserOUTER_SYMBOL = 32
	GoogleSQLParserPERCENT_SYMBOL = 33
	GoogleSQLParserPIVOT_SYMBOL = 34
	GoogleSQLParserPRIVACY_UNIT_COLUMN_SYMBOL = 35
	GoogleSQLParserRIGHT_SYMBOL = 36
	GoogleSQLParserRECURSIVE_SYMBOL = 37
	GoogleSQLParserREPLACE_SYMBOL = 38
	GoogleSQLParserUNPIVOT_SYMBOL = 39
	GoogleSQLParserSELECT_SYMBOL = 40
	GoogleSQLParserSTRUCT_SYMBOL = 41
	GoogleSQLParserSYSTEM_SYMBOL = 42
	GoogleSQLParserSYSTEM_TIME_SYMBOL = 43
	GoogleSQLParserTABLESAMPLE_SYMBOL = 44
	GoogleSQLParserUNION_SYMBOL = 45
	GoogleSQLParserUNNEST_SYMBOL = 46
	GoogleSQLParserUSING_SYMBOL = 47
	GoogleSQLParserVALUE_SYMBOL = 48
	GoogleSQLParserWITH_SYMBOL = 49
	GoogleSQLParserTRUE_SYMBOL = 50
	GoogleSQLParserFALSE_SYMBOL = 51
	GoogleSQLParserNUMERIC_SYMBOL = 52
	GoogleSQLParserDECIMAL_SYMBOL = 53
	GoogleSQLParserBIGNUMERIC_SYMBOL = 54
	GoogleSQLParserBIGDECIMAL_SYMBOL = 55
	GoogleSQLParserNOT_SYMBOL = 56
	GoogleSQLParserAND_SYMBOL = 57
	GoogleSQLParserOR_SYMBOL = 58
	GoogleSQLParserJSON_SYMBOL = 59
	GoogleSQLParserDATE_SYMBOL = 60
	GoogleSQLParserTIME_SYMBOL = 61
	GoogleSQLParserDATETIME_SYMBOL = 62
	GoogleSQLParserTIMESTAMP_SYMBOL = 63
	GoogleSQLParserRANGE_SYMBOL = 64
	GoogleSQLParserINTERVAL_SYMBOL = 65
	GoogleSQLParserSIMPLE_SYMBOL = 66
	GoogleSQLParserABORT_SYMBOL = 67
	GoogleSQLParserACCESS_SYMBOL = 68
	GoogleSQLParserACTION_SYMBOL = 69
	GoogleSQLParserAGGREGATE_SYMBOL = 70
	GoogleSQLParserADD_SYMBOL = 71
	GoogleSQLParserALTER_SYMBOL = 72
	GoogleSQLParserALWAYS_SYMBOL = 73
	GoogleSQLParserANALYZE_SYMBOL = 74
	GoogleSQLParserAPPROX_SYMBOL = 75
	GoogleSQLParserARE_SYMBOL = 76
	GoogleSQLParserASSERT_SYMBOL = 77
	GoogleSQLParserBATCH_SYMBOL = 78
	GoogleSQLParserBEGIN_SYMBOL = 79
	GoogleSQLParserBREAK_SYMBOL = 80
	GoogleSQLParserCALL_SYMBOL = 81
	GoogleSQLParserCASCADE_SYMBOL = 82
	GoogleSQLParserCHECK_SYMBOL = 83
	GoogleSQLParserCLAMPED_SYMBOL = 84
	GoogleSQLParserCLONE_SYMBOL = 85
	GoogleSQLParserCOPY_SYMBOL = 86
	GoogleSQLParserCLUSTER_SYMBOL = 87
	GoogleSQLParserCOLUMN_SYMBOL = 88
	GoogleSQLParserCOLUMNS_SYMBOL = 89
	GoogleSQLParserCOMMIT_SYMBOL = 90
	GoogleSQLParserCONNECTION_SYMBOL = 91
	GoogleSQLParserCONSTANT_SYMBOL = 92
	GoogleSQLParserCONSTRAINT_SYMBOL = 93
	GoogleSQLParserCONTINUE_SYMBOL = 94
	GoogleSQLParserCORRESPONDING_SYMBOL = 95
	GoogleSQLParserCYCLE_SYMBOL = 96
	GoogleSQLParserDATA_SYMBOL = 97
	GoogleSQLParserDATABASE_SYMBOL = 98
	GoogleSQLParserDECLARE_SYMBOL = 99
	GoogleSQLParserDEFINER_SYMBOL = 100
	GoogleSQLParserDELETE_SYMBOL = 101
	GoogleSQLParserDELETION_SYMBOL = 102
	GoogleSQLParserDEPTH_SYMBOL = 103
	GoogleSQLParserDESCRIBE_SYMBOL = 104
	GoogleSQLParserDETERMINISTIC_SYMBOL = 105
	GoogleSQLParserDO_SYMBOL = 106
	GoogleSQLParserDROP_SYMBOL = 107
	GoogleSQLParserELSEIF_SYMBOL = 108
	GoogleSQLParserENFORCED_SYMBOL = 109
	GoogleSQLParserERROR_SYMBOL = 110
	GoogleSQLParserEXCEPTION_SYMBOL = 111
	GoogleSQLParserEXECUTE_SYMBOL = 112
	GoogleSQLParserEXPLAIN_SYMBOL = 113
	GoogleSQLParserEXPORT_SYMBOL = 114
	GoogleSQLParserEXTEND_SYMBOL = 115
	GoogleSQLParserEXTERNAL_SYMBOL = 116
	GoogleSQLParserFILES_SYMBOL = 117
	GoogleSQLParserFILTER_SYMBOL = 118
	GoogleSQLParserFILL_SYMBOL = 119
	GoogleSQLParserFIRST_SYMBOL = 120
	GoogleSQLParserFOREIGN_SYMBOL = 121
	GoogleSQLParserFORMAT_SYMBOL = 122
	GoogleSQLParserFUNCTION_SYMBOL = 123
	GoogleSQLParserGENERATED_SYMBOL = 124
	GoogleSQLParserGRANT_SYMBOL = 125
	GoogleSQLParserGROUP_ROWS_SYMBOL = 126
	GoogleSQLParserHIDDEN_SYMBOL = 127
	GoogleSQLParserIDENTITY_SYMBOL = 128
	GoogleSQLParserIMMEDIATE_SYMBOL = 129
	GoogleSQLParserIMMUTABLE_SYMBOL = 130
	GoogleSQLParserIMPORT_SYMBOL = 131
	GoogleSQLParserINCREMENT_SYMBOL = 132
	GoogleSQLParserINDEX_SYMBOL = 133
	GoogleSQLParserINOUT_SYMBOL = 134
	GoogleSQLParserINPUT_SYMBOL = 135
	GoogleSQLParserINSERT_SYMBOL = 136
	GoogleSQLParserINVOKER_SYMBOL = 137
	GoogleSQLParserISOLATION_SYMBOL = 138
	GoogleSQLParserITERATE_SYMBOL = 139
	GoogleSQLParserKEY_SYMBOL = 140
	GoogleSQLParserLANGUAGE_SYMBOL = 141
	GoogleSQLParserLAST_SYMBOL = 142
	GoogleSQLParserLEAVE_SYMBOL = 143
	GoogleSQLParserLEVEL_SYMBOL = 144
	GoogleSQLParserLOAD_SYMBOL = 145
	GoogleSQLParserLOOP_SYMBOL = 146
	GoogleSQLParserMACRO_SYMBOL = 147
	GoogleSQLParserMAP_SYMBOL = 148
	GoogleSQLParserMATCH_SYMBOL = 149
	GoogleSQLParserKW_MATCH_RECOGNIZE_NONRESERVED_SYMBOL = 150
	GoogleSQLParserMATCHED_SYMBOL = 151
	GoogleSQLParserMATERIALIZED_SYMBOL = 152
	GoogleSQLParserMAX_SYMBOL = 153
	GoogleSQLParserMAXVALUE_SYMBOL = 154
	GoogleSQLParserMEASURES_SYMBOL = 155
	GoogleSQLParserMESSAGE_SYMBOL = 156
	GoogleSQLParserMETADATA_SYMBOL = 157
	GoogleSQLParserMIN_SYMBOL = 158
	GoogleSQLParserMINVALUE_SYMBOL = 159
	GoogleSQLParserMODEL_SYMBOL = 160
	GoogleSQLParserMODULE_SYMBOL = 161
	GoogleSQLParserONLY_SYMBOL = 162
	GoogleSQLParserOUT_SYMBOL = 163
	GoogleSQLParserOUTPUT_SYMBOL = 164
	GoogleSQLParserOVERWRITE_SYMBOL = 165
	GoogleSQLParserPARTITIONS_SYMBOL = 166
	GoogleSQLParserPATTERN_SYMBOL = 167
	GoogleSQLParserPOLICIES_SYMBOL = 168
	GoogleSQLParserPOLICY_SYMBOL = 169
	GoogleSQLParserPRIMARY_SYMBOL = 170
	GoogleSQLParserPRIVATE_SYMBOL = 171
	GoogleSQLParserPRIVILEGE_SYMBOL = 172
	GoogleSQLParserPRIVILEGES_SYMBOL = 173
	GoogleSQLParserPROCEDURE_SYMBOL = 174
	GoogleSQLParserPROJECT_SYMBOL = 175
	GoogleSQLParserPUBLIC_SYMBOL = 176
	GoogleSQLParserRAISE_SYMBOL = 177
	GoogleSQLParserREAD_SYMBOL = 178
	GoogleSQLParserREFERENCES_SYMBOL = 179
	GoogleSQLParserREMOTE_SYMBOL = 180
	GoogleSQLParserREMOVE_SYMBOL = 181
	GoogleSQLParserRENAME_SYMBOL = 182
	GoogleSQLParserREPEAT_SYMBOL = 183
	GoogleSQLParserREPEATABLE_SYMBOL = 184
	GoogleSQLParserREPLACE_FIELDS_SYMBOL = 185
	GoogleSQLParserREPLICA_SYMBOL = 186
	GoogleSQLParserREPORT_SYMBOL = 187
	GoogleSQLParserRESTRICT_SYMBOL = 188
	GoogleSQLParserRESTRICTION_SYMBOL = 189
	GoogleSQLParserRETURNS_SYMBOL = 190
	GoogleSQLParserRETURN_SYMBOL = 191
	GoogleSQLParserREVOKE_SYMBOL = 192
	GoogleSQLParserROLLBACK_SYMBOL = 193
	GoogleSQLParserROW_SYMBOL = 194
	GoogleSQLParserRUN_SYMBOL = 195
	GoogleSQLParserSAFE_CAST_SYMBOL = 196
	GoogleSQLParserSCHEMA_SYMBOL = 197
	GoogleSQLParserSEARCH_SYMBOL = 198
	GoogleSQLParserSECURITY_SYMBOL = 199
	GoogleSQLParserSEQUENCE_SYMBOL = 200
	GoogleSQLParserSETS_SYMBOL = 201
	GoogleSQLParserSHOW_SYMBOL = 202
	GoogleSQLParserSNAPSHOT_SYMBOL = 203
	GoogleSQLParserSOURCE_SYMBOL = 204
	GoogleSQLParserSQL_SYMBOL = 205
	GoogleSQLParserSTABLE_SYMBOL = 206
	GoogleSQLParserSTART_SYMBOL = 207
	GoogleSQLParserSTATIC_DESCRIBE_SYMBOL = 208
	GoogleSQLParserSTORED_SYMBOL = 209
	GoogleSQLParserSTORING_SYMBOL = 210
	GoogleSQLParserSTRICT_SYMBOL = 211
	GoogleSQLParserTABLE_SYMBOL = 212
	GoogleSQLParserTABLES_SYMBOL = 213
	GoogleSQLParserTARGET_SYMBOL = 214
	GoogleSQLParserTEMP_SYMBOL = 215
	GoogleSQLParserTEMPORARY_SYMBOL = 216
	GoogleSQLParserTRANSACTION_SYMBOL = 217
	GoogleSQLParserTRANSFORM_SYMBOL = 218
	GoogleSQLParserTRUNCATE_SYMBOL = 219
	GoogleSQLParserTYPE_SYMBOL = 220
	GoogleSQLParserUNDROP_SYMBOL = 221
	GoogleSQLParserUNIQUE_SYMBOL = 222
	GoogleSQLParserUNKNOWN_SYMBOL = 223
	GoogleSQLParserUNTIL_SYMBOL = 224
	GoogleSQLParserUPDATE_SYMBOL = 225
	GoogleSQLParserVALUES_SYMBOL = 226
	GoogleSQLParserVECTOR_SYMBOL = 227
	GoogleSQLParserVIEW_SYMBOL = 228
	GoogleSQLParserVIEWS_SYMBOL = 229
	GoogleSQLParserVOLATILE_SYMBOL = 230
	GoogleSQLParserWEIGHT_SYMBOL = 231
	GoogleSQLParserWHILE_SYMBOL = 232
	GoogleSQLParserWRITE_SYMBOL = 233
	GoogleSQLParserZONE_SYMBOL = 234
	GoogleSQLParserDESCRIPTOR_SYMBOL = 235
	GoogleSQLParserINTERLEAVE_SYMBOL = 236
	GoogleSQLParserNULL_FILTERED_SYMBOL = 237
	GoogleSQLParserPARENT_SYMBOL = 238
	GoogleSQLParserNEW_SYMBOL = 239
	GoogleSQLParserEND_SYMBOL = 240
	GoogleSQLParserCASE_SYMBOL = 241
	GoogleSQLParserWHEN_SYMBOL = 242
	GoogleSQLParserTHEN_SYMBOL = 243
	GoogleSQLParserELSE_SYMBOL = 244
	GoogleSQLParserCAST_SYMBOL = 245
	GoogleSQLParserEXTRACT_SYMBOL = 246
	GoogleSQLParserCOLLATE_SYMBOL = 247
	GoogleSQLParserIF_SYMBOL = 248
	GoogleSQLParserGROUPING_SYMBOL = 249
	GoogleSQLParserHAVING_SYMBOL = 250
	GoogleSQLParserGROUP_SYMBOL = 251
	GoogleSQLParserROLLUP_SYMBOL = 252
	GoogleSQLParserCUBE_SYMBOL = 253
	GoogleSQLParserHASH_SYMBOL = 254
	GoogleSQLParserPROTO_SYMBOL = 255
	GoogleSQLParserPARTITION_SYMBOL = 256
	GoogleSQLParserIGNORE_SYMBOL = 257
	GoogleSQLParserRESPECT_SYMBOL = 258
	GoogleSQLParserROWS_SYMBOL = 259
	GoogleSQLParserOVER_SYMBOL = 260
	GoogleSQLParserBETWEEN_SYMBOL = 261
	GoogleSQLParserUNBOUNDED_SYMBOL = 262
	GoogleSQLParserCURRENT_SYMBOL = 263
	GoogleSQLParserPRECEDING_SYMBOL = 264
	GoogleSQLParserFOLLOWING_SYMBOL = 265
	GoogleSQLParserNATURAL_SYMBOL = 266
	GoogleSQLParserQUALIFY_SYMBOL = 267
	GoogleSQLParserDEFAULT_SYMBOL = 268
	GoogleSQLParserSLASH_SYMBOL = 269
	GoogleSQLParserMATCH_RECOGNIZE_SYMBOL = 270
	GoogleSQLParserDEFINE_SYMBOL = 271
	GoogleSQLParserLOOKUP_SYMBOL = 272
	GoogleSQLParserWHERE_SYMBOL = 273
	GoogleSQLParserWINDOW_SYMBOL = 274
	GoogleSQLParserTO_SYMBOL = 275
	GoogleSQLParserEXISTS_SYMBOL = 276
	GoogleSQLParserNOT_SPECIAL_SYMBOL = 277
	GoogleSQLParserANY_SYMBOL = 278
	GoogleSQLParserSOME_SYMBOL = 279
	GoogleSQLParserLIKE_SYMBOL = 280
	GoogleSQLParserASTERISK_SYMBOL = 281
	GoogleSQLParserCOMMA_SYMBOL = 282
	GoogleSQLParserDOT_SYMBOL = 283
	GoogleSQLParserEQUAL_SYMBOL = 284
	GoogleSQLParserLC_BRACKET_SYMBOL = 285
	GoogleSQLParserRC_BRACKET_SYMBOL = 286
	GoogleSQLParserLT_BRACKET_SYMBOL = 287
	GoogleSQLParserGT_BRACKET_SYMBOL = 288
	GoogleSQLParserLR_BRACKET_SYMBOL = 289
	GoogleSQLParserRR_BRACKET_SYMBOL = 290
	GoogleSQLParserLS_BRACKET_SYMBOL = 291
	GoogleSQLParserRS_BRACKET_SYMBOL = 292
	GoogleSQLParserSTROKE_SYMBOL = 293
	GoogleSQLParserCOLON_SYMBOL = 294
	GoogleSQLParserSEMI_SYMBOL = 295
	GoogleSQLParserSINGLE_QUOTE_SYMBOL = 296
	GoogleSQLParserSINGLE_QUOTE_3_SYMBOL = 297
	GoogleSQLParserDOUBLE_QUOTE_SYMBOL = 298
	GoogleSQLParserDOUBLE_QUOTE_3_SYMBOL = 299
	GoogleSQLParserBACKQUOTE_SYMBOL = 300
	GoogleSQLParserDASH_SYMBOL = 301
	GoogleSQLParserQUESTION_SYMBOL = 302
	GoogleSQLParserAT_SYMBOL = 303
	GoogleSQLParserATAT_SYMBOL = 304
	GoogleSQLParserEQUAL_GT_BRACKET_SYMBOL = 305
	GoogleSQLParserSUB_GT_BRACKET_SYMBOL = 306
	GoogleSQLParserPLUS_EQUAL_SYMBOL = 307
	GoogleSQLParserSUB_EQUAL_SYMBOL = 308
	GoogleSQLParserPIPE_SYMBOL = 309
	GoogleSQLParserQUOTED_ID = 310
	GoogleSQLParserID = 311
	GoogleSQLParserINT = 312
	GoogleSQLParserFLOAT = 313
	GoogleSQLParserSTRING_LITERAL = 314
	GoogleSQLParserBYTES_LITERAL = 315
	GoogleSQLParserUNCLOSED_STRING_LITERAL = 316
	GoogleSQLParserUNCLOSED_TRIPLE_QUOTED_STRING_LITERAL = 317
	GoogleSQLParserUNCLOSED_RAW_STRING_LITERAL = 318
	GoogleSQLParserUNCLOSED_TRIPLE_QUOTED_RAW_STRING_LITERAL = 319
	GoogleSQLParserUNCLOSED_BYTES_LITERAL = 320
	GoogleSQLParserUNCLOSED_TRIPLE_QUOTED_BYTES_LITERAL = 321
	GoogleSQLParserUNCLOSED_RAW_BYTES_LITERAL = 322
	GoogleSQLParserUNCLOSED_TRIPLE_QUOTED_RAW_BYTES_LITERAL = 323
	GoogleSQLParserINTEGER_LITERAL = 324
	GoogleSQLParserIDENTIFIER = 325
	GoogleSQLParserUNCLOSED_ESCAPED_IDENTIFIER = 326
	GoogleSQLParserWHITESPACE = 327
)

// GoogleSQLParser rules.
const (
	GoogleSQLParserRULE_root = 0
	GoogleSQLParserRULE_stmts = 1
	GoogleSQLParserRULE_stmt = 2
	GoogleSQLParserRULE_query_statement = 3
	GoogleSQLParserRULE_query = 4
	GoogleSQLParserRULE_query_without_pipe_operators = 5
	GoogleSQLParserRULE_bad_keyword_after_from_query = 6
	GoogleSQLParserRULE_bad_keyword_after_from_query_allows_parens = 7
	GoogleSQLParserRULE_with_clause_with_trailing_comma = 8
	GoogleSQLParserRULE_select_or_from_keyword = 9
	GoogleSQLParserRULE_query_primary_or_set_operation = 10
	GoogleSQLParserRULE_query_set_operation = 11
	GoogleSQLParserRULE_query_set_operation_prefix = 12
	GoogleSQLParserRULE_query_primary = 13
	GoogleSQLParserRULE_set_operation_metadata = 14
	GoogleSQLParserRULE_opt_column_match_suffix = 15
	GoogleSQLParserRULE_opt_strict = 16
	GoogleSQLParserRULE_all_or_distinct = 17
	GoogleSQLParserRULE_query_set_operation_type = 18
	GoogleSQLParserRULE_opt_corresponding_outer_mode = 19
	GoogleSQLParserRULE_opt_outer = 20
	GoogleSQLParserRULE_with_clause = 21
	GoogleSQLParserRULE_aliased_query = 22
	GoogleSQLParserRULE_opt_aliased_query_modifiers = 23
	GoogleSQLParserRULE_recursion_depth_modifier = 24
	GoogleSQLParserRULE_possibly_unbounded_int_literal_or_parameter = 25
	GoogleSQLParserRULE_int_literal_or_parameter = 26
	GoogleSQLParserRULE_limit_clause = 27
	GoogleSQLParserRULE_order_by_clause = 28
	GoogleSQLParserRULE_order_by_clause_prefix = 29
	GoogleSQLParserRULE_ordering_expression = 30
	GoogleSQLParserRULE_order_by_expr_list = 31
	GoogleSQLParserRULE_order_by_expr_list_item = 32
	GoogleSQLParserRULE_set_operator = 33
	GoogleSQLParserRULE_select = 34
	GoogleSQLParserRULE_opt_clauses_following_from = 35
	GoogleSQLParserRULE_opt_clauses_following_where = 36
	GoogleSQLParserRULE_opt_clauses_following_group_by = 37
	GoogleSQLParserRULE_window_clause = 38
	GoogleSQLParserRULE_window_clause_prefix = 39
	GoogleSQLParserRULE_window_definition = 40
	GoogleSQLParserRULE_where_clause = 41
	GoogleSQLParserRULE_having_clause = 42
	GoogleSQLParserRULE_group_by_clause = 43
	GoogleSQLParserRULE_group_by_all = 44
	GoogleSQLParserRULE_select_clause = 45
	GoogleSQLParserRULE_opt_select_as_clause = 46
	GoogleSQLParserRULE_opt_select_with = 47
	GoogleSQLParserRULE_from_clause = 48
	GoogleSQLParserRULE_from_clause_contents = 49
	GoogleSQLParserRULE_table_primary = 50
	GoogleSQLParserRULE_tvf_with_suffixes = 51
	GoogleSQLParserRULE_pivot_or_unpivot_clause_and_aliases = 52
	GoogleSQLParserRULE_sample_clause = 53
	GoogleSQLParserRULE_opt_sample_clause_suffix = 54
	GoogleSQLParserRULE_repeatable_clause = 55
	GoogleSQLParserRULE_possibly_cast_int_literal_or_parameter = 56
	GoogleSQLParserRULE_cast_int_literal_or_parameter = 57
	GoogleSQLParserRULE_sample_size = 58
	GoogleSQLParserRULE_sample_size_value = 59
	GoogleSQLParserRULE_sample_size_unit = 60
	GoogleSQLParserRULE_partition_by_clause_prefix_no_hint = 61
	GoogleSQLParserRULE_match_recognize_clause = 62
	GoogleSQLParserRULE_row_pattern_expr = 63
	GoogleSQLParserRULE_row_pattern_concatenation = 64
	GoogleSQLParserRULE_row_pattern_factor = 65
	GoogleSQLParserRULE_select_list_prefix_with_as_aliases = 66
	GoogleSQLParserRULE_select_column_expr_with_as_alias = 67
	GoogleSQLParserRULE_table_subquery = 68
	GoogleSQLParserRULE_join = 69
	GoogleSQLParserRULE_join_item = 70
	GoogleSQLParserRULE_on_or_using_clause_list = 71
	GoogleSQLParserRULE_on_or_using_clause = 72
	GoogleSQLParserRULE_join_hint = 73
	GoogleSQLParserRULE_table_path_expression = 74
	GoogleSQLParserRULE_opt_at_system_time = 75
	GoogleSQLParserRULE_opt_with_offset_and_alias = 76
	GoogleSQLParserRULE_opt_pivot_or_unpivot_clause_and_alias = 77
	GoogleSQLParserRULE_table_path_expression_base = 78
	GoogleSQLParserRULE_maybe_slashed_or_dashed_path_expression = 79
	GoogleSQLParserRULE_maybe_dashed_path_expression = 80
	GoogleSQLParserRULE_dashed_path_expression = 81
	GoogleSQLParserRULE_dashed_identifier = 82
	GoogleSQLParserRULE_slashed_identifier = 83
	GoogleSQLParserRULE_identifier_or_integer = 84
	GoogleSQLParserRULE_slashed_identifier_separator = 85
	GoogleSQLParserRULE_slashed_path_expression = 86
	GoogleSQLParserRULE_unnest_expression = 87
	GoogleSQLParserRULE_unnest_expression_prefix = 88
	GoogleSQLParserRULE_opt_array_zip_mode = 89
	GoogleSQLParserRULE_expression_with_opt_alias = 90
	GoogleSQLParserRULE_tvf_prefix = 91
	GoogleSQLParserRULE_tvf_argument = 92
	GoogleSQLParserRULE_connection_clause = 93
	GoogleSQLParserRULE_path_expression_or_default = 94
	GoogleSQLParserRULE_descriptor_argument = 95
	GoogleSQLParserRULE_descriptor_column_list = 96
	GoogleSQLParserRULE_descriptor_column = 97
	GoogleSQLParserRULE_table_clause = 98
	GoogleSQLParserRULE_model_clause = 99
	GoogleSQLParserRULE_qualify_clause_nonreserved = 100
	GoogleSQLParserRULE_unpivot_clause = 101
	GoogleSQLParserRULE_unpivot_in_item_list = 102
	GoogleSQLParserRULE_unpivot_in_item_list_prefix = 103
	GoogleSQLParserRULE_unpivot_in_item = 104
	GoogleSQLParserRULE_opt_as_string_or_integer = 105
	GoogleSQLParserRULE_path_expression_list_with_opt_parens = 106
	GoogleSQLParserRULE_path_expression_list = 107
	GoogleSQLParserRULE_unpivot_nulls_filter = 108
	GoogleSQLParserRULE_pivot_clause = 109
	GoogleSQLParserRULE_pivot_expression_list = 110
	GoogleSQLParserRULE_pivot_expression = 111
	GoogleSQLParserRULE_pivot_value_list = 112
	GoogleSQLParserRULE_pivot_value = 113
	GoogleSQLParserRULE_tvf_prefix_no_args = 114
	GoogleSQLParserRULE_join_type = 115
	GoogleSQLParserRULE_opt_natural = 116
	GoogleSQLParserRULE_tablesample_operator = 117
	GoogleSQLParserRULE_unpivot_operator = 118
	GoogleSQLParserRULE_single_column_unpivot = 119
	GoogleSQLParserRULE_multi_column_unpivot = 120
	GoogleSQLParserRULE_values_column_set = 121
	GoogleSQLParserRULE_columns_to_unpivot_list = 122
	GoogleSQLParserRULE_columns_to_unpivot_item = 123
	GoogleSQLParserRULE_column_sets_to_unpivot = 124
	GoogleSQLParserRULE_pivot_operator = 125
	GoogleSQLParserRULE_pivot_column_as_alias_list = 126
	GoogleSQLParserRULE_pivot_column_as_alias_list_item = 127
	GoogleSQLParserRULE_aggregate_function_call_as_alias_list = 128
	GoogleSQLParserRULE_aggregate_function_call_as_alias_list_item = 129
	GoogleSQLParserRULE_from_item = 130
	GoogleSQLParserRULE_unnest_operator = 131
	GoogleSQLParserRULE_cross_join_operator = 132
	GoogleSQLParserRULE_conditional_join_operator = 133
	GoogleSQLParserRULE_join_condition = 134
	GoogleSQLParserRULE_on_clause = 135
	GoogleSQLParserRULE_using_clause = 136
	GoogleSQLParserRULE_select_list = 137
	GoogleSQLParserRULE_select_list_item = 138
	GoogleSQLParserRULE_select_expression = 139
	GoogleSQLParserRULE_select_all = 140
	GoogleSQLParserRULE_select_all_except_clause = 141
	GoogleSQLParserRULE_select_all_replace_clause = 142
	GoogleSQLParserRULE_column_name_list = 143
	GoogleSQLParserRULE_expr_as_alias_list = 144
	GoogleSQLParserRULE_expr_as_alias_item = 145
	GoogleSQLParserRULE_as_alias = 146
	GoogleSQLParserRULE_differential_privacy_clause = 147
	GoogleSQLParserRULE_privacy_parameters = 148
	GoogleSQLParserRULE_with_statement = 149
	GoogleSQLParserRULE_cte = 150
	GoogleSQLParserRULE_non_recursive_cte = 151
	GoogleSQLParserRULE_recursive_cte = 152
	GoogleSQLParserRULE_recursive_union_operation = 153
	GoogleSQLParserRULE_base_term = 154
	GoogleSQLParserRULE_union_operator = 155
	GoogleSQLParserRULE_recursive_term = 156
	GoogleSQLParserRULE_expression = 157
	GoogleSQLParserRULE_expression_higher_prec_than_and = 158
	GoogleSQLParserRULE_parenthesized_query = 159
	GoogleSQLParserRULE_parenthesized_expression_not_a_query = 160
	GoogleSQLParserRULE_expression_maybe_parenthesized_not_a_query = 161
	GoogleSQLParserRULE_and_expression = 162
	GoogleSQLParserRULE_unparenthesized_expression_higher_prec_than_and = 163
	GoogleSQLParserRULE_parenthesized_anysomeall_list_in_rhs = 164
	GoogleSQLParserRULE_in_list_two_or_more_prefix = 165
	GoogleSQLParserRULE_any_some_all = 166
	GoogleSQLParserRULE_like_operator = 167
	GoogleSQLParserRULE_expression_subquery_with_keyword = 168
	GoogleSQLParserRULE_struct_constructor = 169
	GoogleSQLParserRULE_struct_constructor_prefix_with_keyword = 170
	GoogleSQLParserRULE_struct_constructor_arg = 171
	GoogleSQLParserRULE_struct_constructor_prefix_without_keyword = 172
	GoogleSQLParserRULE_struct_constructor_prefix_with_keyword_no_arg = 173
	GoogleSQLParserRULE_interval_expression = 174
	GoogleSQLParserRULE_function_call_expression_with_clauses = 175
	GoogleSQLParserRULE_function_call_expression = 176
	GoogleSQLParserRULE_over_clause = 177
	GoogleSQLParserRULE_window_specification = 178
	GoogleSQLParserRULE_opt_window_frame_clause = 179
	GoogleSQLParserRULE_window_frame_bound = 180
	GoogleSQLParserRULE_preceding_or_following = 181
	GoogleSQLParserRULE_frame_unit = 182
	GoogleSQLParserRULE_partition_by_clause = 183
	GoogleSQLParserRULE_partition_by_clause_prefix = 184
	GoogleSQLParserRULE_with_group_rows = 185
	GoogleSQLParserRULE_with_report_modifier = 186
	GoogleSQLParserRULE_clamped_between_modifier = 187
	GoogleSQLParserRULE_with_report_format = 188
	GoogleSQLParserRULE_options_list = 189
	GoogleSQLParserRULE_options_list_prefix = 190
	GoogleSQLParserRULE_options_entry = 191
	GoogleSQLParserRULE_expression_or_proto = 192
	GoogleSQLParserRULE_options_assignment_operator = 193
	GoogleSQLParserRULE_opt_null_handling_modifier = 194
	GoogleSQLParserRULE_function_call_expression_with_args_prefix = 195
	GoogleSQLParserRULE_function_call_argument = 196
	GoogleSQLParserRULE_sequence_arg = 197
	GoogleSQLParserRULE_named_argument = 198
	GoogleSQLParserRULE_lambda_argument = 199
	GoogleSQLParserRULE_lambda_argument_list = 200
	GoogleSQLParserRULE_limit_offset_clause = 201
	GoogleSQLParserRULE_opt_having_or_group_by_modifier = 202
	GoogleSQLParserRULE_group_by_clause_prefix = 203
	GoogleSQLParserRULE_group_by_preamble = 204
	GoogleSQLParserRULE_opt_and_order = 205
	GoogleSQLParserRULE_hint = 206
	GoogleSQLParserRULE_hint_with_body = 207
	GoogleSQLParserRULE_hint_with_body_prefix = 208
	GoogleSQLParserRULE_hint_entry = 209
	GoogleSQLParserRULE_identifier_in_hints = 210
	GoogleSQLParserRULE_extra_identifier_in_hints_name = 211
	GoogleSQLParserRULE_grouping_item = 212
	GoogleSQLParserRULE_grouping_set_list = 213
	GoogleSQLParserRULE_grouping_set = 214
	GoogleSQLParserRULE_cube_list = 215
	GoogleSQLParserRULE_rollup_list = 216
	GoogleSQLParserRULE_opt_as_alias_with_required_as = 217
	GoogleSQLParserRULE_opt_grouping_item_order = 218
	GoogleSQLParserRULE_opt_selection_item_order = 219
	GoogleSQLParserRULE_asc_or_desc = 220
	GoogleSQLParserRULE_null_order = 221
	GoogleSQLParserRULE_function_call_expression_base = 222
	GoogleSQLParserRULE_function_name_from_keyword = 223
	GoogleSQLParserRULE_replace_fields_expression = 224
	GoogleSQLParserRULE_replace_fields_prefix = 225
	GoogleSQLParserRULE_replace_fields_arg = 226
	GoogleSQLParserRULE_generalized_path_expression = 227
	GoogleSQLParserRULE_generalized_extension_path = 228
	GoogleSQLParserRULE_with_expression = 229
	GoogleSQLParserRULE_with_expression_variable_prefix = 230
	GoogleSQLParserRULE_with_expression_variable = 231
	GoogleSQLParserRULE_extract_expression = 232
	GoogleSQLParserRULE_extract_expression_base = 233
	GoogleSQLParserRULE_opt_format = 234
	GoogleSQLParserRULE_opt_at_time_zone = 235
	GoogleSQLParserRULE_cast_expression = 236
	GoogleSQLParserRULE_case_expression = 237
	GoogleSQLParserRULE_case_expression_prefix = 238
	GoogleSQLParserRULE_case_value_expression_prefix = 239
	GoogleSQLParserRULE_case_no_value_expression_prefix = 240
	GoogleSQLParserRULE_struct_braced_constructor = 241
	GoogleSQLParserRULE_braced_new_constructor = 242
	GoogleSQLParserRULE_braced_constructor = 243
	GoogleSQLParserRULE_braced_constructor_start = 244
	GoogleSQLParserRULE_braced_constructor_prefix = 245
	GoogleSQLParserRULE_braced_constructor_field = 246
	GoogleSQLParserRULE_braced_constructor_lhs = 247
	GoogleSQLParserRULE_braced_constructor_field_value = 248
	GoogleSQLParserRULE_braced_constructor_extension = 249
	GoogleSQLParserRULE_new_constructor = 250
	GoogleSQLParserRULE_new_constructor_prefix = 251
	GoogleSQLParserRULE_new_constructor_prefix_no_arg = 252
	GoogleSQLParserRULE_new_constructor_arg = 253
	GoogleSQLParserRULE_array_constructor = 254
	GoogleSQLParserRULE_array_constructor_prefix = 255
	GoogleSQLParserRULE_array_constructor_prefix_no_expressions = 256
	GoogleSQLParserRULE_range_literal = 257
	GoogleSQLParserRULE_range_type = 258
	GoogleSQLParserRULE_type = 259
	GoogleSQLParserRULE_collate_clause = 260
	GoogleSQLParserRULE_string_literal_or_parameter = 261
	GoogleSQLParserRULE_system_variable_expression = 262
	GoogleSQLParserRULE_parameter_expression = 263
	GoogleSQLParserRULE_named_parameter_expression = 264
	GoogleSQLParserRULE_opt_type_parameters = 265
	GoogleSQLParserRULE_type_parameters_prefix = 266
	GoogleSQLParserRULE_type_parameter = 267
	GoogleSQLParserRULE_raw_type = 268
	GoogleSQLParserRULE_map_type = 269
	GoogleSQLParserRULE_function_type = 270
	GoogleSQLParserRULE_function_type_prefix = 271
	GoogleSQLParserRULE_type_name = 272
	GoogleSQLParserRULE_path_expression = 273
	GoogleSQLParserRULE_identifier = 274
	GoogleSQLParserRULE_keyword_as_identifier = 275
	GoogleSQLParserRULE_common_keyword_as_identifier = 276
	GoogleSQLParserRULE_token_identifier = 277
	GoogleSQLParserRULE_struct_type = 278
	GoogleSQLParserRULE_array_type = 279
	GoogleSQLParserRULE_template_type_open = 280
	GoogleSQLParserRULE_template_type_close = 281
	GoogleSQLParserRULE_date_or_time_literal = 282
	GoogleSQLParserRULE_date_or_time_literal_kind = 283
	GoogleSQLParserRULE_floating_point_literal = 284
	GoogleSQLParserRULE_json_literal = 285
	GoogleSQLParserRULE_bignumeric_literal = 286
	GoogleSQLParserRULE_bignumeric_literal_prefix = 287
	GoogleSQLParserRULE_numeric_literal = 288
	GoogleSQLParserRULE_numeric_literal_prefix = 289
	GoogleSQLParserRULE_integer_literal = 290
	GoogleSQLParserRULE_bytes_literal = 291
	GoogleSQLParserRULE_null_literal = 292
	GoogleSQLParserRULE_boolean_literal = 293
	GoogleSQLParserRULE_string_literal = 294
	GoogleSQLParserRULE_string_literal_component = 295
	GoogleSQLParserRULE_bytes_literal_component = 296
	GoogleSQLParserRULE_count = 297
	GoogleSQLParserRULE_skip_rows = 298
	GoogleSQLParserRULE_name = 299
	GoogleSQLParserRULE_cte_name = 300
	GoogleSQLParserRULE_column_name = 301
	GoogleSQLParserRULE_alias_name = 302
	GoogleSQLParserRULE_table_name = 303
	GoogleSQLParserRULE_number = 304
	GoogleSQLParserRULE_integer_type = 305
	GoogleSQLParserRULE_float_type = 306
)

// IRootContext is an interface to support dynamic dispatch.
type IRootContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Stmts() IStmtsContext
	EOF() antlr.TerminalNode

	// IsRootContext differentiates from other interfaces.
	IsRootContext()
}

type RootContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootContext() *RootContext {
	var p = new(RootContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_root
	return p
}

func InitEmptyRootContext(p *RootContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_root
}

func (*RootContext) IsRootContext() {}

func NewRootContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootContext {
	var p = new(RootContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_root

	return p
}

func (s *RootContext) GetParser() antlr.Parser { return s.parser }

func (s *RootContext) Stmts() IStmtsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtsContext)
}

func (s *RootContext) EOF() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEOF, 0)
}

func (s *RootContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RootContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterRoot(s)
	}
}

func (s *RootContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitRoot(s)
	}
}

func (s *RootContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitRoot(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Root() (localctx IRootContext) {
	localctx = NewRootContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, GoogleSQLParserRULE_root)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(614)
		p.Stmts()
	}
	{
		p.SetState(615)
		p.Match(GoogleSQLParserEOF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStmtsContext is an interface to support dynamic dispatch.
type IStmtsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext
	AllSEMI_SYMBOL() []antlr.TerminalNode
	SEMI_SYMBOL(i int) antlr.TerminalNode

	// IsStmtsContext differentiates from other interfaces.
	IsStmtsContext()
}

type StmtsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtsContext() *StmtsContext {
	var p = new(StmtsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_stmts
	return p
}

func InitEmptyStmtsContext(p *StmtsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_stmts
}

func (*StmtsContext) IsStmtsContext() {}

func NewStmtsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtsContext {
	var p = new(StmtsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_stmts

	return p
}

func (s *StmtsContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtsContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *StmtsContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *StmtsContext) AllSEMI_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserSEMI_SYMBOL)
}

func (s *StmtsContext) SEMI_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSEMI_SYMBOL, i)
}

func (s *StmtsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StmtsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterStmts(s)
	}
}

func (s *StmtsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitStmts(s)
	}
}

func (s *StmtsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitStmts(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Stmts() (localctx IStmtsContext) {
	localctx = NewStmtsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, GoogleSQLParserRULE_stmts)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(617)
		p.Stmt()
	}
	p.SetState(622)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(618)
				p.Match(GoogleSQLParserSEMI_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(619)
				p.Stmt()
			}


		}
		p.SetState(624)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserSEMI_SYMBOL {
		{
			p.SetState(625)
			p.Match(GoogleSQLParserSEMI_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Query_statement() IQuery_statementContext

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_stmt
	return p
}

func InitEmptyStmtContext(p *StmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_stmt
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) Query_statement() IQuery_statementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_statementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_statementContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterStmt(s)
	}
}

func (s *StmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitStmt(s)
	}
}

func (s *StmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, GoogleSQLParserRULE_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(628)
		p.Query_statement()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQuery_statementContext is an interface to support dynamic dispatch.
type IQuery_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Query() IQueryContext

	// IsQuery_statementContext differentiates from other interfaces.
	IsQuery_statementContext()
}

type Query_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_statementContext() *Query_statementContext {
	var p = new(Query_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_query_statement
	return p
}

func InitEmptyQuery_statementContext(p *Query_statementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_query_statement
}

func (*Query_statementContext) IsQuery_statementContext() {}

func NewQuery_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_statementContext {
	var p = new(Query_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_query_statement

	return p
}

func (s *Query_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_statementContext) Query() IQueryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *Query_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Query_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterQuery_statement(s)
	}
}

func (s *Query_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitQuery_statement(s)
	}
}

func (s *Query_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitQuery_statement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Query_statement() (localctx IQuery_statementContext) {
	localctx = NewQuery_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, GoogleSQLParserRULE_query_statement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(630)
		p.Query()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Query_without_pipe_operators() IQuery_without_pipe_operatorsContext

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_query
	return p
}

func InitEmptyQueryContext(p *QueryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_query
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) Query_without_pipe_operators() IQuery_without_pipe_operatorsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_without_pipe_operatorsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_without_pipe_operatorsContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (s *QueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitQuery(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, GoogleSQLParserRULE_query)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(632)
		p.Query_without_pipe_operators()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQuery_without_pipe_operatorsContext is an interface to support dynamic dispatch.
type IQuery_without_pipe_operatorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	With_clause() IWith_clauseContext
	Query_primary_or_set_operation() IQuery_primary_or_set_operationContext
	Order_by_clause() IOrder_by_clauseContext
	Limit_offset_clause() ILimit_offset_clauseContext
	With_clause_with_trailing_comma() IWith_clause_with_trailing_commaContext
	Select_or_from_keyword() ISelect_or_from_keywordContext
	PIPE_SYMBOL() antlr.TerminalNode
	From_clause() IFrom_clauseContext
	Bad_keyword_after_from_query() IBad_keyword_after_from_queryContext
	Bad_keyword_after_from_query_allows_parens() IBad_keyword_after_from_query_allows_parensContext

	// IsQuery_without_pipe_operatorsContext differentiates from other interfaces.
	IsQuery_without_pipe_operatorsContext()
}

type Query_without_pipe_operatorsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_without_pipe_operatorsContext() *Query_without_pipe_operatorsContext {
	var p = new(Query_without_pipe_operatorsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_query_without_pipe_operators
	return p
}

func InitEmptyQuery_without_pipe_operatorsContext(p *Query_without_pipe_operatorsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_query_without_pipe_operators
}

func (*Query_without_pipe_operatorsContext) IsQuery_without_pipe_operatorsContext() {}

func NewQuery_without_pipe_operatorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_without_pipe_operatorsContext {
	var p = new(Query_without_pipe_operatorsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_query_without_pipe_operators

	return p
}

func (s *Query_without_pipe_operatorsContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_without_pipe_operatorsContext) With_clause() IWith_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_clauseContext)
}

func (s *Query_without_pipe_operatorsContext) Query_primary_or_set_operation() IQuery_primary_or_set_operationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_primary_or_set_operationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_primary_or_set_operationContext)
}

func (s *Query_without_pipe_operatorsContext) Order_by_clause() IOrder_by_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Query_without_pipe_operatorsContext) Limit_offset_clause() ILimit_offset_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimit_offset_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimit_offset_clauseContext)
}

func (s *Query_without_pipe_operatorsContext) With_clause_with_trailing_comma() IWith_clause_with_trailing_commaContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_clause_with_trailing_commaContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_clause_with_trailing_commaContext)
}

func (s *Query_without_pipe_operatorsContext) Select_or_from_keyword() ISelect_or_from_keywordContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_or_from_keywordContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_or_from_keywordContext)
}

func (s *Query_without_pipe_operatorsContext) PIPE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPIPE_SYMBOL, 0)
}

func (s *Query_without_pipe_operatorsContext) From_clause() IFrom_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_clauseContext)
}

func (s *Query_without_pipe_operatorsContext) Bad_keyword_after_from_query() IBad_keyword_after_from_queryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBad_keyword_after_from_queryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBad_keyword_after_from_queryContext)
}

func (s *Query_without_pipe_operatorsContext) Bad_keyword_after_from_query_allows_parens() IBad_keyword_after_from_query_allows_parensContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBad_keyword_after_from_query_allows_parensContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBad_keyword_after_from_query_allows_parensContext)
}

func (s *Query_without_pipe_operatorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_without_pipe_operatorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Query_without_pipe_operatorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterQuery_without_pipe_operators(s)
	}
}

func (s *Query_without_pipe_operatorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitQuery_without_pipe_operators(s)
	}
}

func (s *Query_without_pipe_operatorsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitQuery_without_pipe_operators(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Query_without_pipe_operators() (localctx IQuery_without_pipe_operatorsContext) {
	localctx = NewQuery_without_pipe_operatorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, GoogleSQLParserRULE_query_without_pipe_operators)
	var _la int

	p.SetState(675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(634)
			p.with_clause(0)
		}
		{
			p.SetState(635)
			p.Query_primary_or_set_operation()
		}
		p.SetState(637)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserORDER_SYMBOL {
			{
				p.SetState(636)
				p.Order_by_clause()
			}

		}
		p.SetState(640)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserLIMIT_SYMBOL {
			{
				p.SetState(639)
				p.Limit_offset_clause()
			}

		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(642)
			p.With_clause_with_trailing_comma()
		}
		{
			p.SetState(643)
			p.Select_or_from_keyword()
		}
		p.NotifyErrorListeners("Syntax error: Trailing comma after the WITH " "clause before the main query is not allowed", nil, nil)
				


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(646)
			p.with_clause(0)
		}
		{
			p.SetState(647)
			p.Match(GoogleSQLParserPIPE_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.NotifyErrorListeners("Syntax error: A pipe operator cannot follow "
		                               "the WITH clause before the main query; The "
		                               "main query usually starts with SELECT or "
		                               "FROM here", nil, nil)


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(650)
			p.Query_primary_or_set_operation()
		}
		p.SetState(652)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserORDER_SYMBOL {
			{
				p.SetState(651)
				p.Order_by_clause()
			}

		}
		p.SetState(655)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserLIMIT_SYMBOL {
			{
				p.SetState(654)
				p.Limit_offset_clause()
			}

		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(658)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserWITH_SYMBOL {
			{
				p.SetState(657)
				p.with_clause(0)
			}

		}
		{
			p.SetState(660)
			p.From_clause()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(662)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserWITH_SYMBOL {
			{
				p.SetState(661)
				p.with_clause(0)
			}

		}
		{
			p.SetState(664)
			p.From_clause()
		}
		{
			p.SetState(665)
			p.Bad_keyword_after_from_query()
		}
		p.NotifyErrorListeners("Syntax error: ", "<KEYWORD>", " not supported after FROM query; "
		            "Consider using pipe operator `|>` ", nil, nil)


	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(669)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserWITH_SYMBOL {
			{
				p.SetState(668)
				p.with_clause(0)
			}

		}
		{
			p.SetState(671)
			p.From_clause()
		}
		{
			p.SetState(672)
			p.Bad_keyword_after_from_query_allows_parens()
		}
		p.NotifyErrorListeners("Syntax error: ", "<KEYWORD>", " not supported after FROM query; "
		            "Consider using pipe operator `|>` ", nil, nil)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBad_keyword_after_from_queryContext is an interface to support dynamic dispatch.
type IBad_keyword_after_from_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE_SYMBOL() antlr.TerminalNode
	SELECT_SYMBOL() antlr.TerminalNode
	GROUP_SYMBOL() antlr.TerminalNode

	// IsBad_keyword_after_from_queryContext differentiates from other interfaces.
	IsBad_keyword_after_from_queryContext()
}

type Bad_keyword_after_from_queryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBad_keyword_after_from_queryContext() *Bad_keyword_after_from_queryContext {
	var p = new(Bad_keyword_after_from_queryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_bad_keyword_after_from_query
	return p
}

func InitEmptyBad_keyword_after_from_queryContext(p *Bad_keyword_after_from_queryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_bad_keyword_after_from_query
}

func (*Bad_keyword_after_from_queryContext) IsBad_keyword_after_from_queryContext() {}

func NewBad_keyword_after_from_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bad_keyword_after_from_queryContext {
	var p = new(Bad_keyword_after_from_queryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_bad_keyword_after_from_query

	return p
}

func (s *Bad_keyword_after_from_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Bad_keyword_after_from_queryContext) WHERE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWHERE_SYMBOL, 0)
}

func (s *Bad_keyword_after_from_queryContext) SELECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSELECT_SYMBOL, 0)
}

func (s *Bad_keyword_after_from_queryContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserGROUP_SYMBOL, 0)
}

func (s *Bad_keyword_after_from_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bad_keyword_after_from_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bad_keyword_after_from_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterBad_keyword_after_from_query(s)
	}
}

func (s *Bad_keyword_after_from_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitBad_keyword_after_from_query(s)
	}
}

func (s *Bad_keyword_after_from_queryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitBad_keyword_after_from_query(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Bad_keyword_after_from_query() (localctx IBad_keyword_after_from_queryContext) {
	localctx = NewBad_keyword_after_from_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, GoogleSQLParserRULE_bad_keyword_after_from_query)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(677)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GoogleSQLParserSELECT_SYMBOL || _la == GoogleSQLParserGROUP_SYMBOL || _la == GoogleSQLParserWHERE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBad_keyword_after_from_query_allows_parensContext is an interface to support dynamic dispatch.
type IBad_keyword_after_from_query_allows_parensContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER_SYMBOL() antlr.TerminalNode
	UNION_SYMBOL() antlr.TerminalNode
	INTERSECT_SYMBOL() antlr.TerminalNode
	EXCEPT_SYMBOL() antlr.TerminalNode
	LIMIT_SYMBOL() antlr.TerminalNode

	// IsBad_keyword_after_from_query_allows_parensContext differentiates from other interfaces.
	IsBad_keyword_after_from_query_allows_parensContext()
}

type Bad_keyword_after_from_query_allows_parensContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBad_keyword_after_from_query_allows_parensContext() *Bad_keyword_after_from_query_allows_parensContext {
	var p = new(Bad_keyword_after_from_query_allows_parensContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_bad_keyword_after_from_query_allows_parens
	return p
}

func InitEmptyBad_keyword_after_from_query_allows_parensContext(p *Bad_keyword_after_from_query_allows_parensContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_bad_keyword_after_from_query_allows_parens
}

func (*Bad_keyword_after_from_query_allows_parensContext) IsBad_keyword_after_from_query_allows_parensContext() {}

func NewBad_keyword_after_from_query_allows_parensContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bad_keyword_after_from_query_allows_parensContext {
	var p = new(Bad_keyword_after_from_query_allows_parensContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_bad_keyword_after_from_query_allows_parens

	return p
}

func (s *Bad_keyword_after_from_query_allows_parensContext) GetParser() antlr.Parser { return s.parser }

func (s *Bad_keyword_after_from_query_allows_parensContext) ORDER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserORDER_SYMBOL, 0)
}

func (s *Bad_keyword_after_from_query_allows_parensContext) UNION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserUNION_SYMBOL, 0)
}

func (s *Bad_keyword_after_from_query_allows_parensContext) INTERSECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINTERSECT_SYMBOL, 0)
}

func (s *Bad_keyword_after_from_query_allows_parensContext) EXCEPT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEXCEPT_SYMBOL, 0)
}

func (s *Bad_keyword_after_from_query_allows_parensContext) LIMIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLIMIT_SYMBOL, 0)
}

func (s *Bad_keyword_after_from_query_allows_parensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bad_keyword_after_from_query_allows_parensContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bad_keyword_after_from_query_allows_parensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterBad_keyword_after_from_query_allows_parens(s)
	}
}

func (s *Bad_keyword_after_from_query_allows_parensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitBad_keyword_after_from_query_allows_parens(s)
	}
}

func (s *Bad_keyword_after_from_query_allows_parensContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitBad_keyword_after_from_query_allows_parens(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Bad_keyword_after_from_query_allows_parens() (localctx IBad_keyword_after_from_query_allows_parensContext) {
	localctx = NewBad_keyword_after_from_query_allows_parensContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, GoogleSQLParserRULE_bad_keyword_after_from_query_allows_parens)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(679)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 35186530066432) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWith_clause_with_trailing_commaContext is an interface to support dynamic dispatch.
type IWith_clause_with_trailing_commaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	With_clause() IWith_clauseContext
	COMMA_SYMBOL() antlr.TerminalNode

	// IsWith_clause_with_trailing_commaContext differentiates from other interfaces.
	IsWith_clause_with_trailing_commaContext()
}

type With_clause_with_trailing_commaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_clause_with_trailing_commaContext() *With_clause_with_trailing_commaContext {
	var p = new(With_clause_with_trailing_commaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_with_clause_with_trailing_comma
	return p
}

func InitEmptyWith_clause_with_trailing_commaContext(p *With_clause_with_trailing_commaContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_with_clause_with_trailing_comma
}

func (*With_clause_with_trailing_commaContext) IsWith_clause_with_trailing_commaContext() {}

func NewWith_clause_with_trailing_commaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_clause_with_trailing_commaContext {
	var p = new(With_clause_with_trailing_commaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_with_clause_with_trailing_comma

	return p
}

func (s *With_clause_with_trailing_commaContext) GetParser() antlr.Parser { return s.parser }

func (s *With_clause_with_trailing_commaContext) With_clause() IWith_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_clauseContext)
}

func (s *With_clause_with_trailing_commaContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, 0)
}

func (s *With_clause_with_trailing_commaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_clause_with_trailing_commaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *With_clause_with_trailing_commaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterWith_clause_with_trailing_comma(s)
	}
}

func (s *With_clause_with_trailing_commaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitWith_clause_with_trailing_comma(s)
	}
}

func (s *With_clause_with_trailing_commaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitWith_clause_with_trailing_comma(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) With_clause_with_trailing_comma() (localctx IWith_clause_with_trailing_commaContext) {
	localctx = NewWith_clause_with_trailing_commaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, GoogleSQLParserRULE_with_clause_with_trailing_comma)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(681)
		p.with_clause(0)
	}
	{
		p.SetState(682)
		p.Match(GoogleSQLParserCOMMA_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_or_from_keywordContext is an interface to support dynamic dispatch.
type ISelect_or_from_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT_SYMBOL() antlr.TerminalNode
	FROM_SYMBOL() antlr.TerminalNode

	// IsSelect_or_from_keywordContext differentiates from other interfaces.
	IsSelect_or_from_keywordContext()
}

type Select_or_from_keywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_or_from_keywordContext() *Select_or_from_keywordContext {
	var p = new(Select_or_from_keywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select_or_from_keyword
	return p
}

func InitEmptySelect_or_from_keywordContext(p *Select_or_from_keywordContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select_or_from_keyword
}

func (*Select_or_from_keywordContext) IsSelect_or_from_keywordContext() {}

func NewSelect_or_from_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_or_from_keywordContext {
	var p = new(Select_or_from_keywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_select_or_from_keyword

	return p
}

func (s *Select_or_from_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_or_from_keywordContext) SELECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSELECT_SYMBOL, 0)
}

func (s *Select_or_from_keywordContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFROM_SYMBOL, 0)
}

func (s *Select_or_from_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_or_from_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_or_from_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSelect_or_from_keyword(s)
	}
}

func (s *Select_or_from_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSelect_or_from_keyword(s)
	}
}

func (s *Select_or_from_keywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSelect_or_from_keyword(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Select_or_from_keyword() (localctx ISelect_or_from_keywordContext) {
	localctx = NewSelect_or_from_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, GoogleSQLParserRULE_select_or_from_keyword)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(684)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GoogleSQLParserFROM_SYMBOL || _la == GoogleSQLParserSELECT_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQuery_primary_or_set_operationContext is an interface to support dynamic dispatch.
type IQuery_primary_or_set_operationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Query_primary() IQuery_primaryContext
	Query_set_operation() IQuery_set_operationContext

	// IsQuery_primary_or_set_operationContext differentiates from other interfaces.
	IsQuery_primary_or_set_operationContext()
}

type Query_primary_or_set_operationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_primary_or_set_operationContext() *Query_primary_or_set_operationContext {
	var p = new(Query_primary_or_set_operationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_query_primary_or_set_operation
	return p
}

func InitEmptyQuery_primary_or_set_operationContext(p *Query_primary_or_set_operationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_query_primary_or_set_operation
}

func (*Query_primary_or_set_operationContext) IsQuery_primary_or_set_operationContext() {}

func NewQuery_primary_or_set_operationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_primary_or_set_operationContext {
	var p = new(Query_primary_or_set_operationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_query_primary_or_set_operation

	return p
}

func (s *Query_primary_or_set_operationContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_primary_or_set_operationContext) Query_primary() IQuery_primaryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_primaryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_primaryContext)
}

func (s *Query_primary_or_set_operationContext) Query_set_operation() IQuery_set_operationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_set_operationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_set_operationContext)
}

func (s *Query_primary_or_set_operationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_primary_or_set_operationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Query_primary_or_set_operationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterQuery_primary_or_set_operation(s)
	}
}

func (s *Query_primary_or_set_operationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitQuery_primary_or_set_operation(s)
	}
}

func (s *Query_primary_or_set_operationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitQuery_primary_or_set_operation(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Query_primary_or_set_operation() (localctx IQuery_primary_or_set_operationContext) {
	localctx = NewQuery_primary_or_set_operationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, GoogleSQLParserRULE_query_primary_or_set_operation)
	p.SetState(688)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(686)
			p.Query_primary()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(687)
			p.Query_set_operation()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQuery_set_operationContext is an interface to support dynamic dispatch.
type IQuery_set_operationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Query_set_operation_prefix() IQuery_set_operation_prefixContext

	// IsQuery_set_operationContext differentiates from other interfaces.
	IsQuery_set_operationContext()
}

type Query_set_operationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_set_operationContext() *Query_set_operationContext {
	var p = new(Query_set_operationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_query_set_operation
	return p
}

func InitEmptyQuery_set_operationContext(p *Query_set_operationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_query_set_operation
}

func (*Query_set_operationContext) IsQuery_set_operationContext() {}

func NewQuery_set_operationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_set_operationContext {
	var p = new(Query_set_operationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_query_set_operation

	return p
}

func (s *Query_set_operationContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_set_operationContext) Query_set_operation_prefix() IQuery_set_operation_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_set_operation_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_set_operation_prefixContext)
}

func (s *Query_set_operationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_set_operationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Query_set_operationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterQuery_set_operation(s)
	}
}

func (s *Query_set_operationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitQuery_set_operation(s)
	}
}

func (s *Query_set_operationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitQuery_set_operation(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Query_set_operation() (localctx IQuery_set_operationContext) {
	localctx = NewQuery_set_operationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, GoogleSQLParserRULE_query_set_operation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(690)
		p.query_set_operation_prefix(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQuery_set_operation_prefixContext is an interface to support dynamic dispatch.
type IQuery_set_operation_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQuery_primary() []IQuery_primaryContext
	Query_primary(i int) IQuery_primaryContext
	Set_operation_metadata() ISet_operation_metadataContext
	FROM_SYMBOL() antlr.TerminalNode
	Query_set_operation_prefix() IQuery_set_operation_prefixContext

	// IsQuery_set_operation_prefixContext differentiates from other interfaces.
	IsQuery_set_operation_prefixContext()
}

type Query_set_operation_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_set_operation_prefixContext() *Query_set_operation_prefixContext {
	var p = new(Query_set_operation_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_query_set_operation_prefix
	return p
}

func InitEmptyQuery_set_operation_prefixContext(p *Query_set_operation_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_query_set_operation_prefix
}

func (*Query_set_operation_prefixContext) IsQuery_set_operation_prefixContext() {}

func NewQuery_set_operation_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_set_operation_prefixContext {
	var p = new(Query_set_operation_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_query_set_operation_prefix

	return p
}

func (s *Query_set_operation_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_set_operation_prefixContext) AllQuery_primary() []IQuery_primaryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQuery_primaryContext); ok {
			len++
		}
	}

	tst := make([]IQuery_primaryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQuery_primaryContext); ok {
			tst[i] = t.(IQuery_primaryContext)
			i++
		}
	}

	return tst
}

func (s *Query_set_operation_prefixContext) Query_primary(i int) IQuery_primaryContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_primaryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_primaryContext)
}

func (s *Query_set_operation_prefixContext) Set_operation_metadata() ISet_operation_metadataContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_operation_metadataContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_operation_metadataContext)
}

func (s *Query_set_operation_prefixContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFROM_SYMBOL, 0)
}

func (s *Query_set_operation_prefixContext) Query_set_operation_prefix() IQuery_set_operation_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_set_operation_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_set_operation_prefixContext)
}

func (s *Query_set_operation_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_set_operation_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Query_set_operation_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterQuery_set_operation_prefix(s)
	}
}

func (s *Query_set_operation_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitQuery_set_operation_prefix(s)
	}
}

func (s *Query_set_operation_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitQuery_set_operation_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}





func (p *GoogleSQLParser) Query_set_operation_prefix() (localctx IQuery_set_operation_prefixContext) {
	return p.query_set_operation_prefix(0)
}

func (p *GoogleSQLParser) query_set_operation_prefix(_p int) (localctx IQuery_set_operation_prefixContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewQuery_set_operation_prefixContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQuery_set_operation_prefixContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 24
	p.EnterRecursionRule(localctx, 24, GoogleSQLParserRULE_query_set_operation_prefix, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(702)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(693)
			p.Query_primary()
		}
		{
			p.SetState(694)
			p.Set_operation_metadata()
		}
		{
			p.SetState(695)
			p.Query_primary()
		}


	case 2:
		{
			p.SetState(697)
			p.Query_primary()
		}
		{
			p.SetState(698)
			p.Set_operation_metadata()
		}
		{
			p.SetState(699)
			p.Match(GoogleSQLParserFROM_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		 p.NotifyErrorListeners("Syntax error: Unexpected FROM;" "FROM queries following a set operation must be parenthesized", nil, nil); 
				

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(713)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) {
			case 1:
				localctx = NewQuery_set_operation_prefixContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_query_set_operation_prefix)
				p.SetState(704)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(705)
					p.Set_operation_metadata()
				}
				{
					p.SetState(706)
					p.Query_primary()
				}


			case 2:
				localctx = NewQuery_set_operation_prefixContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_query_set_operation_prefix)
				p.SetState(708)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(709)
					p.Set_operation_metadata()
				}
				{
					p.SetState(710)
					p.Match(GoogleSQLParserFROM_SYMBOL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				 p.NotifyErrorListeners("Syntax error: Unexpected FROM;" "FROM queries following a set operation must be parenthesized", nil, nil); 
				          		

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(717)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQuery_primaryContext is an interface to support dynamic dispatch.
type IQuery_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_() ISelectContext
	Parenthesized_query() IParenthesized_queryContext
	Opt_as_alias_with_required_as() IOpt_as_alias_with_required_asContext

	// IsQuery_primaryContext differentiates from other interfaces.
	IsQuery_primaryContext()
}

type Query_primaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_primaryContext() *Query_primaryContext {
	var p = new(Query_primaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_query_primary
	return p
}

func InitEmptyQuery_primaryContext(p *Query_primaryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_query_primary
}

func (*Query_primaryContext) IsQuery_primaryContext() {}

func NewQuery_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_primaryContext {
	var p = new(Query_primaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_query_primary

	return p
}

func (s *Query_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_primaryContext) Select_() ISelectContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectContext)
}

func (s *Query_primaryContext) Parenthesized_query() IParenthesized_queryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesized_queryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesized_queryContext)
}

func (s *Query_primaryContext) Opt_as_alias_with_required_as() IOpt_as_alias_with_required_asContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_as_alias_with_required_asContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_as_alias_with_required_asContext)
}

func (s *Query_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Query_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterQuery_primary(s)
	}
}

func (s *Query_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitQuery_primary(s)
	}
}

func (s *Query_primaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitQuery_primary(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Query_primary() (localctx IQuery_primaryContext) {
	localctx = NewQuery_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, GoogleSQLParserRULE_query_primary)
	p.SetState(722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserSELECT_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(718)
			p.Select_()
		}


	case GoogleSQLParserLR_BRACKET_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(719)
			p.Parenthesized_query()
		}
		{
			p.SetState(720)
			p.Opt_as_alias_with_required_as()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISet_operation_metadataContext is an interface to support dynamic dispatch.
type ISet_operation_metadataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Query_set_operation_type() IQuery_set_operation_typeContext
	All_or_distinct() IAll_or_distinctContext
	Opt_corresponding_outer_mode() IOpt_corresponding_outer_modeContext
	Hint() IHintContext
	Opt_strict() IOpt_strictContext
	Opt_column_match_suffix() IOpt_column_match_suffixContext

	// IsSet_operation_metadataContext differentiates from other interfaces.
	IsSet_operation_metadataContext()
}

type Set_operation_metadataContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_operation_metadataContext() *Set_operation_metadataContext {
	var p = new(Set_operation_metadataContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_set_operation_metadata
	return p
}

func InitEmptySet_operation_metadataContext(p *Set_operation_metadataContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_set_operation_metadata
}

func (*Set_operation_metadataContext) IsSet_operation_metadataContext() {}

func NewSet_operation_metadataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_operation_metadataContext {
	var p = new(Set_operation_metadataContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_set_operation_metadata

	return p
}

func (s *Set_operation_metadataContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_operation_metadataContext) Query_set_operation_type() IQuery_set_operation_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_set_operation_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_set_operation_typeContext)
}

func (s *Set_operation_metadataContext) All_or_distinct() IAll_or_distinctContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAll_or_distinctContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAll_or_distinctContext)
}

func (s *Set_operation_metadataContext) Opt_corresponding_outer_mode() IOpt_corresponding_outer_modeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_corresponding_outer_modeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_corresponding_outer_modeContext)
}

func (s *Set_operation_metadataContext) Hint() IHintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintContext)
}

func (s *Set_operation_metadataContext) Opt_strict() IOpt_strictContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_strictContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_strictContext)
}

func (s *Set_operation_metadataContext) Opt_column_match_suffix() IOpt_column_match_suffixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_column_match_suffixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_column_match_suffixContext)
}

func (s *Set_operation_metadataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_operation_metadataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Set_operation_metadataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSet_operation_metadata(s)
	}
}

func (s *Set_operation_metadataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSet_operation_metadata(s)
	}
}

func (s *Set_operation_metadataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSet_operation_metadata(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Set_operation_metadata() (localctx ISet_operation_metadataContext) {
	localctx = NewSet_operation_metadataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, GoogleSQLParserRULE_set_operation_metadata)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 4299292672) != 0) {
		{
			p.SetState(724)
			p.Opt_corresponding_outer_mode()
		}

	}
	{
		p.SetState(727)
		p.Query_set_operation_type()
	}
	p.SetState(729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserAT_SYMBOL {
		{
			p.SetState(728)
			p.Hint()
		}

	}
	{
		p.SetState(731)
		p.All_or_distinct()
	}
	p.SetState(733)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserSTRICT_SYMBOL {
		{
			p.SetState(732)
			p.Opt_strict()
		}

	}
	p.SetState(736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserCORRESPONDING_SYMBOL {
		{
			p.SetState(735)
			p.Opt_column_match_suffix()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_column_match_suffixContext is an interface to support dynamic dispatch.
type IOpt_column_match_suffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CORRESPONDING_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode

	// IsOpt_column_match_suffixContext differentiates from other interfaces.
	IsOpt_column_match_suffixContext()
}

type Opt_column_match_suffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_column_match_suffixContext() *Opt_column_match_suffixContext {
	var p = new(Opt_column_match_suffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_column_match_suffix
	return p
}

func InitEmptyOpt_column_match_suffixContext(p *Opt_column_match_suffixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_column_match_suffix
}

func (*Opt_column_match_suffixContext) IsOpt_column_match_suffixContext() {}

func NewOpt_column_match_suffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_column_match_suffixContext {
	var p = new(Opt_column_match_suffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_column_match_suffix

	return p
}

func (s *Opt_column_match_suffixContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_column_match_suffixContext) CORRESPONDING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCORRESPONDING_SYMBOL, 0)
}

func (s *Opt_column_match_suffixContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserBY_SYMBOL, 0)
}

func (s *Opt_column_match_suffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_column_match_suffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_column_match_suffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_column_match_suffix(s)
	}
}

func (s *Opt_column_match_suffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_column_match_suffix(s)
	}
}

func (s *Opt_column_match_suffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_column_match_suffix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_column_match_suffix() (localctx IOpt_column_match_suffixContext) {
	localctx = NewOpt_column_match_suffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, GoogleSQLParserRULE_opt_column_match_suffix)
	p.SetState(741)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(738)
			p.Match(GoogleSQLParserCORRESPONDING_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(739)
			p.Match(GoogleSQLParserCORRESPONDING_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(740)
			p.Match(GoogleSQLParserBY_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_strictContext is an interface to support dynamic dispatch.
type IOpt_strictContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRICT_SYMBOL() antlr.TerminalNode

	// IsOpt_strictContext differentiates from other interfaces.
	IsOpt_strictContext()
}

type Opt_strictContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_strictContext() *Opt_strictContext {
	var p = new(Opt_strictContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_strict
	return p
}

func InitEmptyOpt_strictContext(p *Opt_strictContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_strict
}

func (*Opt_strictContext) IsOpt_strictContext() {}

func NewOpt_strictContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_strictContext {
	var p = new(Opt_strictContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_strict

	return p
}

func (s *Opt_strictContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_strictContext) STRICT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSTRICT_SYMBOL, 0)
}

func (s *Opt_strictContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_strictContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_strictContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_strict(s)
	}
}

func (s *Opt_strictContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_strict(s)
	}
}

func (s *Opt_strictContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_strict(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_strict() (localctx IOpt_strictContext) {
	localctx = NewOpt_strictContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, GoogleSQLParserRULE_opt_strict)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(743)
		p.Match(GoogleSQLParserSTRICT_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAll_or_distinctContext is an interface to support dynamic dispatch.
type IAll_or_distinctContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL_SYMBOL() antlr.TerminalNode
	DISTINCT_SYMBOL() antlr.TerminalNode

	// IsAll_or_distinctContext differentiates from other interfaces.
	IsAll_or_distinctContext()
}

type All_or_distinctContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAll_or_distinctContext() *All_or_distinctContext {
	var p = new(All_or_distinctContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_all_or_distinct
	return p
}

func InitEmptyAll_or_distinctContext(p *All_or_distinctContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_all_or_distinct
}

func (*All_or_distinctContext) IsAll_or_distinctContext() {}

func NewAll_or_distinctContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *All_or_distinctContext {
	var p = new(All_or_distinctContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_all_or_distinct

	return p
}

func (s *All_or_distinctContext) GetParser() antlr.Parser { return s.parser }

func (s *All_or_distinctContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserALL_SYMBOL, 0)
}

func (s *All_or_distinctContext) DISTINCT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDISTINCT_SYMBOL, 0)
}

func (s *All_or_distinctContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *All_or_distinctContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *All_or_distinctContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterAll_or_distinct(s)
	}
}

func (s *All_or_distinctContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitAll_or_distinct(s)
	}
}

func (s *All_or_distinctContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitAll_or_distinct(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) All_or_distinct() (localctx IAll_or_distinctContext) {
	localctx = NewAll_or_distinctContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, GoogleSQLParserRULE_all_or_distinct)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(745)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GoogleSQLParserALL_SYMBOL || _la == GoogleSQLParserDISTINCT_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQuery_set_operation_typeContext is an interface to support dynamic dispatch.
type IQuery_set_operation_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNION_SYMBOL() antlr.TerminalNode
	EXCEPT_SYMBOL() antlr.TerminalNode
	INTERSECT_SYMBOL() antlr.TerminalNode

	// IsQuery_set_operation_typeContext differentiates from other interfaces.
	IsQuery_set_operation_typeContext()
}

type Query_set_operation_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_set_operation_typeContext() *Query_set_operation_typeContext {
	var p = new(Query_set_operation_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_query_set_operation_type
	return p
}

func InitEmptyQuery_set_operation_typeContext(p *Query_set_operation_typeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_query_set_operation_type
}

func (*Query_set_operation_typeContext) IsQuery_set_operation_typeContext() {}

func NewQuery_set_operation_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_set_operation_typeContext {
	var p = new(Query_set_operation_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_query_set_operation_type

	return p
}

func (s *Query_set_operation_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_set_operation_typeContext) UNION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserUNION_SYMBOL, 0)
}

func (s *Query_set_operation_typeContext) EXCEPT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEXCEPT_SYMBOL, 0)
}

func (s *Query_set_operation_typeContext) INTERSECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINTERSECT_SYMBOL, 0)
}

func (s *Query_set_operation_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_set_operation_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Query_set_operation_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterQuery_set_operation_type(s)
	}
}

func (s *Query_set_operation_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitQuery_set_operation_type(s)
	}
}

func (s *Query_set_operation_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitQuery_set_operation_type(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Query_set_operation_type() (localctx IQuery_set_operation_typeContext) {
	localctx = NewQuery_set_operation_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, GoogleSQLParserRULE_query_set_operation_type)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(747)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 35184374194176) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_corresponding_outer_modeContext is an interface to support dynamic dispatch.
type IOpt_corresponding_outer_modeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FULL_SYMBOL() antlr.TerminalNode
	Opt_outer() IOpt_outerContext
	OUTER_SYMBOL() antlr.TerminalNode
	LEFT_SYMBOL() antlr.TerminalNode

	// IsOpt_corresponding_outer_modeContext differentiates from other interfaces.
	IsOpt_corresponding_outer_modeContext()
}

type Opt_corresponding_outer_modeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_corresponding_outer_modeContext() *Opt_corresponding_outer_modeContext {
	var p = new(Opt_corresponding_outer_modeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_corresponding_outer_mode
	return p
}

func InitEmptyOpt_corresponding_outer_modeContext(p *Opt_corresponding_outer_modeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_corresponding_outer_mode
}

func (*Opt_corresponding_outer_modeContext) IsOpt_corresponding_outer_modeContext() {}

func NewOpt_corresponding_outer_modeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_corresponding_outer_modeContext {
	var p = new(Opt_corresponding_outer_modeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_corresponding_outer_mode

	return p
}

func (s *Opt_corresponding_outer_modeContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_corresponding_outer_modeContext) FULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFULL_SYMBOL, 0)
}

func (s *Opt_corresponding_outer_modeContext) Opt_outer() IOpt_outerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_outerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_outerContext)
}

func (s *Opt_corresponding_outer_modeContext) OUTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserOUTER_SYMBOL, 0)
}

func (s *Opt_corresponding_outer_modeContext) LEFT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLEFT_SYMBOL, 0)
}

func (s *Opt_corresponding_outer_modeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_corresponding_outer_modeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_corresponding_outer_modeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_corresponding_outer_mode(s)
	}
}

func (s *Opt_corresponding_outer_modeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_corresponding_outer_mode(s)
	}
}

func (s *Opt_corresponding_outer_modeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_corresponding_outer_mode(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_corresponding_outer_mode() (localctx IOpt_corresponding_outer_modeContext) {
	localctx = NewOpt_corresponding_outer_modeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, GoogleSQLParserRULE_opt_corresponding_outer_mode)
	var _la int

	p.SetState(758)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserFULL_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(749)
			p.Match(GoogleSQLParserFULL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(751)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserOUTER_SYMBOL {
			{
				p.SetState(750)
				p.Opt_outer()
			}

		}


	case GoogleSQLParserOUTER_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(753)
			p.Match(GoogleSQLParserOUTER_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case GoogleSQLParserLEFT_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(754)
			p.Match(GoogleSQLParserLEFT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(756)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserOUTER_SYMBOL {
			{
				p.SetState(755)
				p.Opt_outer()
			}

		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_outerContext is an interface to support dynamic dispatch.
type IOpt_outerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OUTER_SYMBOL() antlr.TerminalNode

	// IsOpt_outerContext differentiates from other interfaces.
	IsOpt_outerContext()
}

type Opt_outerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_outerContext() *Opt_outerContext {
	var p = new(Opt_outerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_outer
	return p
}

func InitEmptyOpt_outerContext(p *Opt_outerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_outer
}

func (*Opt_outerContext) IsOpt_outerContext() {}

func NewOpt_outerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_outerContext {
	var p = new(Opt_outerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_outer

	return p
}

func (s *Opt_outerContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_outerContext) OUTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserOUTER_SYMBOL, 0)
}

func (s *Opt_outerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_outerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_outerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_outer(s)
	}
}

func (s *Opt_outerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_outer(s)
	}
}

func (s *Opt_outerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_outer(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_outer() (localctx IOpt_outerContext) {
	localctx = NewOpt_outerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, GoogleSQLParserRULE_opt_outer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(760)
		p.Match(GoogleSQLParserOUTER_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWith_clauseContext is an interface to support dynamic dispatch.
type IWith_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	Aliased_query() IAliased_queryContext
	RECURSIVE_SYMBOL() antlr.TerminalNode
	With_clause() IWith_clauseContext
	COMMA_SYMBOL() antlr.TerminalNode

	// IsWith_clauseContext differentiates from other interfaces.
	IsWith_clauseContext()
}

type With_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_clauseContext() *With_clauseContext {
	var p = new(With_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_with_clause
	return p
}

func InitEmptyWith_clauseContext(p *With_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_with_clause
}

func (*With_clauseContext) IsWith_clauseContext() {}

func NewWith_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_clauseContext {
	var p = new(With_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_with_clause

	return p
}

func (s *With_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *With_clauseContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWITH_SYMBOL, 0)
}

func (s *With_clauseContext) Aliased_query() IAliased_queryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliased_queryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliased_queryContext)
}

func (s *With_clauseContext) RECURSIVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRECURSIVE_SYMBOL, 0)
}

func (s *With_clauseContext) With_clause() IWith_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_clauseContext)
}

func (s *With_clauseContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, 0)
}

func (s *With_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *With_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterWith_clause(s)
	}
}

func (s *With_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitWith_clause(s)
	}
}

func (s *With_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitWith_clause(s)

	default:
		return t.VisitChildren(s)
	}
}





func (p *GoogleSQLParser) With_clause() (localctx IWith_clauseContext) {
	return p.with_clause(0)
}

func (p *GoogleSQLParser) with_clause(_p int) (localctx IWith_clauseContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewWith_clauseContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IWith_clauseContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 42
	p.EnterRecursionRule(localctx, 42, GoogleSQLParserRULE_with_clause, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(768)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(763)
			p.Match(GoogleSQLParserWITH_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(764)
			p.Aliased_query()
		}


	case 2:
		{
			p.SetState(765)
			p.Match(GoogleSQLParserWITH_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(766)
			p.Match(GoogleSQLParserRECURSIVE_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(767)
			p.Aliased_query()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(775)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewWith_clauseContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_with_clause)
			p.SetState(770)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(771)
				p.Match(GoogleSQLParserCOMMA_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(772)
				p.Aliased_query()
			}


		}
		p.SetState(777)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAliased_queryContext is an interface to support dynamic dispatch.
type IAliased_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AS_SYMBOL() antlr.TerminalNode
	Parenthesized_query() IParenthesized_queryContext
	Opt_aliased_query_modifiers() IOpt_aliased_query_modifiersContext

	// IsAliased_queryContext differentiates from other interfaces.
	IsAliased_queryContext()
}

type Aliased_queryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliased_queryContext() *Aliased_queryContext {
	var p = new(Aliased_queryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_aliased_query
	return p
}

func InitEmptyAliased_queryContext(p *Aliased_queryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_aliased_query
}

func (*Aliased_queryContext) IsAliased_queryContext() {}

func NewAliased_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Aliased_queryContext {
	var p = new(Aliased_queryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_aliased_query

	return p
}

func (s *Aliased_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Aliased_queryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Aliased_queryContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAS_SYMBOL, 0)
}

func (s *Aliased_queryContext) Parenthesized_query() IParenthesized_queryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesized_queryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesized_queryContext)
}

func (s *Aliased_queryContext) Opt_aliased_query_modifiers() IOpt_aliased_query_modifiersContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_aliased_query_modifiersContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_aliased_query_modifiersContext)
}

func (s *Aliased_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Aliased_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Aliased_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterAliased_query(s)
	}
}

func (s *Aliased_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitAliased_query(s)
	}
}

func (s *Aliased_queryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitAliased_query(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Aliased_query() (localctx IAliased_queryContext) {
	localctx = NewAliased_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, GoogleSQLParserRULE_aliased_query)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(778)
		p.Identifier()
	}
	{
		p.SetState(779)
		p.Match(GoogleSQLParserAS_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(780)
		p.Parenthesized_query()
	}
	p.SetState(782)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(781)
			p.Opt_aliased_query_modifiers()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_aliased_query_modifiersContext is an interface to support dynamic dispatch.
type IOpt_aliased_query_modifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Recursion_depth_modifier() IRecursion_depth_modifierContext

	// IsOpt_aliased_query_modifiersContext differentiates from other interfaces.
	IsOpt_aliased_query_modifiersContext()
}

type Opt_aliased_query_modifiersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_aliased_query_modifiersContext() *Opt_aliased_query_modifiersContext {
	var p = new(Opt_aliased_query_modifiersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_aliased_query_modifiers
	return p
}

func InitEmptyOpt_aliased_query_modifiersContext(p *Opt_aliased_query_modifiersContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_aliased_query_modifiers
}

func (*Opt_aliased_query_modifiersContext) IsOpt_aliased_query_modifiersContext() {}

func NewOpt_aliased_query_modifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_aliased_query_modifiersContext {
	var p = new(Opt_aliased_query_modifiersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_aliased_query_modifiers

	return p
}

func (s *Opt_aliased_query_modifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_aliased_query_modifiersContext) Recursion_depth_modifier() IRecursion_depth_modifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecursion_depth_modifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecursion_depth_modifierContext)
}

func (s *Opt_aliased_query_modifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_aliased_query_modifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_aliased_query_modifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_aliased_query_modifiers(s)
	}
}

func (s *Opt_aliased_query_modifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_aliased_query_modifiers(s)
	}
}

func (s *Opt_aliased_query_modifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_aliased_query_modifiers(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_aliased_query_modifiers() (localctx IOpt_aliased_query_modifiersContext) {
	localctx = NewOpt_aliased_query_modifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, GoogleSQLParserRULE_opt_aliased_query_modifiers)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(784)
		p.Recursion_depth_modifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRecursion_depth_modifierContext is an interface to support dynamic dispatch.
type IRecursion_depth_modifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	DEPTH_SYMBOL() antlr.TerminalNode
	Opt_as_alias_with_required_as() IOpt_as_alias_with_required_asContext
	BETWEEN_SYMBOL() antlr.TerminalNode
	AllPossibly_unbounded_int_literal_or_parameter() []IPossibly_unbounded_int_literal_or_parameterContext
	Possibly_unbounded_int_literal_or_parameter(i int) IPossibly_unbounded_int_literal_or_parameterContext
	AND_SYMBOL() antlr.TerminalNode
	MAX_SYMBOL() antlr.TerminalNode

	// IsRecursion_depth_modifierContext differentiates from other interfaces.
	IsRecursion_depth_modifierContext()
}

type Recursion_depth_modifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecursion_depth_modifierContext() *Recursion_depth_modifierContext {
	var p = new(Recursion_depth_modifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_recursion_depth_modifier
	return p
}

func InitEmptyRecursion_depth_modifierContext(p *Recursion_depth_modifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_recursion_depth_modifier
}

func (*Recursion_depth_modifierContext) IsRecursion_depth_modifierContext() {}

func NewRecursion_depth_modifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Recursion_depth_modifierContext {
	var p = new(Recursion_depth_modifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_recursion_depth_modifier

	return p
}

func (s *Recursion_depth_modifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Recursion_depth_modifierContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWITH_SYMBOL, 0)
}

func (s *Recursion_depth_modifierContext) DEPTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDEPTH_SYMBOL, 0)
}

func (s *Recursion_depth_modifierContext) Opt_as_alias_with_required_as() IOpt_as_alias_with_required_asContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_as_alias_with_required_asContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_as_alias_with_required_asContext)
}

func (s *Recursion_depth_modifierContext) BETWEEN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserBETWEEN_SYMBOL, 0)
}

func (s *Recursion_depth_modifierContext) AllPossibly_unbounded_int_literal_or_parameter() []IPossibly_unbounded_int_literal_or_parameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPossibly_unbounded_int_literal_or_parameterContext); ok {
			len++
		}
	}

	tst := make([]IPossibly_unbounded_int_literal_or_parameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPossibly_unbounded_int_literal_or_parameterContext); ok {
			tst[i] = t.(IPossibly_unbounded_int_literal_or_parameterContext)
			i++
		}
	}

	return tst
}

func (s *Recursion_depth_modifierContext) Possibly_unbounded_int_literal_or_parameter(i int) IPossibly_unbounded_int_literal_or_parameterContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPossibly_unbounded_int_literal_or_parameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPossibly_unbounded_int_literal_or_parameterContext)
}

func (s *Recursion_depth_modifierContext) AND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAND_SYMBOL, 0)
}

func (s *Recursion_depth_modifierContext) MAX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMAX_SYMBOL, 0)
}

func (s *Recursion_depth_modifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Recursion_depth_modifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Recursion_depth_modifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterRecursion_depth_modifier(s)
	}
}

func (s *Recursion_depth_modifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitRecursion_depth_modifier(s)
	}
}

func (s *Recursion_depth_modifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitRecursion_depth_modifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Recursion_depth_modifier() (localctx IRecursion_depth_modifierContext) {
	localctx = NewRecursion_depth_modifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, GoogleSQLParserRULE_recursion_depth_modifier)
	p.SetState(805)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(786)
			p.Match(GoogleSQLParserWITH_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(787)
			p.Match(GoogleSQLParserDEPTH_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(789)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(788)
				p.Opt_as_alias_with_required_as()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(791)
			p.Match(GoogleSQLParserWITH_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(792)
			p.Match(GoogleSQLParserDEPTH_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(793)
			p.Opt_as_alias_with_required_as()
		}
		{
			p.SetState(794)
			p.Match(GoogleSQLParserBETWEEN_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(795)
			p.Possibly_unbounded_int_literal_or_parameter()
		}
		{
			p.SetState(796)
			p.Match(GoogleSQLParserAND_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(797)
			p.Possibly_unbounded_int_literal_or_parameter()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(799)
			p.Match(GoogleSQLParserWITH_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(800)
			p.Match(GoogleSQLParserDEPTH_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(801)
			p.Opt_as_alias_with_required_as()
		}
		{
			p.SetState(802)
			p.Match(GoogleSQLParserMAX_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(803)
			p.Possibly_unbounded_int_literal_or_parameter()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPossibly_unbounded_int_literal_or_parameterContext is an interface to support dynamic dispatch.
type IPossibly_unbounded_int_literal_or_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Int_literal_or_parameter() IInt_literal_or_parameterContext
	UNBOUNDED_SYMBOL() antlr.TerminalNode

	// IsPossibly_unbounded_int_literal_or_parameterContext differentiates from other interfaces.
	IsPossibly_unbounded_int_literal_or_parameterContext()
}

type Possibly_unbounded_int_literal_or_parameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPossibly_unbounded_int_literal_or_parameterContext() *Possibly_unbounded_int_literal_or_parameterContext {
	var p = new(Possibly_unbounded_int_literal_or_parameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_possibly_unbounded_int_literal_or_parameter
	return p
}

func InitEmptyPossibly_unbounded_int_literal_or_parameterContext(p *Possibly_unbounded_int_literal_or_parameterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_possibly_unbounded_int_literal_or_parameter
}

func (*Possibly_unbounded_int_literal_or_parameterContext) IsPossibly_unbounded_int_literal_or_parameterContext() {}

func NewPossibly_unbounded_int_literal_or_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Possibly_unbounded_int_literal_or_parameterContext {
	var p = new(Possibly_unbounded_int_literal_or_parameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_possibly_unbounded_int_literal_or_parameter

	return p
}

func (s *Possibly_unbounded_int_literal_or_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Possibly_unbounded_int_literal_or_parameterContext) Int_literal_or_parameter() IInt_literal_or_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_literal_or_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_literal_or_parameterContext)
}

func (s *Possibly_unbounded_int_literal_or_parameterContext) UNBOUNDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserUNBOUNDED_SYMBOL, 0)
}

func (s *Possibly_unbounded_int_literal_or_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Possibly_unbounded_int_literal_or_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Possibly_unbounded_int_literal_or_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterPossibly_unbounded_int_literal_or_parameter(s)
	}
}

func (s *Possibly_unbounded_int_literal_or_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitPossibly_unbounded_int_literal_or_parameter(s)
	}
}

func (s *Possibly_unbounded_int_literal_or_parameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitPossibly_unbounded_int_literal_or_parameter(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Possibly_unbounded_int_literal_or_parameter() (localctx IPossibly_unbounded_int_literal_or_parameterContext) {
	localctx = NewPossibly_unbounded_int_literal_or_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, GoogleSQLParserRULE_possibly_unbounded_int_literal_or_parameter)
	p.SetState(809)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserQUESTION_SYMBOL, GoogleSQLParserAT_SYMBOL, GoogleSQLParserATAT_SYMBOL, GoogleSQLParserINTEGER_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(807)
			p.Int_literal_or_parameter()
		}


	case GoogleSQLParserUNBOUNDED_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(808)
			p.Match(GoogleSQLParserUNBOUNDED_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInt_literal_or_parameterContext is an interface to support dynamic dispatch.
type IInt_literal_or_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Integer_literal() IInteger_literalContext
	Parameter_expression() IParameter_expressionContext
	System_variable_expression() ISystem_variable_expressionContext

	// IsInt_literal_or_parameterContext differentiates from other interfaces.
	IsInt_literal_or_parameterContext()
}

type Int_literal_or_parameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInt_literal_or_parameterContext() *Int_literal_or_parameterContext {
	var p = new(Int_literal_or_parameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_int_literal_or_parameter
	return p
}

func InitEmptyInt_literal_or_parameterContext(p *Int_literal_or_parameterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_int_literal_or_parameter
}

func (*Int_literal_or_parameterContext) IsInt_literal_or_parameterContext() {}

func NewInt_literal_or_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Int_literal_or_parameterContext {
	var p = new(Int_literal_or_parameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_int_literal_or_parameter

	return p
}

func (s *Int_literal_or_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Int_literal_or_parameterContext) Integer_literal() IInteger_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInteger_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInteger_literalContext)
}

func (s *Int_literal_or_parameterContext) Parameter_expression() IParameter_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameter_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameter_expressionContext)
}

func (s *Int_literal_or_parameterContext) System_variable_expression() ISystem_variable_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystem_variable_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystem_variable_expressionContext)
}

func (s *Int_literal_or_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Int_literal_or_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Int_literal_or_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterInt_literal_or_parameter(s)
	}
}

func (s *Int_literal_or_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitInt_literal_or_parameter(s)
	}
}

func (s *Int_literal_or_parameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitInt_literal_or_parameter(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Int_literal_or_parameter() (localctx IInt_literal_or_parameterContext) {
	localctx = NewInt_literal_or_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, GoogleSQLParserRULE_int_literal_or_parameter)
	p.SetState(814)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserINTEGER_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(811)
			p.Integer_literal()
		}


	case GoogleSQLParserQUESTION_SYMBOL, GoogleSQLParserAT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(812)
			p.Parameter_expression()
		}


	case GoogleSQLParserATAT_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(813)
			p.System_variable_expression()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILimit_clauseContext is an interface to support dynamic dispatch.
type ILimit_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT_SYMBOL() antlr.TerminalNode
	Count() ICountContext
	OFFSET_SYMBOL() antlr.TerminalNode
	Skip_rows() ISkip_rowsContext

	// IsLimit_clauseContext differentiates from other interfaces.
	IsLimit_clauseContext()
}

type Limit_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimit_clauseContext() *Limit_clauseContext {
	var p = new(Limit_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_limit_clause
	return p
}

func InitEmptyLimit_clauseContext(p *Limit_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_limit_clause
}

func (*Limit_clauseContext) IsLimit_clauseContext() {}

func NewLimit_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Limit_clauseContext {
	var p = new(Limit_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_limit_clause

	return p
}

func (s *Limit_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Limit_clauseContext) LIMIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLIMIT_SYMBOL, 0)
}

func (s *Limit_clauseContext) Count() ICountContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICountContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICountContext)
}

func (s *Limit_clauseContext) OFFSET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserOFFSET_SYMBOL, 0)
}

func (s *Limit_clauseContext) Skip_rows() ISkip_rowsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkip_rowsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkip_rowsContext)
}

func (s *Limit_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Limit_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Limit_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterLimit_clause(s)
	}
}

func (s *Limit_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitLimit_clause(s)
	}
}

func (s *Limit_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitLimit_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Limit_clause() (localctx ILimit_clauseContext) {
	localctx = NewLimit_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, GoogleSQLParserRULE_limit_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(816)
		p.Match(GoogleSQLParserLIMIT_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(817)
		p.Count()
	}

	{
		p.SetState(818)
		p.Match(GoogleSQLParserOFFSET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(819)
		p.Skip_rows()
	}




errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOrder_by_clauseContext is an interface to support dynamic dispatch.
type IOrder_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Order_by_clause_prefix() IOrder_by_clause_prefixContext

	// IsOrder_by_clauseContext differentiates from other interfaces.
	IsOrder_by_clauseContext()
}

type Order_by_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrder_by_clauseContext() *Order_by_clauseContext {
	var p = new(Order_by_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_order_by_clause
	return p
}

func InitEmptyOrder_by_clauseContext(p *Order_by_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_order_by_clause
}

func (*Order_by_clauseContext) IsOrder_by_clauseContext() {}

func NewOrder_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Order_by_clauseContext {
	var p = new(Order_by_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_order_by_clause

	return p
}

func (s *Order_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Order_by_clauseContext) Order_by_clause_prefix() IOrder_by_clause_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clause_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clause_prefixContext)
}

func (s *Order_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Order_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Order_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOrder_by_clause(s)
	}
}

func (s *Order_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOrder_by_clause(s)
	}
}

func (s *Order_by_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOrder_by_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Order_by_clause() (localctx IOrder_by_clauseContext) {
	localctx = NewOrder_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, GoogleSQLParserRULE_order_by_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(821)
		p.Order_by_clause_prefix()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOrder_by_clause_prefixContext is an interface to support dynamic dispatch.
type IOrder_by_clause_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	AllOrdering_expression() []IOrdering_expressionContext
	Ordering_expression(i int) IOrdering_expressionContext
	Hint() IHintContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsOrder_by_clause_prefixContext differentiates from other interfaces.
	IsOrder_by_clause_prefixContext()
}

type Order_by_clause_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrder_by_clause_prefixContext() *Order_by_clause_prefixContext {
	var p = new(Order_by_clause_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_order_by_clause_prefix
	return p
}

func InitEmptyOrder_by_clause_prefixContext(p *Order_by_clause_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_order_by_clause_prefix
}

func (*Order_by_clause_prefixContext) IsOrder_by_clause_prefixContext() {}

func NewOrder_by_clause_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Order_by_clause_prefixContext {
	var p = new(Order_by_clause_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_order_by_clause_prefix

	return p
}

func (s *Order_by_clause_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Order_by_clause_prefixContext) ORDER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserORDER_SYMBOL, 0)
}

func (s *Order_by_clause_prefixContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserBY_SYMBOL, 0)
}

func (s *Order_by_clause_prefixContext) AllOrdering_expression() []IOrdering_expressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrdering_expressionContext); ok {
			len++
		}
	}

	tst := make([]IOrdering_expressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrdering_expressionContext); ok {
			tst[i] = t.(IOrdering_expressionContext)
			i++
		}
	}

	return tst
}

func (s *Order_by_clause_prefixContext) Ordering_expression(i int) IOrdering_expressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrdering_expressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrdering_expressionContext)
}

func (s *Order_by_clause_prefixContext) Hint() IHintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintContext)
}

func (s *Order_by_clause_prefixContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Order_by_clause_prefixContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Order_by_clause_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Order_by_clause_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Order_by_clause_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOrder_by_clause_prefix(s)
	}
}

func (s *Order_by_clause_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOrder_by_clause_prefix(s)
	}
}

func (s *Order_by_clause_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOrder_by_clause_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Order_by_clause_prefix() (localctx IOrder_by_clause_prefixContext) {
	localctx = NewOrder_by_clause_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, GoogleSQLParserRULE_order_by_clause_prefix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(823)
		p.Match(GoogleSQLParserORDER_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(825)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserAT_SYMBOL {
		{
			p.SetState(824)
			p.Hint()
		}

	}
	{
		p.SetState(827)
		p.Match(GoogleSQLParserBY_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(828)
		p.Ordering_expression()
	}
	p.SetState(833)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(829)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(830)
			p.Ordering_expression()
		}


		p.SetState(835)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOrdering_expressionContext is an interface to support dynamic dispatch.
type IOrdering_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Collate_clause() ICollate_clauseContext
	Asc_or_desc() IAsc_or_descContext
	Null_order() INull_orderContext

	// IsOrdering_expressionContext differentiates from other interfaces.
	IsOrdering_expressionContext()
}

type Ordering_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrdering_expressionContext() *Ordering_expressionContext {
	var p = new(Ordering_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_ordering_expression
	return p
}

func InitEmptyOrdering_expressionContext(p *Ordering_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_ordering_expression
}

func (*Ordering_expressionContext) IsOrdering_expressionContext() {}

func NewOrdering_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ordering_expressionContext {
	var p = new(Ordering_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_ordering_expression

	return p
}

func (s *Ordering_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Ordering_expressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Ordering_expressionContext) Collate_clause() ICollate_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollate_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollate_clauseContext)
}

func (s *Ordering_expressionContext) Asc_or_desc() IAsc_or_descContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsc_or_descContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsc_or_descContext)
}

func (s *Ordering_expressionContext) Null_order() INull_orderContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INull_orderContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INull_orderContext)
}

func (s *Ordering_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ordering_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Ordering_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOrdering_expression(s)
	}
}

func (s *Ordering_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOrdering_expression(s)
	}
}

func (s *Ordering_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOrdering_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Ordering_expression() (localctx IOrdering_expressionContext) {
	localctx = NewOrdering_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, GoogleSQLParserRULE_ordering_expression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(836)
		p.expression(0)
	}
	p.SetState(838)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserCOLLATE_SYMBOL {
		{
			p.SetState(837)
			p.Collate_clause()
		}

	}
	p.SetState(841)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserASC_SYMBOL || _la == GoogleSQLParserDESC_SYMBOL {
		{
			p.SetState(840)
			p.Asc_or_desc()
		}

	}
	p.SetState(844)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserNULLS_SYMBOL {
		{
			p.SetState(843)
			p.Null_order()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOrder_by_expr_listContext is an interface to support dynamic dispatch.
type IOrder_by_expr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOrder_by_expr_list_item() []IOrder_by_expr_list_itemContext
	Order_by_expr_list_item(i int) IOrder_by_expr_list_itemContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsOrder_by_expr_listContext differentiates from other interfaces.
	IsOrder_by_expr_listContext()
}

type Order_by_expr_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrder_by_expr_listContext() *Order_by_expr_listContext {
	var p = new(Order_by_expr_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_order_by_expr_list
	return p
}

func InitEmptyOrder_by_expr_listContext(p *Order_by_expr_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_order_by_expr_list
}

func (*Order_by_expr_listContext) IsOrder_by_expr_listContext() {}

func NewOrder_by_expr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Order_by_expr_listContext {
	var p = new(Order_by_expr_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_order_by_expr_list

	return p
}

func (s *Order_by_expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Order_by_expr_listContext) AllOrder_by_expr_list_item() []IOrder_by_expr_list_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrder_by_expr_list_itemContext); ok {
			len++
		}
	}

	tst := make([]IOrder_by_expr_list_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrder_by_expr_list_itemContext); ok {
			tst[i] = t.(IOrder_by_expr_list_itemContext)
			i++
		}
	}

	return tst
}

func (s *Order_by_expr_listContext) Order_by_expr_list_item(i int) IOrder_by_expr_list_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_expr_list_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_expr_list_itemContext)
}

func (s *Order_by_expr_listContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Order_by_expr_listContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Order_by_expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Order_by_expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Order_by_expr_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOrder_by_expr_list(s)
	}
}

func (s *Order_by_expr_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOrder_by_expr_list(s)
	}
}

func (s *Order_by_expr_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOrder_by_expr_list(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Order_by_expr_list() (localctx IOrder_by_expr_listContext) {
	localctx = NewOrder_by_expr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, GoogleSQLParserRULE_order_by_expr_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(846)
		p.Order_by_expr_list_item()
	}
	p.SetState(851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(847)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(848)
			p.Order_by_expr_list_item()
		}


		p.SetState(853)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOrder_by_expr_list_itemContext is an interface to support dynamic dispatch.
type IOrder_by_expr_list_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	ASC_SYMBOL() antlr.TerminalNode
	DESC_SYMBOL() antlr.TerminalNode

	// IsOrder_by_expr_list_itemContext differentiates from other interfaces.
	IsOrder_by_expr_list_itemContext()
}

type Order_by_expr_list_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrder_by_expr_list_itemContext() *Order_by_expr_list_itemContext {
	var p = new(Order_by_expr_list_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_order_by_expr_list_item
	return p
}

func InitEmptyOrder_by_expr_list_itemContext(p *Order_by_expr_list_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_order_by_expr_list_item
}

func (*Order_by_expr_list_itemContext) IsOrder_by_expr_list_itemContext() {}

func NewOrder_by_expr_list_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Order_by_expr_list_itemContext {
	var p = new(Order_by_expr_list_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_order_by_expr_list_item

	return p
}

func (s *Order_by_expr_list_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Order_by_expr_list_itemContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Order_by_expr_list_itemContext) ASC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserASC_SYMBOL, 0)
}

func (s *Order_by_expr_list_itemContext) DESC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDESC_SYMBOL, 0)
}

func (s *Order_by_expr_list_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Order_by_expr_list_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Order_by_expr_list_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOrder_by_expr_list_item(s)
	}
}

func (s *Order_by_expr_list_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOrder_by_expr_list_item(s)
	}
}

func (s *Order_by_expr_list_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOrder_by_expr_list_item(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Order_by_expr_list_item() (localctx IOrder_by_expr_list_itemContext) {
	localctx = NewOrder_by_expr_list_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, GoogleSQLParserRULE_order_by_expr_list_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(854)
		p.expression(0)
	}
	p.SetState(856)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserASC_SYMBOL || _la == GoogleSQLParserDESC_SYMBOL {
		{
			p.SetState(855)
			_la = p.GetTokenStream().LA(1)

			if !(_la == GoogleSQLParserASC_SYMBOL || _la == GoogleSQLParserDESC_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISet_operatorContext is an interface to support dynamic dispatch.
type ISet_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNION_SYMBOL() antlr.TerminalNode
	ALL_SYMBOL() antlr.TerminalNode
	DISTINCT_SYMBOL() antlr.TerminalNode
	INTERSECT_SYMBOL() antlr.TerminalNode
	EXCEPT_SYMBOL() antlr.TerminalNode

	// IsSet_operatorContext differentiates from other interfaces.
	IsSet_operatorContext()
}

type Set_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_operatorContext() *Set_operatorContext {
	var p = new(Set_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_set_operator
	return p
}

func InitEmptySet_operatorContext(p *Set_operatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_set_operator
}

func (*Set_operatorContext) IsSet_operatorContext() {}

func NewSet_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_operatorContext {
	var p = new(Set_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_set_operator

	return p
}

func (s *Set_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_operatorContext) UNION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserUNION_SYMBOL, 0)
}

func (s *Set_operatorContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserALL_SYMBOL, 0)
}

func (s *Set_operatorContext) DISTINCT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDISTINCT_SYMBOL, 0)
}

func (s *Set_operatorContext) INTERSECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINTERSECT_SYMBOL, 0)
}

func (s *Set_operatorContext) EXCEPT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEXCEPT_SYMBOL, 0)
}

func (s *Set_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Set_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSet_operator(s)
	}
}

func (s *Set_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSet_operator(s)
	}
}

func (s *Set_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSet_operator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Set_operator() (localctx ISet_operatorContext) {
	localctx = NewSet_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, GoogleSQLParserRULE_set_operator)
	var _la int

	p.SetState(864)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserUNION_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(858)
			p.Match(GoogleSQLParserUNION_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(859)
			_la = p.GetTokenStream().LA(1)

			if !(_la == GoogleSQLParserALL_SYMBOL || _la == GoogleSQLParserDISTINCT_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case GoogleSQLParserINTERSECT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(860)
			p.Match(GoogleSQLParserINTERSECT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(861)
			p.Match(GoogleSQLParserDISTINCT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case GoogleSQLParserEXCEPT_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(862)
			p.Match(GoogleSQLParserEXCEPT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(863)
			p.Match(GoogleSQLParserDISTINCT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelectContext is an interface to support dynamic dispatch.
type ISelectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_clause() ISelect_clauseContext
	Opt_clauses_following_from() IOpt_clauses_following_fromContext
	From_clause() IFrom_clauseContext

	// IsSelectContext differentiates from other interfaces.
	IsSelectContext()
}

type SelectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectContext() *SelectContext {
	var p = new(SelectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select
	return p
}

func InitEmptySelectContext(p *SelectContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select
}

func (*SelectContext) IsSelectContext() {}

func NewSelectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectContext {
	var p = new(SelectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_select

	return p
}

func (s *SelectContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectContext) Select_clause() ISelect_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_clauseContext)
}

func (s *SelectContext) Opt_clauses_following_from() IOpt_clauses_following_fromContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_clauses_following_fromContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_clauses_following_fromContext)
}

func (s *SelectContext) From_clause() IFrom_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_clauseContext)
}

func (s *SelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSelect(s)
	}
}

func (s *SelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSelect(s)
	}
}

func (s *SelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSelect(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Select_() (localctx ISelectContext) {
	localctx = NewSelectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, GoogleSQLParserRULE_select)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(866)
		p.Select_clause()
	}
	p.SetState(868)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(867)
			p.From_clause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(870)
		p.Opt_clauses_following_from()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_clauses_following_fromContext is an interface to support dynamic dispatch.
type IOpt_clauses_following_fromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Where_clause() IWhere_clauseContext
	Group_by_clause() IGroup_by_clauseContext
	Having_clause() IHaving_clauseContext
	Qualify_clause_nonreserved() IQualify_clause_nonreservedContext
	Window_clause() IWindow_clauseContext
	Opt_clauses_following_where() IOpt_clauses_following_whereContext

	// IsOpt_clauses_following_fromContext differentiates from other interfaces.
	IsOpt_clauses_following_fromContext()
}

type Opt_clauses_following_fromContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_clauses_following_fromContext() *Opt_clauses_following_fromContext {
	var p = new(Opt_clauses_following_fromContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_clauses_following_from
	return p
}

func InitEmptyOpt_clauses_following_fromContext(p *Opt_clauses_following_fromContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_clauses_following_from
}

func (*Opt_clauses_following_fromContext) IsOpt_clauses_following_fromContext() {}

func NewOpt_clauses_following_fromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_clauses_following_fromContext {
	var p = new(Opt_clauses_following_fromContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_clauses_following_from

	return p
}

func (s *Opt_clauses_following_fromContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_clauses_following_fromContext) Where_clause() IWhere_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Opt_clauses_following_fromContext) Group_by_clause() IGroup_by_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroup_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroup_by_clauseContext)
}

func (s *Opt_clauses_following_fromContext) Having_clause() IHaving_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHaving_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHaving_clauseContext)
}

func (s *Opt_clauses_following_fromContext) Qualify_clause_nonreserved() IQualify_clause_nonreservedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualify_clause_nonreservedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualify_clause_nonreservedContext)
}

func (s *Opt_clauses_following_fromContext) Window_clause() IWindow_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_clauseContext)
}

func (s *Opt_clauses_following_fromContext) Opt_clauses_following_where() IOpt_clauses_following_whereContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_clauses_following_whereContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_clauses_following_whereContext)
}

func (s *Opt_clauses_following_fromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_clauses_following_fromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_clauses_following_fromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_clauses_following_from(s)
	}
}

func (s *Opt_clauses_following_fromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_clauses_following_from(s)
	}
}

func (s *Opt_clauses_following_fromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_clauses_following_from(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_clauses_following_from() (localctx IOpt_clauses_following_fromContext) {
	localctx = NewOpt_clauses_following_fromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, GoogleSQLParserRULE_opt_clauses_following_from)
	p.SetState(886)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(872)
			p.Where_clause()
		}
		p.SetState(874)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(873)
				p.Group_by_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(877)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(876)
				p.Having_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(880)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(879)
				p.Qualify_clause_nonreserved()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(883)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(882)
				p.Window_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(885)
			p.Opt_clauses_following_where()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_clauses_following_whereContext is an interface to support dynamic dispatch.
type IOpt_clauses_following_whereContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Group_by_clause() IGroup_by_clauseContext
	Having_clause() IHaving_clauseContext
	Qualify_clause_nonreserved() IQualify_clause_nonreservedContext
	Window_clause() IWindow_clauseContext
	Opt_clauses_following_group_by() IOpt_clauses_following_group_byContext

	// IsOpt_clauses_following_whereContext differentiates from other interfaces.
	IsOpt_clauses_following_whereContext()
}

type Opt_clauses_following_whereContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_clauses_following_whereContext() *Opt_clauses_following_whereContext {
	var p = new(Opt_clauses_following_whereContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_clauses_following_where
	return p
}

func InitEmptyOpt_clauses_following_whereContext(p *Opt_clauses_following_whereContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_clauses_following_where
}

func (*Opt_clauses_following_whereContext) IsOpt_clauses_following_whereContext() {}

func NewOpt_clauses_following_whereContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_clauses_following_whereContext {
	var p = new(Opt_clauses_following_whereContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_clauses_following_where

	return p
}

func (s *Opt_clauses_following_whereContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_clauses_following_whereContext) Group_by_clause() IGroup_by_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroup_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroup_by_clauseContext)
}

func (s *Opt_clauses_following_whereContext) Having_clause() IHaving_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHaving_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHaving_clauseContext)
}

func (s *Opt_clauses_following_whereContext) Qualify_clause_nonreserved() IQualify_clause_nonreservedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualify_clause_nonreservedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualify_clause_nonreservedContext)
}

func (s *Opt_clauses_following_whereContext) Window_clause() IWindow_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_clauseContext)
}

func (s *Opt_clauses_following_whereContext) Opt_clauses_following_group_by() IOpt_clauses_following_group_byContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_clauses_following_group_byContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_clauses_following_group_byContext)
}

func (s *Opt_clauses_following_whereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_clauses_following_whereContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_clauses_following_whereContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_clauses_following_where(s)
	}
}

func (s *Opt_clauses_following_whereContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_clauses_following_where(s)
	}
}

func (s *Opt_clauses_following_whereContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_clauses_following_where(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_clauses_following_where() (localctx IOpt_clauses_following_whereContext) {
	localctx = NewOpt_clauses_following_whereContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, GoogleSQLParserRULE_opt_clauses_following_where)
	p.SetState(899)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(888)
			p.Group_by_clause()
		}
		p.SetState(890)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(889)
				p.Having_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(893)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(892)
				p.Qualify_clause_nonreserved()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(896)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(895)
				p.Window_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(898)
			p.Opt_clauses_following_group_by()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_clauses_following_group_byContext is an interface to support dynamic dispatch.
type IOpt_clauses_following_group_byContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Having_clause() IHaving_clauseContext
	Qualify_clause_nonreserved() IQualify_clause_nonreservedContext
	Window_clause() IWindow_clauseContext

	// IsOpt_clauses_following_group_byContext differentiates from other interfaces.
	IsOpt_clauses_following_group_byContext()
}

type Opt_clauses_following_group_byContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_clauses_following_group_byContext() *Opt_clauses_following_group_byContext {
	var p = new(Opt_clauses_following_group_byContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_clauses_following_group_by
	return p
}

func InitEmptyOpt_clauses_following_group_byContext(p *Opt_clauses_following_group_byContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_clauses_following_group_by
}

func (*Opt_clauses_following_group_byContext) IsOpt_clauses_following_group_byContext() {}

func NewOpt_clauses_following_group_byContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_clauses_following_group_byContext {
	var p = new(Opt_clauses_following_group_byContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_clauses_following_group_by

	return p
}

func (s *Opt_clauses_following_group_byContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_clauses_following_group_byContext) Having_clause() IHaving_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHaving_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHaving_clauseContext)
}

func (s *Opt_clauses_following_group_byContext) Qualify_clause_nonreserved() IQualify_clause_nonreservedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualify_clause_nonreservedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualify_clause_nonreservedContext)
}

func (s *Opt_clauses_following_group_byContext) Window_clause() IWindow_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_clauseContext)
}

func (s *Opt_clauses_following_group_byContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_clauses_following_group_byContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_clauses_following_group_byContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_clauses_following_group_by(s)
	}
}

func (s *Opt_clauses_following_group_byContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_clauses_following_group_by(s)
	}
}

func (s *Opt_clauses_following_group_byContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_clauses_following_group_by(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_clauses_following_group_by() (localctx IOpt_clauses_following_group_byContext) {
	localctx = NewOpt_clauses_following_group_byContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, GoogleSQLParserRULE_opt_clauses_following_group_by)
	p.SetState(916)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(902)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(901)
				p.Having_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(905)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(904)
				p.Qualify_clause_nonreserved()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(908)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(907)
				p.Window_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(911)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(910)
				p.Qualify_clause_nonreserved()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(914)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(913)
				p.Window_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_clauseContext is an interface to support dynamic dispatch.
type IWindow_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Window_clause_prefix() IWindow_clause_prefixContext

	// IsWindow_clauseContext differentiates from other interfaces.
	IsWindow_clauseContext()
}

type Window_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_clauseContext() *Window_clauseContext {
	var p = new(Window_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_window_clause
	return p
}

func InitEmptyWindow_clauseContext(p *Window_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_window_clause
}

func (*Window_clauseContext) IsWindow_clauseContext() {}

func NewWindow_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_clauseContext {
	var p = new(Window_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_window_clause

	return p
}

func (s *Window_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_clauseContext) Window_clause_prefix() IWindow_clause_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_clause_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_clause_prefixContext)
}

func (s *Window_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterWindow_clause(s)
	}
}

func (s *Window_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitWindow_clause(s)
	}
}

func (s *Window_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitWindow_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Window_clause() (localctx IWindow_clauseContext) {
	localctx = NewWindow_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, GoogleSQLParserRULE_window_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(918)
		p.Window_clause_prefix()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_clause_prefixContext is an interface to support dynamic dispatch.
type IWindow_clause_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WINDOW_SYMBOL() antlr.TerminalNode
	AllWindow_definition() []IWindow_definitionContext
	Window_definition(i int) IWindow_definitionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsWindow_clause_prefixContext differentiates from other interfaces.
	IsWindow_clause_prefixContext()
}

type Window_clause_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_clause_prefixContext() *Window_clause_prefixContext {
	var p = new(Window_clause_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_window_clause_prefix
	return p
}

func InitEmptyWindow_clause_prefixContext(p *Window_clause_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_window_clause_prefix
}

func (*Window_clause_prefixContext) IsWindow_clause_prefixContext() {}

func NewWindow_clause_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_clause_prefixContext {
	var p = new(Window_clause_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_window_clause_prefix

	return p
}

func (s *Window_clause_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_clause_prefixContext) WINDOW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWINDOW_SYMBOL, 0)
}

func (s *Window_clause_prefixContext) AllWindow_definition() []IWindow_definitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindow_definitionContext); ok {
			len++
		}
	}

	tst := make([]IWindow_definitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindow_definitionContext); ok {
			tst[i] = t.(IWindow_definitionContext)
			i++
		}
	}

	return tst
}

func (s *Window_clause_prefixContext) Window_definition(i int) IWindow_definitionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_definitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_definitionContext)
}

func (s *Window_clause_prefixContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Window_clause_prefixContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Window_clause_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_clause_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_clause_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterWindow_clause_prefix(s)
	}
}

func (s *Window_clause_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitWindow_clause_prefix(s)
	}
}

func (s *Window_clause_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitWindow_clause_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Window_clause_prefix() (localctx IWindow_clause_prefixContext) {
	localctx = NewWindow_clause_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, GoogleSQLParserRULE_window_clause_prefix)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(920)
		p.Match(GoogleSQLParserWINDOW_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(921)
		p.Window_definition()
	}
	p.SetState(926)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(922)
				p.Match(GoogleSQLParserCOMMA_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(923)
				p.Window_definition()
			}


		}
		p.SetState(928)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_definitionContext is an interface to support dynamic dispatch.
type IWindow_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AS_SYMBOL() antlr.TerminalNode
	Window_specification() IWindow_specificationContext

	// IsWindow_definitionContext differentiates from other interfaces.
	IsWindow_definitionContext()
}

type Window_definitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_definitionContext() *Window_definitionContext {
	var p = new(Window_definitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_window_definition
	return p
}

func InitEmptyWindow_definitionContext(p *Window_definitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_window_definition
}

func (*Window_definitionContext) IsWindow_definitionContext() {}

func NewWindow_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_definitionContext {
	var p = new(Window_definitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_window_definition

	return p
}

func (s *Window_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_definitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Window_definitionContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAS_SYMBOL, 0)
}

func (s *Window_definitionContext) Window_specification() IWindow_specificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_specificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_specificationContext)
}

func (s *Window_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterWindow_definition(s)
	}
}

func (s *Window_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitWindow_definition(s)
	}
}

func (s *Window_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitWindow_definition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Window_definition() (localctx IWindow_definitionContext) {
	localctx = NewWindow_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, GoogleSQLParserRULE_window_definition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(929)
		p.Identifier()
	}
	{
		p.SetState(930)
		p.Match(GoogleSQLParserAS_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(931)
		p.Window_specification()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWhere_clauseContext is an interface to support dynamic dispatch.
type IWhere_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsWhere_clauseContext differentiates from other interfaces.
	IsWhere_clauseContext()
}

type Where_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhere_clauseContext() *Where_clauseContext {
	var p = new(Where_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_where_clause
	return p
}

func InitEmptyWhere_clauseContext(p *Where_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_where_clause
}

func (*Where_clauseContext) IsWhere_clauseContext() {}

func NewWhere_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Where_clauseContext {
	var p = new(Where_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_where_clause

	return p
}

func (s *Where_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Where_clauseContext) WHERE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWHERE_SYMBOL, 0)
}

func (s *Where_clauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Where_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Where_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Where_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterWhere_clause(s)
	}
}

func (s *Where_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitWhere_clause(s)
	}
}

func (s *Where_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitWhere_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Where_clause() (localctx IWhere_clauseContext) {
	localctx = NewWhere_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, GoogleSQLParserRULE_where_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(933)
		p.Match(GoogleSQLParserWHERE_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(934)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHaving_clauseContext is an interface to support dynamic dispatch.
type IHaving_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HAVING_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsHaving_clauseContext differentiates from other interfaces.
	IsHaving_clauseContext()
}

type Having_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHaving_clauseContext() *Having_clauseContext {
	var p = new(Having_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_having_clause
	return p
}

func InitEmptyHaving_clauseContext(p *Having_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_having_clause
}

func (*Having_clauseContext) IsHaving_clauseContext() {}

func NewHaving_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Having_clauseContext {
	var p = new(Having_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_having_clause

	return p
}

func (s *Having_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Having_clauseContext) HAVING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserHAVING_SYMBOL, 0)
}

func (s *Having_clauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Having_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Having_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Having_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterHaving_clause(s)
	}
}

func (s *Having_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitHaving_clause(s)
	}
}

func (s *Having_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitHaving_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Having_clause() (localctx IHaving_clauseContext) {
	localctx = NewHaving_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, GoogleSQLParserRULE_having_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(936)
		p.Match(GoogleSQLParserHAVING_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(937)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGroup_by_clauseContext is an interface to support dynamic dispatch.
type IGroup_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Group_by_all() IGroup_by_allContext
	Group_by_clause_prefix() IGroup_by_clause_prefixContext

	// IsGroup_by_clauseContext differentiates from other interfaces.
	IsGroup_by_clauseContext()
}

type Group_by_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_by_clauseContext() *Group_by_clauseContext {
	var p = new(Group_by_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_group_by_clause
	return p
}

func InitEmptyGroup_by_clauseContext(p *Group_by_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_group_by_clause
}

func (*Group_by_clauseContext) IsGroup_by_clauseContext() {}

func NewGroup_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_by_clauseContext {
	var p = new(Group_by_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_group_by_clause

	return p
}

func (s *Group_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_by_clauseContext) Group_by_all() IGroup_by_allContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroup_by_allContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroup_by_allContext)
}

func (s *Group_by_clauseContext) Group_by_clause_prefix() IGroup_by_clause_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroup_by_clause_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroup_by_clause_prefixContext)
}

func (s *Group_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Group_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterGroup_by_clause(s)
	}
}

func (s *Group_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitGroup_by_clause(s)
	}
}

func (s *Group_by_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitGroup_by_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Group_by_clause() (localctx IGroup_by_clauseContext) {
	localctx = NewGroup_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, GoogleSQLParserRULE_group_by_clause)
	p.SetState(941)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(939)
			p.Group_by_all()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(940)
			p.Group_by_clause_prefix()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGroup_by_allContext is an interface to support dynamic dispatch.
type IGroup_by_allContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Group_by_preamble() IGroup_by_preambleContext
	ALL_SYMBOL() antlr.TerminalNode

	// IsGroup_by_allContext differentiates from other interfaces.
	IsGroup_by_allContext()
}

type Group_by_allContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_by_allContext() *Group_by_allContext {
	var p = new(Group_by_allContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_group_by_all
	return p
}

func InitEmptyGroup_by_allContext(p *Group_by_allContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_group_by_all
}

func (*Group_by_allContext) IsGroup_by_allContext() {}

func NewGroup_by_allContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_by_allContext {
	var p = new(Group_by_allContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_group_by_all

	return p
}

func (s *Group_by_allContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_by_allContext) Group_by_preamble() IGroup_by_preambleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroup_by_preambleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroup_by_preambleContext)
}

func (s *Group_by_allContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserALL_SYMBOL, 0)
}

func (s *Group_by_allContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_by_allContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Group_by_allContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterGroup_by_all(s)
	}
}

func (s *Group_by_allContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitGroup_by_all(s)
	}
}

func (s *Group_by_allContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitGroup_by_all(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Group_by_all() (localctx IGroup_by_allContext) {
	localctx = NewGroup_by_allContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, GoogleSQLParserRULE_group_by_all)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(943)
		p.Group_by_preamble()
	}
	{
		p.SetState(944)
		p.Match(GoogleSQLParserALL_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_clauseContext is an interface to support dynamic dispatch.
type ISelect_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT_SYMBOL() antlr.TerminalNode
	Select_list() ISelect_listContext
	Hint() IHintContext
	Opt_select_with() IOpt_select_withContext
	All_or_distinct() IAll_or_distinctContext
	Opt_select_as_clause() IOpt_select_as_clauseContext
	FROM_SYMBOL() antlr.TerminalNode

	// IsSelect_clauseContext differentiates from other interfaces.
	IsSelect_clauseContext()
}

type Select_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_clauseContext() *Select_clauseContext {
	var p = new(Select_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select_clause
	return p
}

func InitEmptySelect_clauseContext(p *Select_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select_clause
}

func (*Select_clauseContext) IsSelect_clauseContext() {}

func NewSelect_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_clauseContext {
	var p = new(Select_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_select_clause

	return p
}

func (s *Select_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_clauseContext) SELECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSELECT_SYMBOL, 0)
}

func (s *Select_clauseContext) Select_list() ISelect_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_listContext)
}

func (s *Select_clauseContext) Hint() IHintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintContext)
}

func (s *Select_clauseContext) Opt_select_with() IOpt_select_withContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_select_withContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_select_withContext)
}

func (s *Select_clauseContext) All_or_distinct() IAll_or_distinctContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAll_or_distinctContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAll_or_distinctContext)
}

func (s *Select_clauseContext) Opt_select_as_clause() IOpt_select_as_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_select_as_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_select_as_clauseContext)
}

func (s *Select_clauseContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFROM_SYMBOL, 0)
}

func (s *Select_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSelect_clause(s)
	}
}

func (s *Select_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSelect_clause(s)
	}
}

func (s *Select_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSelect_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Select_clause() (localctx ISelect_clauseContext) {
	localctx = NewSelect_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, GoogleSQLParserRULE_select_clause)
	var _la int

	p.SetState(975)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(946)
			p.Match(GoogleSQLParserSELECT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(948)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(947)
				p.Hint()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(951)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(950)
				p.Opt_select_with()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(954)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(953)
				p.All_or_distinct()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(957)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(956)
				p.Opt_select_as_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(959)
			p.Select_list()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(960)
			p.Match(GoogleSQLParserSELECT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(962)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserAT_SYMBOL {
			{
				p.SetState(961)
				p.Hint()
			}

		}
		p.SetState(965)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserWITH_SYMBOL {
			{
				p.SetState(964)
				p.Opt_select_with()
			}

		}
		p.SetState(968)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserALL_SYMBOL || _la == GoogleSQLParserDISTINCT_SYMBOL {
			{
				p.SetState(967)
				p.All_or_distinct()
			}

		}
		p.SetState(971)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserAS_SYMBOL {
			{
				p.SetState(970)
				p.Opt_select_as_clause()
			}

		}
		{
			p.SetState(973)
			p.Match(GoogleSQLParserFROM_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.NotifyErrorListeners("Syntax error: SELECT list must not be empty", nil, nil)
				

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_select_as_clauseContext is an interface to support dynamic dispatch.
type IOpt_select_as_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS_SYMBOL() antlr.TerminalNode
	STRUCT_SYMBOL() antlr.TerminalNode
	Path_expression() IPath_expressionContext

	// IsOpt_select_as_clauseContext differentiates from other interfaces.
	IsOpt_select_as_clauseContext()
}

type Opt_select_as_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_select_as_clauseContext() *Opt_select_as_clauseContext {
	var p = new(Opt_select_as_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_select_as_clause
	return p
}

func InitEmptyOpt_select_as_clauseContext(p *Opt_select_as_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_select_as_clause
}

func (*Opt_select_as_clauseContext) IsOpt_select_as_clauseContext() {}

func NewOpt_select_as_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_select_as_clauseContext {
	var p = new(Opt_select_as_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_select_as_clause

	return p
}

func (s *Opt_select_as_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_select_as_clauseContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAS_SYMBOL, 0)
}

func (s *Opt_select_as_clauseContext) STRUCT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSTRUCT_SYMBOL, 0)
}

func (s *Opt_select_as_clauseContext) Path_expression() IPath_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPath_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPath_expressionContext)
}

func (s *Opt_select_as_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_select_as_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_select_as_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_select_as_clause(s)
	}
}

func (s *Opt_select_as_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_select_as_clause(s)
	}
}

func (s *Opt_select_as_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_select_as_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_select_as_clause() (localctx IOpt_select_as_clauseContext) {
	localctx = NewOpt_select_as_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, GoogleSQLParserRULE_opt_select_as_clause)
	p.SetState(981)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(977)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(978)
			p.Match(GoogleSQLParserSTRUCT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(979)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(980)
			p.path_expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_select_withContext is an interface to support dynamic dispatch.
type IOpt_select_withContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	OPTIONS_SYMBOL() antlr.TerminalNode
	Options_list() IOptions_listContext

	// IsOpt_select_withContext differentiates from other interfaces.
	IsOpt_select_withContext()
}

type Opt_select_withContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_select_withContext() *Opt_select_withContext {
	var p = new(Opt_select_withContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_select_with
	return p
}

func InitEmptyOpt_select_withContext(p *Opt_select_withContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_select_with
}

func (*Opt_select_withContext) IsOpt_select_withContext() {}

func NewOpt_select_withContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_select_withContext {
	var p = new(Opt_select_withContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_select_with

	return p
}

func (s *Opt_select_withContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_select_withContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWITH_SYMBOL, 0)
}

func (s *Opt_select_withContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Opt_select_withContext) OPTIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserOPTIONS_SYMBOL, 0)
}

func (s *Opt_select_withContext) Options_list() IOptions_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptions_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptions_listContext)
}

func (s *Opt_select_withContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_select_withContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_select_withContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_select_with(s)
	}
}

func (s *Opt_select_withContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_select_with(s)
	}
}

func (s *Opt_select_withContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_select_with(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_select_with() (localctx IOpt_select_withContext) {
	localctx = NewOpt_select_withContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, GoogleSQLParserRULE_opt_select_with)
	p.SetState(990)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(983)
			p.Match(GoogleSQLParserWITH_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(984)
			p.Identifier()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(985)
			p.Match(GoogleSQLParserWITH_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(986)
			p.Identifier()
		}
		{
			p.SetState(987)
			p.Match(GoogleSQLParserOPTIONS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(988)
			p.Options_list()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFrom_clauseContext is an interface to support dynamic dispatch.
type IFrom_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM_SYMBOL() antlr.TerminalNode
	From_clause_contents() IFrom_clause_contentsContext

	// IsFrom_clauseContext differentiates from other interfaces.
	IsFrom_clauseContext()
}

type From_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_clauseContext() *From_clauseContext {
	var p = new(From_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_from_clause
	return p
}

func InitEmptyFrom_clauseContext(p *From_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_from_clause
}

func (*From_clauseContext) IsFrom_clauseContext() {}

func NewFrom_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_clauseContext {
	var p = new(From_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_from_clause

	return p
}

func (s *From_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_clauseContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFROM_SYMBOL, 0)
}

func (s *From_clauseContext) From_clause_contents() IFrom_clause_contentsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_clause_contentsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_clause_contentsContext)
}

func (s *From_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *From_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterFrom_clause(s)
	}
}

func (s *From_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitFrom_clause(s)
	}
}

func (s *From_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitFrom_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) From_clause() (localctx IFrom_clauseContext) {
	localctx = NewFrom_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, GoogleSQLParserRULE_from_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(992)
		p.Match(GoogleSQLParserFROM_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(993)
		p.from_clause_contents(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFrom_clause_contentsContext is an interface to support dynamic dispatch.
type IFrom_clause_contentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_primary() ITable_primaryContext
	AT_SYMBOL() antlr.TerminalNode
	QUESTION_SYMBOL() antlr.TerminalNode
	ATAT_SYMBOL() antlr.TerminalNode
	From_clause_contents() IFrom_clause_contentsContext
	COMMA_SYMBOL() antlr.TerminalNode
	Join_hint() IJoin_hintContext
	Opt_natural() IOpt_naturalContext
	Join_type() IJoin_typeContext

	// IsFrom_clause_contentsContext differentiates from other interfaces.
	IsFrom_clause_contentsContext()
}

type From_clause_contentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_clause_contentsContext() *From_clause_contentsContext {
	var p = new(From_clause_contentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_from_clause_contents
	return p
}

func InitEmptyFrom_clause_contentsContext(p *From_clause_contentsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_from_clause_contents
}

func (*From_clause_contentsContext) IsFrom_clause_contentsContext() {}

func NewFrom_clause_contentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_clause_contentsContext {
	var p = new(From_clause_contentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_from_clause_contents

	return p
}

func (s *From_clause_contentsContext) GetParser() antlr.Parser { return s.parser }

func (s *From_clause_contentsContext) Table_primary() ITable_primaryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_primaryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_primaryContext)
}

func (s *From_clause_contentsContext) AT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAT_SYMBOL, 0)
}

func (s *From_clause_contentsContext) QUESTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserQUESTION_SYMBOL, 0)
}

func (s *From_clause_contentsContext) ATAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserATAT_SYMBOL, 0)
}

func (s *From_clause_contentsContext) From_clause_contents() IFrom_clause_contentsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_clause_contentsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_clause_contentsContext)
}

func (s *From_clause_contentsContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, 0)
}

func (s *From_clause_contentsContext) Join_hint() IJoin_hintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoin_hintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoin_hintContext)
}

func (s *From_clause_contentsContext) Opt_natural() IOpt_naturalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_naturalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_naturalContext)
}

func (s *From_clause_contentsContext) Join_type() IJoin_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoin_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoin_typeContext)
}

func (s *From_clause_contentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_clause_contentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *From_clause_contentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterFrom_clause_contents(s)
	}
}

func (s *From_clause_contentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitFrom_clause_contents(s)
	}
}

func (s *From_clause_contentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitFrom_clause_contents(s)

	default:
		return t.VisitChildren(s)
	}
}





func (p *GoogleSQLParser) From_clause_contents() (localctx IFrom_clause_contentsContext) {
	return p.from_clause_contents(0)
}

func (p *GoogleSQLParser) from_clause_contents(_p int) (localctx IFrom_clause_contentsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewFrom_clause_contentsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFrom_clause_contentsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 98
	p.EnterRecursionRule(localctx, 98, GoogleSQLParserRULE_from_clause_contents, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1003)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserINCLUDE_SYMBOL, GoogleSQLParserOFFSET_SYMBOL, GoogleSQLParserOPTIONS_SYMBOL, GoogleSQLParserPERCENT_SYMBOL, GoogleSQLParserPIVOT_SYMBOL, GoogleSQLParserREPLACE_SYMBOL, GoogleSQLParserUNPIVOT_SYMBOL, GoogleSQLParserSYSTEM_SYMBOL, GoogleSQLParserSYSTEM_TIME_SYMBOL, GoogleSQLParserUNNEST_SYMBOL, GoogleSQLParserVALUE_SYMBOL, GoogleSQLParserNUMERIC_SYMBOL, GoogleSQLParserDECIMAL_SYMBOL, GoogleSQLParserBIGNUMERIC_SYMBOL, GoogleSQLParserBIGDECIMAL_SYMBOL, GoogleSQLParserJSON_SYMBOL, GoogleSQLParserDATE_SYMBOL, GoogleSQLParserTIME_SYMBOL, GoogleSQLParserDATETIME_SYMBOL, GoogleSQLParserTIMESTAMP_SYMBOL, GoogleSQLParserSIMPLE_SYMBOL, GoogleSQLParserABORT_SYMBOL, GoogleSQLParserACCESS_SYMBOL, GoogleSQLParserACTION_SYMBOL, GoogleSQLParserAGGREGATE_SYMBOL, GoogleSQLParserADD_SYMBOL, GoogleSQLParserALTER_SYMBOL, GoogleSQLParserALWAYS_SYMBOL, GoogleSQLParserANALYZE_SYMBOL, GoogleSQLParserAPPROX_SYMBOL, GoogleSQLParserARE_SYMBOL, GoogleSQLParserASSERT_SYMBOL, GoogleSQLParserBATCH_SYMBOL, GoogleSQLParserBEGIN_SYMBOL, GoogleSQLParserBREAK_SYMBOL, GoogleSQLParserCALL_SYMBOL, GoogleSQLParserCASCADE_SYMBOL, GoogleSQLParserCHECK_SYMBOL, GoogleSQLParserCLAMPED_SYMBOL, GoogleSQLParserCLONE_SYMBOL, GoogleSQLParserCOPY_SYMBOL, GoogleSQLParserCLUSTER_SYMBOL, GoogleSQLParserCOLUMN_SYMBOL, GoogleSQLParserCOLUMNS_SYMBOL, GoogleSQLParserCOMMIT_SYMBOL, GoogleSQLParserCONNECTION_SYMBOL, GoogleSQLParserCONSTANT_SYMBOL, GoogleSQLParserCONSTRAINT_SYMBOL, GoogleSQLParserCONTINUE_SYMBOL, GoogleSQLParserCORRESPONDING_SYMBOL, GoogleSQLParserCYCLE_SYMBOL, GoogleSQLParserDATA_SYMBOL, GoogleSQLParserDATABASE_SYMBOL, GoogleSQLParserDECLARE_SYMBOL, GoogleSQLParserDEFINER_SYMBOL, GoogleSQLParserDELETE_SYMBOL, GoogleSQLParserDELETION_SYMBOL, GoogleSQLParserDEPTH_SYMBOL, GoogleSQLParserDESCRIBE_SYMBOL, GoogleSQLParserDETERMINISTIC_SYMBOL, GoogleSQLParserDO_SYMBOL, GoogleSQLParserDROP_SYMBOL, GoogleSQLParserELSEIF_SYMBOL, GoogleSQLParserENFORCED_SYMBOL, GoogleSQLParserERROR_SYMBOL, GoogleSQLParserEXCEPTION_SYMBOL, GoogleSQLParserEXECUTE_SYMBOL, GoogleSQLParserEXPLAIN_SYMBOL, GoogleSQLParserEXPORT_SYMBOL, GoogleSQLParserEXTEND_SYMBOL, GoogleSQLParserEXTERNAL_SYMBOL, GoogleSQLParserFILES_SYMBOL, GoogleSQLParserFILTER_SYMBOL, GoogleSQLParserFILL_SYMBOL, GoogleSQLParserFIRST_SYMBOL, GoogleSQLParserFOREIGN_SYMBOL, GoogleSQLParserFORMAT_SYMBOL, GoogleSQLParserFUNCTION_SYMBOL, GoogleSQLParserGENERATED_SYMBOL, GoogleSQLParserGRANT_SYMBOL, GoogleSQLParserGROUP_ROWS_SYMBOL, GoogleSQLParserHIDDEN_SYMBOL, GoogleSQLParserIDENTITY_SYMBOL, GoogleSQLParserIMMEDIATE_SYMBOL, GoogleSQLParserIMMUTABLE_SYMBOL, GoogleSQLParserIMPORT_SYMBOL, GoogleSQLParserINCREMENT_SYMBOL, GoogleSQLParserINDEX_SYMBOL, GoogleSQLParserINOUT_SYMBOL, GoogleSQLParserINPUT_SYMBOL, GoogleSQLParserINSERT_SYMBOL, GoogleSQLParserINVOKER_SYMBOL, GoogleSQLParserISOLATION_SYMBOL, GoogleSQLParserITERATE_SYMBOL, GoogleSQLParserKEY_SYMBOL, GoogleSQLParserLANGUAGE_SYMBOL, GoogleSQLParserLAST_SYMBOL, GoogleSQLParserLEAVE_SYMBOL, GoogleSQLParserLEVEL_SYMBOL, GoogleSQLParserLOAD_SYMBOL, GoogleSQLParserLOOP_SYMBOL, GoogleSQLParserMACRO_SYMBOL, GoogleSQLParserMAP_SYMBOL, GoogleSQLParserMATCH_SYMBOL, GoogleSQLParserKW_MATCH_RECOGNIZE_NONRESERVED_SYMBOL, GoogleSQLParserMATCHED_SYMBOL, GoogleSQLParserMATERIALIZED_SYMBOL, GoogleSQLParserMAX_SYMBOL, GoogleSQLParserMAXVALUE_SYMBOL, GoogleSQLParserMEASURES_SYMBOL, GoogleSQLParserMESSAGE_SYMBOL, GoogleSQLParserMETADATA_SYMBOL, GoogleSQLParserMIN_SYMBOL, GoogleSQLParserMINVALUE_SYMBOL, GoogleSQLParserMODEL_SYMBOL, GoogleSQLParserMODULE_SYMBOL, GoogleSQLParserONLY_SYMBOL, GoogleSQLParserOUT_SYMBOL, GoogleSQLParserOUTPUT_SYMBOL, GoogleSQLParserOVERWRITE_SYMBOL, GoogleSQLParserPARTITIONS_SYMBOL, GoogleSQLParserPATTERN_SYMBOL, GoogleSQLParserPOLICIES_SYMBOL, GoogleSQLParserPOLICY_SYMBOL, GoogleSQLParserPRIMARY_SYMBOL, GoogleSQLParserPRIVATE_SYMBOL, GoogleSQLParserPRIVILEGE_SYMBOL, GoogleSQLParserPRIVILEGES_SYMBOL, GoogleSQLParserPROCEDURE_SYMBOL, GoogleSQLParserPROJECT_SYMBOL, GoogleSQLParserPUBLIC_SYMBOL, GoogleSQLParserRAISE_SYMBOL, GoogleSQLParserREAD_SYMBOL, GoogleSQLParserREFERENCES_SYMBOL, GoogleSQLParserREMOTE_SYMBOL, GoogleSQLParserREMOVE_SYMBOL, GoogleSQLParserRENAME_SYMBOL, GoogleSQLParserREPEAT_SYMBOL, GoogleSQLParserREPEATABLE_SYMBOL, GoogleSQLParserREPLACE_FIELDS_SYMBOL, GoogleSQLParserREPLICA_SYMBOL, GoogleSQLParserREPORT_SYMBOL, GoogleSQLParserRESTRICT_SYMBOL, GoogleSQLParserRESTRICTION_SYMBOL, GoogleSQLParserRETURNS_SYMBOL, GoogleSQLParserRETURN_SYMBOL, GoogleSQLParserREVOKE_SYMBOL, GoogleSQLParserROLLBACK_SYMBOL, GoogleSQLParserROW_SYMBOL, GoogleSQLParserRUN_SYMBOL, GoogleSQLParserSAFE_CAST_SYMBOL, GoogleSQLParserSCHEMA_SYMBOL, GoogleSQLParserSEARCH_SYMBOL, GoogleSQLParserSECURITY_SYMBOL, GoogleSQLParserSEQUENCE_SYMBOL, GoogleSQLParserSETS_SYMBOL, GoogleSQLParserSHOW_SYMBOL, GoogleSQLParserSNAPSHOT_SYMBOL, GoogleSQLParserSOURCE_SYMBOL, GoogleSQLParserSQL_SYMBOL, GoogleSQLParserSTABLE_SYMBOL, GoogleSQLParserSTART_SYMBOL, GoogleSQLParserSTATIC_DESCRIBE_SYMBOL, GoogleSQLParserSTORED_SYMBOL, GoogleSQLParserSTORING_SYMBOL, GoogleSQLParserSTRICT_SYMBOL, GoogleSQLParserTABLE_SYMBOL, GoogleSQLParserTABLES_SYMBOL, GoogleSQLParserTARGET_SYMBOL, GoogleSQLParserTEMP_SYMBOL, GoogleSQLParserTEMPORARY_SYMBOL, GoogleSQLParserTRANSACTION_SYMBOL, GoogleSQLParserTRANSFORM_SYMBOL, GoogleSQLParserTRUNCATE_SYMBOL, GoogleSQLParserTYPE_SYMBOL, GoogleSQLParserUNDROP_SYMBOL, GoogleSQLParserUNIQUE_SYMBOL, GoogleSQLParserUNKNOWN_SYMBOL, GoogleSQLParserUNTIL_SYMBOL, GoogleSQLParserUPDATE_SYMBOL, GoogleSQLParserVALUES_SYMBOL, GoogleSQLParserVECTOR_SYMBOL, GoogleSQLParserVIEW_SYMBOL, GoogleSQLParserVIEWS_SYMBOL, GoogleSQLParserVOLATILE_SYMBOL, GoogleSQLParserWEIGHT_SYMBOL, GoogleSQLParserWHILE_SYMBOL, GoogleSQLParserWRITE_SYMBOL, GoogleSQLParserZONE_SYMBOL, GoogleSQLParserDESCRIPTOR_SYMBOL, GoogleSQLParserINTERLEAVE_SYMBOL, GoogleSQLParserNULL_FILTERED_SYMBOL, GoogleSQLParserPARENT_SYMBOL, GoogleSQLParserIF_SYMBOL, GoogleSQLParserSLASH_SYMBOL, GoogleSQLParserLR_BRACKET_SYMBOL, GoogleSQLParserIDENTIFIER:
		{
			p.SetState(996)
			p.table_primary(0)
		}


	case GoogleSQLParserAT_SYMBOL:
		{
			p.SetState(997)
			p.Match(GoogleSQLParserAT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.NotifyErrorListeners("Query parameters cannot be used in place of table names",nil,nil)
				


	case GoogleSQLParserQUESTION_SYMBOL:
		{
			p.SetState(999)
			p.Match(GoogleSQLParserQUESTION_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.NotifyErrorListeners("Query parameters cannot be used in place of table names",nil,nil)
				


	case GoogleSQLParserATAT_SYMBOL:
		{
			p.SetState(1001)
			p.Match(GoogleSQLParserATAT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.NotifyErrorListeners("System variables cannot be used in place of table names",nil,nil)
				



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1018)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1016)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) {
			case 1:
				localctx = NewFrom_clause_contentsContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_from_clause_contents)
				p.SetState(1005)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(1006)
					p.Match(GoogleSQLParserCOMMA_SYMBOL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(1007)
					p.table_primary(0)
				}


			case 2:
				localctx = NewFrom_clause_contentsContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_from_clause_contents)
				p.SetState(1008)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				p.SetState(1010)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				if _la == GoogleSQLParserNATURAL_SYMBOL {
					{
						p.SetState(1009)
						p.Opt_natural()
					}

				}
				p.SetState(1013)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 68724850752) != 0) {
					{
						p.SetState(1012)
						p.Join_type()
					}

				}
				{
					p.SetState(1015)
					p.Join_hint()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1020)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_primaryContext is an interface to support dynamic dispatch.
type ITable_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Tvf_with_suffixes() ITvf_with_suffixesContext
	Table_path_expression() ITable_path_expressionContext
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Join() IJoinContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	Table_subquery() ITable_subqueryContext
	Table_primary() ITable_primaryContext
	Match_recognize_clause() IMatch_recognize_clauseContext
	Sample_clause() ISample_clauseContext

	// IsTable_primaryContext differentiates from other interfaces.
	IsTable_primaryContext()
}

type Table_primaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_primaryContext() *Table_primaryContext {
	var p = new(Table_primaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_table_primary
	return p
}

func InitEmptyTable_primaryContext(p *Table_primaryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_table_primary
}

func (*Table_primaryContext) IsTable_primaryContext() {}

func NewTable_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_primaryContext {
	var p = new(Table_primaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_table_primary

	return p
}

func (s *Table_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_primaryContext) Tvf_with_suffixes() ITvf_with_suffixesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITvf_with_suffixesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITvf_with_suffixesContext)
}

func (s *Table_primaryContext) Table_path_expression() ITable_path_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_path_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_path_expressionContext)
}

func (s *Table_primaryContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Table_primaryContext) Join() IJoinContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinContext)
}

func (s *Table_primaryContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Table_primaryContext) Table_subquery() ITable_subqueryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_subqueryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_subqueryContext)
}

func (s *Table_primaryContext) Table_primary() ITable_primaryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_primaryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_primaryContext)
}

func (s *Table_primaryContext) Match_recognize_clause() IMatch_recognize_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatch_recognize_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatch_recognize_clauseContext)
}

func (s *Table_primaryContext) Sample_clause() ISample_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISample_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISample_clauseContext)
}

func (s *Table_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterTable_primary(s)
	}
}

func (s *Table_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitTable_primary(s)
	}
}

func (s *Table_primaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitTable_primary(s)

	default:
		return t.VisitChildren(s)
	}
}





func (p *GoogleSQLParser) Table_primary() (localctx ITable_primaryContext) {
	return p.table_primary(0)
}

func (p *GoogleSQLParser) table_primary(_p int) (localctx ITable_primaryContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewTable_primaryContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITable_primaryContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 100
	p.EnterRecursionRule(localctx, 100, GoogleSQLParserRULE_table_primary, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1029)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1022)
			p.Tvf_with_suffixes()
		}


	case 2:
		{
			p.SetState(1023)
			p.Table_path_expression()
		}


	case 3:
		{
			p.SetState(1024)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1025)
			p.Join()
		}
		{
			p.SetState(1026)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		{
			p.SetState(1028)
			p.Table_subquery()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1037)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1035)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) {
			case 1:
				localctx = NewTable_primaryContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_table_primary)
				p.SetState(1031)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(1032)
					p.Match_recognize_clause()
				}


			case 2:
				localctx = NewTable_primaryContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_table_primary)
				p.SetState(1033)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(1034)
					p.Sample_clause()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1039)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITvf_with_suffixesContext is an interface to support dynamic dispatch.
type ITvf_with_suffixesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Tvf_prefix_no_args() ITvf_prefix_no_argsContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	Hint() IHintContext
	Pivot_or_unpivot_clause_and_aliases() IPivot_or_unpivot_clause_and_aliasesContext
	Tvf_prefix() ITvf_prefixContext

	// IsTvf_with_suffixesContext differentiates from other interfaces.
	IsTvf_with_suffixesContext()
}

type Tvf_with_suffixesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTvf_with_suffixesContext() *Tvf_with_suffixesContext {
	var p = new(Tvf_with_suffixesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_tvf_with_suffixes
	return p
}

func InitEmptyTvf_with_suffixesContext(p *Tvf_with_suffixesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_tvf_with_suffixes
}

func (*Tvf_with_suffixesContext) IsTvf_with_suffixesContext() {}

func NewTvf_with_suffixesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tvf_with_suffixesContext {
	var p = new(Tvf_with_suffixesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_tvf_with_suffixes

	return p
}

func (s *Tvf_with_suffixesContext) GetParser() antlr.Parser { return s.parser }

func (s *Tvf_with_suffixesContext) Tvf_prefix_no_args() ITvf_prefix_no_argsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITvf_prefix_no_argsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITvf_prefix_no_argsContext)
}

func (s *Tvf_with_suffixesContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Tvf_with_suffixesContext) Hint() IHintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintContext)
}

func (s *Tvf_with_suffixesContext) Pivot_or_unpivot_clause_and_aliases() IPivot_or_unpivot_clause_and_aliasesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivot_or_unpivot_clause_and_aliasesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivot_or_unpivot_clause_and_aliasesContext)
}

func (s *Tvf_with_suffixesContext) Tvf_prefix() ITvf_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITvf_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITvf_prefixContext)
}

func (s *Tvf_with_suffixesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tvf_with_suffixesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Tvf_with_suffixesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterTvf_with_suffixes(s)
	}
}

func (s *Tvf_with_suffixesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitTvf_with_suffixes(s)
	}
}

func (s *Tvf_with_suffixesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitTvf_with_suffixes(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Tvf_with_suffixes() (localctx ITvf_with_suffixesContext) {
	localctx = NewTvf_with_suffixesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, GoogleSQLParserRULE_tvf_with_suffixes)
	p.SetState(1056)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1040)
			p.Tvf_prefix_no_args()
		}
		{
			p.SetState(1041)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1043)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1042)
				p.Hint()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(1046)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1045)
				p.Pivot_or_unpivot_clause_and_aliases()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1048)
			p.Tvf_prefix()
		}
		{
			p.SetState(1049)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1051)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1050)
				p.Hint()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(1054)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1053)
				p.Pivot_or_unpivot_clause_and_aliases()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPivot_or_unpivot_clause_and_aliasesContext is an interface to support dynamic dispatch.
type IPivot_or_unpivot_clause_and_aliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	Pivot_clause() IPivot_clauseContext
	As_alias() IAs_aliasContext
	Unpivot_clause() IUnpivot_clauseContext
	Qualify_clause_nonreserved() IQualify_clause_nonreservedContext

	// IsPivot_or_unpivot_clause_and_aliasesContext differentiates from other interfaces.
	IsPivot_or_unpivot_clause_and_aliasesContext()
}

type Pivot_or_unpivot_clause_and_aliasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivot_or_unpivot_clause_and_aliasesContext() *Pivot_or_unpivot_clause_and_aliasesContext {
	var p = new(Pivot_or_unpivot_clause_and_aliasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_pivot_or_unpivot_clause_and_aliases
	return p
}

func InitEmptyPivot_or_unpivot_clause_and_aliasesContext(p *Pivot_or_unpivot_clause_and_aliasesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_pivot_or_unpivot_clause_and_aliases
}

func (*Pivot_or_unpivot_clause_and_aliasesContext) IsPivot_or_unpivot_clause_and_aliasesContext() {}

func NewPivot_or_unpivot_clause_and_aliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pivot_or_unpivot_clause_and_aliasesContext {
	var p = new(Pivot_or_unpivot_clause_and_aliasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_pivot_or_unpivot_clause_and_aliases

	return p
}

func (s *Pivot_or_unpivot_clause_and_aliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *Pivot_or_unpivot_clause_and_aliasesContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAS_SYMBOL, 0)
}

func (s *Pivot_or_unpivot_clause_and_aliasesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Pivot_or_unpivot_clause_and_aliasesContext) Pivot_clause() IPivot_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivot_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivot_clauseContext)
}

func (s *Pivot_or_unpivot_clause_and_aliasesContext) As_alias() IAs_aliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAs_aliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAs_aliasContext)
}

func (s *Pivot_or_unpivot_clause_and_aliasesContext) Unpivot_clause() IUnpivot_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivot_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivot_clauseContext)
}

func (s *Pivot_or_unpivot_clause_and_aliasesContext) Qualify_clause_nonreserved() IQualify_clause_nonreservedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualify_clause_nonreservedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualify_clause_nonreservedContext)
}

func (s *Pivot_or_unpivot_clause_and_aliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pivot_or_unpivot_clause_and_aliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Pivot_or_unpivot_clause_and_aliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterPivot_or_unpivot_clause_and_aliases(s)
	}
}

func (s *Pivot_or_unpivot_clause_and_aliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitPivot_or_unpivot_clause_and_aliases(s)
	}
}

func (s *Pivot_or_unpivot_clause_and_aliasesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitPivot_or_unpivot_clause_and_aliases(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Pivot_or_unpivot_clause_and_aliases() (localctx IPivot_or_unpivot_clause_and_aliasesContext) {
	localctx = NewPivot_or_unpivot_clause_and_aliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, GoogleSQLParserRULE_pivot_or_unpivot_clause_and_aliases)
	p.SetState(1101)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1058)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1059)
			p.Identifier()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1060)
			p.Identifier()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1061)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1062)
			p.Identifier()
		}
		{
			p.SetState(1063)
			p.Pivot_clause()
		}
		p.SetState(1065)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1064)
				p.As_alias()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1067)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1068)
			p.Identifier()
		}
		{
			p.SetState(1069)
			p.Unpivot_clause()
		}
		p.SetState(1071)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1070)
				p.As_alias()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1073)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1074)
			p.Identifier()
		}
		{
			p.SetState(1075)
			p.Qualify_clause_nonreserved()
		}

						 p.NotifyErrorListeners("QUALIFY clause must be used in conjunction with WHERE or GROUP BY " "or HAVING clause", nil, nil); 
				


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1078)
			p.Identifier()
		}
		{
			p.SetState(1079)
			p.Pivot_clause()
		}
		{
			p.SetState(1080)
			p.As_alias()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1082)
			p.Identifier()
		}
		{
			p.SetState(1083)
			p.Unpivot_clause()
		}
		{
			p.SetState(1084)
			p.As_alias()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1086)
			p.Identifier()
		}
		{
			p.SetState(1087)
			p.Qualify_clause_nonreserved()
		}

						 p.NotifyErrorListeners("QUALIFY clause must be used in conjunction with WHERE or GROUP BY " "or HAVING clause", nil, nil); 
				


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1090)
			p.Pivot_clause()
		}
		p.SetState(1092)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1091)
				p.As_alias()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1094)
			p.Unpivot_clause()
		}
		p.SetState(1096)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1095)
				p.As_alias()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1098)
			p.Qualify_clause_nonreserved()
		}

						 p.NotifyErrorListeners("QUALIFY clause must be used in conjunction with WHERE or GROUP BY " "or HAVING clause", nil, nil); 
				

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISample_clauseContext is an interface to support dynamic dispatch.
type ISample_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLESAMPLE_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Sample_size() ISample_sizeContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	Opt_sample_clause_suffix() IOpt_sample_clause_suffixContext

	// IsSample_clauseContext differentiates from other interfaces.
	IsSample_clauseContext()
}

type Sample_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySample_clauseContext() *Sample_clauseContext {
	var p = new(Sample_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_sample_clause
	return p
}

func InitEmptySample_clauseContext(p *Sample_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_sample_clause
}

func (*Sample_clauseContext) IsSample_clauseContext() {}

func NewSample_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sample_clauseContext {
	var p = new(Sample_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_sample_clause

	return p
}

func (s *Sample_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Sample_clauseContext) TABLESAMPLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTABLESAMPLE_SYMBOL, 0)
}

func (s *Sample_clauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Sample_clauseContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Sample_clauseContext) Sample_size() ISample_sizeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISample_sizeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISample_sizeContext)
}

func (s *Sample_clauseContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Sample_clauseContext) Opt_sample_clause_suffix() IOpt_sample_clause_suffixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_sample_clause_suffixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_sample_clause_suffixContext)
}

func (s *Sample_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sample_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Sample_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSample_clause(s)
	}
}

func (s *Sample_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSample_clause(s)
	}
}

func (s *Sample_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSample_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Sample_clause() (localctx ISample_clauseContext) {
	localctx = NewSample_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, GoogleSQLParserRULE_sample_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1103)
		p.Match(GoogleSQLParserTABLESAMPLE_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1104)
		p.Identifier()
	}
	{
		p.SetState(1105)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1106)
		p.Sample_size()
	}
	{
		p.SetState(1107)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1108)
		p.Opt_sample_clause_suffix()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_sample_clause_suffixContext is an interface to support dynamic dispatch.
type IOpt_sample_clause_suffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Repeatable_clause() IRepeatable_clauseContext
	WITH_SYMBOL() antlr.TerminalNode
	WEIGHT_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	AS_SYMBOL() antlr.TerminalNode

	// IsOpt_sample_clause_suffixContext differentiates from other interfaces.
	IsOpt_sample_clause_suffixContext()
}

type Opt_sample_clause_suffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_sample_clause_suffixContext() *Opt_sample_clause_suffixContext {
	var p = new(Opt_sample_clause_suffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_sample_clause_suffix
	return p
}

func InitEmptyOpt_sample_clause_suffixContext(p *Opt_sample_clause_suffixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_sample_clause_suffix
}

func (*Opt_sample_clause_suffixContext) IsOpt_sample_clause_suffixContext() {}

func NewOpt_sample_clause_suffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_sample_clause_suffixContext {
	var p = new(Opt_sample_clause_suffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_sample_clause_suffix

	return p
}

func (s *Opt_sample_clause_suffixContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_sample_clause_suffixContext) Repeatable_clause() IRepeatable_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepeatable_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepeatable_clauseContext)
}

func (s *Opt_sample_clause_suffixContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWITH_SYMBOL, 0)
}

func (s *Opt_sample_clause_suffixContext) WEIGHT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWEIGHT_SYMBOL, 0)
}

func (s *Opt_sample_clause_suffixContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Opt_sample_clause_suffixContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAS_SYMBOL, 0)
}

func (s *Opt_sample_clause_suffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_sample_clause_suffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_sample_clause_suffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_sample_clause_suffix(s)
	}
}

func (s *Opt_sample_clause_suffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_sample_clause_suffix(s)
	}
}

func (s *Opt_sample_clause_suffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_sample_clause_suffix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_sample_clause_suffix() (localctx IOpt_sample_clause_suffixContext) {
	localctx = NewOpt_sample_clause_suffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, GoogleSQLParserRULE_opt_sample_clause_suffix)
	p.SetState(1129)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1110)
			p.Repeatable_clause()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1111)
			p.Match(GoogleSQLParserWITH_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1112)
			p.Match(GoogleSQLParserWEIGHT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1114)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1113)
				p.Repeatable_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1116)
			p.Match(GoogleSQLParserWITH_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1117)
			p.Match(GoogleSQLParserWEIGHT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1118)
			p.Identifier()
		}
		p.SetState(1120)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1119)
				p.Repeatable_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1122)
			p.Match(GoogleSQLParserWITH_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1123)
			p.Match(GoogleSQLParserWEIGHT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1124)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1125)
			p.Identifier()
		}
		p.SetState(1127)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1126)
				p.Repeatable_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRepeatable_clauseContext is an interface to support dynamic dispatch.
type IRepeatable_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPEATABLE_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Possibly_cast_int_literal_or_parameter() IPossibly_cast_int_literal_or_parameterContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsRepeatable_clauseContext differentiates from other interfaces.
	IsRepeatable_clauseContext()
}

type Repeatable_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeatable_clauseContext() *Repeatable_clauseContext {
	var p = new(Repeatable_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_repeatable_clause
	return p
}

func InitEmptyRepeatable_clauseContext(p *Repeatable_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_repeatable_clause
}

func (*Repeatable_clauseContext) IsRepeatable_clauseContext() {}

func NewRepeatable_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Repeatable_clauseContext {
	var p = new(Repeatable_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_repeatable_clause

	return p
}

func (s *Repeatable_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Repeatable_clauseContext) REPEATABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserREPEATABLE_SYMBOL, 0)
}

func (s *Repeatable_clauseContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Repeatable_clauseContext) Possibly_cast_int_literal_or_parameter() IPossibly_cast_int_literal_or_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPossibly_cast_int_literal_or_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPossibly_cast_int_literal_or_parameterContext)
}

func (s *Repeatable_clauseContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Repeatable_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Repeatable_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Repeatable_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterRepeatable_clause(s)
	}
}

func (s *Repeatable_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitRepeatable_clause(s)
	}
}

func (s *Repeatable_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitRepeatable_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Repeatable_clause() (localctx IRepeatable_clauseContext) {
	localctx = NewRepeatable_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, GoogleSQLParserRULE_repeatable_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1131)
		p.Match(GoogleSQLParserREPEATABLE_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1132)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1133)
		p.Possibly_cast_int_literal_or_parameter()
	}
	{
		p.SetState(1134)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPossibly_cast_int_literal_or_parameterContext is an interface to support dynamic dispatch.
type IPossibly_cast_int_literal_or_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Cast_int_literal_or_parameter() ICast_int_literal_or_parameterContext
	Int_literal_or_parameter() IInt_literal_or_parameterContext

	// IsPossibly_cast_int_literal_or_parameterContext differentiates from other interfaces.
	IsPossibly_cast_int_literal_or_parameterContext()
}

type Possibly_cast_int_literal_or_parameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPossibly_cast_int_literal_or_parameterContext() *Possibly_cast_int_literal_or_parameterContext {
	var p = new(Possibly_cast_int_literal_or_parameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_possibly_cast_int_literal_or_parameter
	return p
}

func InitEmptyPossibly_cast_int_literal_or_parameterContext(p *Possibly_cast_int_literal_or_parameterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_possibly_cast_int_literal_or_parameter
}

func (*Possibly_cast_int_literal_or_parameterContext) IsPossibly_cast_int_literal_or_parameterContext() {}

func NewPossibly_cast_int_literal_or_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Possibly_cast_int_literal_or_parameterContext {
	var p = new(Possibly_cast_int_literal_or_parameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_possibly_cast_int_literal_or_parameter

	return p
}

func (s *Possibly_cast_int_literal_or_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Possibly_cast_int_literal_or_parameterContext) Cast_int_literal_or_parameter() ICast_int_literal_or_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICast_int_literal_or_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICast_int_literal_or_parameterContext)
}

func (s *Possibly_cast_int_literal_or_parameterContext) Int_literal_or_parameter() IInt_literal_or_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_literal_or_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_literal_or_parameterContext)
}

func (s *Possibly_cast_int_literal_or_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Possibly_cast_int_literal_or_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Possibly_cast_int_literal_or_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterPossibly_cast_int_literal_or_parameter(s)
	}
}

func (s *Possibly_cast_int_literal_or_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitPossibly_cast_int_literal_or_parameter(s)
	}
}

func (s *Possibly_cast_int_literal_or_parameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitPossibly_cast_int_literal_or_parameter(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Possibly_cast_int_literal_or_parameter() (localctx IPossibly_cast_int_literal_or_parameterContext) {
	localctx = NewPossibly_cast_int_literal_or_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, GoogleSQLParserRULE_possibly_cast_int_literal_or_parameter)
	p.SetState(1138)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserCAST_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1136)
			p.Cast_int_literal_or_parameter()
		}


	case GoogleSQLParserQUESTION_SYMBOL, GoogleSQLParserAT_SYMBOL, GoogleSQLParserATAT_SYMBOL, GoogleSQLParserINTEGER_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1137)
			p.Int_literal_or_parameter()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICast_int_literal_or_parameterContext is an interface to support dynamic dispatch.
type ICast_int_literal_or_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CAST_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Int_literal_or_parameter() IInt_literal_or_parameterContext
	AS_SYMBOL() antlr.TerminalNode
	Type_() ITypeContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	Opt_format() IOpt_formatContext

	// IsCast_int_literal_or_parameterContext differentiates from other interfaces.
	IsCast_int_literal_or_parameterContext()
}

type Cast_int_literal_or_parameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCast_int_literal_or_parameterContext() *Cast_int_literal_or_parameterContext {
	var p = new(Cast_int_literal_or_parameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_cast_int_literal_or_parameter
	return p
}

func InitEmptyCast_int_literal_or_parameterContext(p *Cast_int_literal_or_parameterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_cast_int_literal_or_parameter
}

func (*Cast_int_literal_or_parameterContext) IsCast_int_literal_or_parameterContext() {}

func NewCast_int_literal_or_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cast_int_literal_or_parameterContext {
	var p = new(Cast_int_literal_or_parameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_cast_int_literal_or_parameter

	return p
}

func (s *Cast_int_literal_or_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Cast_int_literal_or_parameterContext) CAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCAST_SYMBOL, 0)
}

func (s *Cast_int_literal_or_parameterContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Cast_int_literal_or_parameterContext) Int_literal_or_parameter() IInt_literal_or_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_literal_or_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_literal_or_parameterContext)
}

func (s *Cast_int_literal_or_parameterContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAS_SYMBOL, 0)
}

func (s *Cast_int_literal_or_parameterContext) Type_() ITypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Cast_int_literal_or_parameterContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Cast_int_literal_or_parameterContext) Opt_format() IOpt_formatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_formatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_formatContext)
}

func (s *Cast_int_literal_or_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cast_int_literal_or_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Cast_int_literal_or_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterCast_int_literal_or_parameter(s)
	}
}

func (s *Cast_int_literal_or_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitCast_int_literal_or_parameter(s)
	}
}

func (s *Cast_int_literal_or_parameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitCast_int_literal_or_parameter(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Cast_int_literal_or_parameter() (localctx ICast_int_literal_or_parameterContext) {
	localctx = NewCast_int_literal_or_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, GoogleSQLParserRULE_cast_int_literal_or_parameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1140)
		p.Match(GoogleSQLParserCAST_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1141)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1142)
		p.Int_literal_or_parameter()
	}
	{
		p.SetState(1143)
		p.Match(GoogleSQLParserAS_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1144)
		p.Type_()
	}
	p.SetState(1146)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserFORMAT_SYMBOL {
		{
			p.SetState(1145)
			p.Opt_format()
		}

	}
	{
		p.SetState(1148)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISample_sizeContext is an interface to support dynamic dispatch.
type ISample_sizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Sample_size_value() ISample_size_valueContext
	Sample_size_unit() ISample_size_unitContext
	Partition_by_clause_prefix_no_hint() IPartition_by_clause_prefix_no_hintContext

	// IsSample_sizeContext differentiates from other interfaces.
	IsSample_sizeContext()
}

type Sample_sizeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySample_sizeContext() *Sample_sizeContext {
	var p = new(Sample_sizeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_sample_size
	return p
}

func InitEmptySample_sizeContext(p *Sample_sizeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_sample_size
}

func (*Sample_sizeContext) IsSample_sizeContext() {}

func NewSample_sizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sample_sizeContext {
	var p = new(Sample_sizeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_sample_size

	return p
}

func (s *Sample_sizeContext) GetParser() antlr.Parser { return s.parser }

func (s *Sample_sizeContext) Sample_size_value() ISample_size_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISample_size_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISample_size_valueContext)
}

func (s *Sample_sizeContext) Sample_size_unit() ISample_size_unitContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISample_size_unitContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISample_size_unitContext)
}

func (s *Sample_sizeContext) Partition_by_clause_prefix_no_hint() IPartition_by_clause_prefix_no_hintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartition_by_clause_prefix_no_hintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartition_by_clause_prefix_no_hintContext)
}

func (s *Sample_sizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sample_sizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Sample_sizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSample_size(s)
	}
}

func (s *Sample_sizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSample_size(s)
	}
}

func (s *Sample_sizeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSample_size(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Sample_size() (localctx ISample_sizeContext) {
	localctx = NewSample_sizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, GoogleSQLParserRULE_sample_size)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1150)
		p.Sample_size_value()
	}
	{
		p.SetState(1151)
		p.Sample_size_unit()
	}
	p.SetState(1153)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserPARTITION_SYMBOL {
		{
			p.SetState(1152)
			p.Partition_by_clause_prefix_no_hint()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISample_size_valueContext is an interface to support dynamic dispatch.
type ISample_size_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Possibly_cast_int_literal_or_parameter() IPossibly_cast_int_literal_or_parameterContext
	Floating_point_literal() IFloating_point_literalContext

	// IsSample_size_valueContext differentiates from other interfaces.
	IsSample_size_valueContext()
}

type Sample_size_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySample_size_valueContext() *Sample_size_valueContext {
	var p = new(Sample_size_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_sample_size_value
	return p
}

func InitEmptySample_size_valueContext(p *Sample_size_valueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_sample_size_value
}

func (*Sample_size_valueContext) IsSample_size_valueContext() {}

func NewSample_size_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sample_size_valueContext {
	var p = new(Sample_size_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_sample_size_value

	return p
}

func (s *Sample_size_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Sample_size_valueContext) Possibly_cast_int_literal_or_parameter() IPossibly_cast_int_literal_or_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPossibly_cast_int_literal_or_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPossibly_cast_int_literal_or_parameterContext)
}

func (s *Sample_size_valueContext) Floating_point_literal() IFloating_point_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloating_point_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloating_point_literalContext)
}

func (s *Sample_size_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sample_size_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Sample_size_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSample_size_value(s)
	}
}

func (s *Sample_size_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSample_size_value(s)
	}
}

func (s *Sample_size_valueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSample_size_value(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Sample_size_value() (localctx ISample_size_valueContext) {
	localctx = NewSample_size_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, GoogleSQLParserRULE_sample_size_value)
	p.SetState(1157)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserCAST_SYMBOL, GoogleSQLParserQUESTION_SYMBOL, GoogleSQLParserAT_SYMBOL, GoogleSQLParserATAT_SYMBOL, GoogleSQLParserINTEGER_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1155)
			p.Possibly_cast_int_literal_or_parameter()
		}


	case GoogleSQLParserFLOAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1156)
			p.Floating_point_literal()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISample_size_unitContext is an interface to support dynamic dispatch.
type ISample_size_unitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROWS_SYMBOL() antlr.TerminalNode
	PERCENT_SYMBOL() antlr.TerminalNode

	// IsSample_size_unitContext differentiates from other interfaces.
	IsSample_size_unitContext()
}

type Sample_size_unitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySample_size_unitContext() *Sample_size_unitContext {
	var p = new(Sample_size_unitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_sample_size_unit
	return p
}

func InitEmptySample_size_unitContext(p *Sample_size_unitContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_sample_size_unit
}

func (*Sample_size_unitContext) IsSample_size_unitContext() {}

func NewSample_size_unitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sample_size_unitContext {
	var p = new(Sample_size_unitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_sample_size_unit

	return p
}

func (s *Sample_size_unitContext) GetParser() antlr.Parser { return s.parser }

func (s *Sample_size_unitContext) ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserROWS_SYMBOL, 0)
}

func (s *Sample_size_unitContext) PERCENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPERCENT_SYMBOL, 0)
}

func (s *Sample_size_unitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sample_size_unitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Sample_size_unitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSample_size_unit(s)
	}
}

func (s *Sample_size_unitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSample_size_unit(s)
	}
}

func (s *Sample_size_unitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSample_size_unit(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Sample_size_unit() (localctx ISample_size_unitContext) {
	localctx = NewSample_size_unitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, GoogleSQLParserRULE_sample_size_unit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1159)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GoogleSQLParserPERCENT_SYMBOL || _la == GoogleSQLParserROWS_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartition_by_clause_prefix_no_hintContext is an interface to support dynamic dispatch.
type IPartition_by_clause_prefix_no_hintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsPartition_by_clause_prefix_no_hintContext differentiates from other interfaces.
	IsPartition_by_clause_prefix_no_hintContext()
}

type Partition_by_clause_prefix_no_hintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartition_by_clause_prefix_no_hintContext() *Partition_by_clause_prefix_no_hintContext {
	var p = new(Partition_by_clause_prefix_no_hintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_partition_by_clause_prefix_no_hint
	return p
}

func InitEmptyPartition_by_clause_prefix_no_hintContext(p *Partition_by_clause_prefix_no_hintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_partition_by_clause_prefix_no_hint
}

func (*Partition_by_clause_prefix_no_hintContext) IsPartition_by_clause_prefix_no_hintContext() {}

func NewPartition_by_clause_prefix_no_hintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Partition_by_clause_prefix_no_hintContext {
	var p = new(Partition_by_clause_prefix_no_hintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_partition_by_clause_prefix_no_hint

	return p
}

func (s *Partition_by_clause_prefix_no_hintContext) GetParser() antlr.Parser { return s.parser }

func (s *Partition_by_clause_prefix_no_hintContext) PARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPARTITION_SYMBOL, 0)
}

func (s *Partition_by_clause_prefix_no_hintContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserBY_SYMBOL, 0)
}

func (s *Partition_by_clause_prefix_no_hintContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Partition_by_clause_prefix_no_hintContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Partition_by_clause_prefix_no_hintContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Partition_by_clause_prefix_no_hintContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Partition_by_clause_prefix_no_hintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Partition_by_clause_prefix_no_hintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Partition_by_clause_prefix_no_hintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterPartition_by_clause_prefix_no_hint(s)
	}
}

func (s *Partition_by_clause_prefix_no_hintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitPartition_by_clause_prefix_no_hint(s)
	}
}

func (s *Partition_by_clause_prefix_no_hintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitPartition_by_clause_prefix_no_hint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Partition_by_clause_prefix_no_hint() (localctx IPartition_by_clause_prefix_no_hintContext) {
	localctx = NewPartition_by_clause_prefix_no_hintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, GoogleSQLParserRULE_partition_by_clause_prefix_no_hint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1161)
		p.Match(GoogleSQLParserPARTITION_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1162)
		p.Match(GoogleSQLParserBY_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1163)
		p.expression(0)
	}
	p.SetState(1168)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(1164)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1165)
			p.expression(0)
		}


		p.SetState(1170)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMatch_recognize_clauseContext is an interface to support dynamic dispatch.
type IMatch_recognize_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MATCH_RECOGNIZE_SYMBOL() antlr.TerminalNode
	AllLR_BRACKET_SYMBOL() []antlr.TerminalNode
	LR_BRACKET_SYMBOL(i int) antlr.TerminalNode
	Order_by_clause() IOrder_by_clauseContext
	MEASURES_SYMBOL() antlr.TerminalNode
	Select_list_prefix_with_as_aliases() ISelect_list_prefix_with_as_aliasesContext
	PATTERN_SYMBOL() antlr.TerminalNode
	Row_pattern_expr() IRow_pattern_exprContext
	AllRR_BRACKET_SYMBOL() []antlr.TerminalNode
	RR_BRACKET_SYMBOL(i int) antlr.TerminalNode
	DEFINE_SYMBOL() antlr.TerminalNode
	With_expression_variable_prefix() IWith_expression_variable_prefixContext
	Partition_by_clause_prefix() IPartition_by_clause_prefixContext
	As_alias() IAs_aliasContext

	// IsMatch_recognize_clauseContext differentiates from other interfaces.
	IsMatch_recognize_clauseContext()
}

type Match_recognize_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatch_recognize_clauseContext() *Match_recognize_clauseContext {
	var p = new(Match_recognize_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_match_recognize_clause
	return p
}

func InitEmptyMatch_recognize_clauseContext(p *Match_recognize_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_match_recognize_clause
}

func (*Match_recognize_clauseContext) IsMatch_recognize_clauseContext() {}

func NewMatch_recognize_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Match_recognize_clauseContext {
	var p = new(Match_recognize_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_match_recognize_clause

	return p
}

func (s *Match_recognize_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Match_recognize_clauseContext) MATCH_RECOGNIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMATCH_RECOGNIZE_SYMBOL, 0)
}

func (s *Match_recognize_clauseContext) AllLR_BRACKET_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserLR_BRACKET_SYMBOL)
}

func (s *Match_recognize_clauseContext) LR_BRACKET_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, i)
}

func (s *Match_recognize_clauseContext) Order_by_clause() IOrder_by_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Match_recognize_clauseContext) MEASURES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMEASURES_SYMBOL, 0)
}

func (s *Match_recognize_clauseContext) Select_list_prefix_with_as_aliases() ISelect_list_prefix_with_as_aliasesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_list_prefix_with_as_aliasesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_list_prefix_with_as_aliasesContext)
}

func (s *Match_recognize_clauseContext) PATTERN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPATTERN_SYMBOL, 0)
}

func (s *Match_recognize_clauseContext) Row_pattern_expr() IRow_pattern_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_exprContext)
}

func (s *Match_recognize_clauseContext) AllRR_BRACKET_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserRR_BRACKET_SYMBOL)
}

func (s *Match_recognize_clauseContext) RR_BRACKET_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, i)
}

func (s *Match_recognize_clauseContext) DEFINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDEFINE_SYMBOL, 0)
}

func (s *Match_recognize_clauseContext) With_expression_variable_prefix() IWith_expression_variable_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_expression_variable_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_expression_variable_prefixContext)
}

func (s *Match_recognize_clauseContext) Partition_by_clause_prefix() IPartition_by_clause_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartition_by_clause_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartition_by_clause_prefixContext)
}

func (s *Match_recognize_clauseContext) As_alias() IAs_aliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAs_aliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAs_aliasContext)
}

func (s *Match_recognize_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Match_recognize_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Match_recognize_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterMatch_recognize_clause(s)
	}
}

func (s *Match_recognize_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitMatch_recognize_clause(s)
	}
}

func (s *Match_recognize_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitMatch_recognize_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Match_recognize_clause() (localctx IMatch_recognize_clauseContext) {
	localctx = NewMatch_recognize_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, GoogleSQLParserRULE_match_recognize_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1171)
		p.Match(GoogleSQLParserMATCH_RECOGNIZE_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1172)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1174)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserPARTITION_SYMBOL {
		{
			p.SetState(1173)
			p.Partition_by_clause_prefix()
		}

	}
	{
		p.SetState(1176)
		p.Order_by_clause()
	}
	{
		p.SetState(1177)
		p.Match(GoogleSQLParserMEASURES_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1178)
		p.Select_list_prefix_with_as_aliases()
	}
	{
		p.SetState(1179)
		p.Match(GoogleSQLParserPATTERN_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1180)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1181)
		p.row_pattern_expr(0)
	}
	{
		p.SetState(1182)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1183)
		p.Match(GoogleSQLParserDEFINE_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1184)
		p.With_expression_variable_prefix()
	}
	{
		p.SetState(1185)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1187)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1186)
			p.As_alias()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_exprContext is an interface to support dynamic dispatch.
type IRow_pattern_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Row_pattern_concatenation() IRow_pattern_concatenationContext
	Row_pattern_expr() IRow_pattern_exprContext
	STROKE_SYMBOL() antlr.TerminalNode

	// IsRow_pattern_exprContext differentiates from other interfaces.
	IsRow_pattern_exprContext()
}

type Row_pattern_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_exprContext() *Row_pattern_exprContext {
	var p = new(Row_pattern_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_row_pattern_expr
	return p
}

func InitEmptyRow_pattern_exprContext(p *Row_pattern_exprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_row_pattern_expr
}

func (*Row_pattern_exprContext) IsRow_pattern_exprContext() {}

func NewRow_pattern_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_exprContext {
	var p = new(Row_pattern_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_row_pattern_expr

	return p
}

func (s *Row_pattern_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_exprContext) Row_pattern_concatenation() IRow_pattern_concatenationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_concatenationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_concatenationContext)
}

func (s *Row_pattern_exprContext) Row_pattern_expr() IRow_pattern_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_exprContext)
}

func (s *Row_pattern_exprContext) STROKE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSTROKE_SYMBOL, 0)
}

func (s *Row_pattern_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterRow_pattern_expr(s)
	}
}

func (s *Row_pattern_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitRow_pattern_expr(s)
	}
}

func (s *Row_pattern_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitRow_pattern_expr(s)

	default:
		return t.VisitChildren(s)
	}
}





func (p *GoogleSQLParser) Row_pattern_expr() (localctx IRow_pattern_exprContext) {
	return p.row_pattern_expr(0)
}

func (p *GoogleSQLParser) row_pattern_expr(_p int) (localctx IRow_pattern_exprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewRow_pattern_exprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRow_pattern_exprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 126
	p.EnterRecursionRule(localctx, 126, GoogleSQLParserRULE_row_pattern_expr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1190)
		p.row_pattern_concatenation(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRow_pattern_exprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_row_pattern_expr)
			p.SetState(1192)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(1193)
				p.Match(GoogleSQLParserSTROKE_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1194)
				p.row_pattern_concatenation(0)
			}


		}
		p.SetState(1199)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_concatenationContext is an interface to support dynamic dispatch.
type IRow_pattern_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Row_pattern_factor() IRow_pattern_factorContext
	Row_pattern_concatenation() IRow_pattern_concatenationContext

	// IsRow_pattern_concatenationContext differentiates from other interfaces.
	IsRow_pattern_concatenationContext()
}

type Row_pattern_concatenationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_concatenationContext() *Row_pattern_concatenationContext {
	var p = new(Row_pattern_concatenationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_row_pattern_concatenation
	return p
}

func InitEmptyRow_pattern_concatenationContext(p *Row_pattern_concatenationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_row_pattern_concatenation
}

func (*Row_pattern_concatenationContext) IsRow_pattern_concatenationContext() {}

func NewRow_pattern_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_concatenationContext {
	var p = new(Row_pattern_concatenationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_row_pattern_concatenation

	return p
}

func (s *Row_pattern_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_concatenationContext) Row_pattern_factor() IRow_pattern_factorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_factorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_factorContext)
}

func (s *Row_pattern_concatenationContext) Row_pattern_concatenation() IRow_pattern_concatenationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_concatenationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_concatenationContext)
}

func (s *Row_pattern_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterRow_pattern_concatenation(s)
	}
}

func (s *Row_pattern_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitRow_pattern_concatenation(s)
	}
}

func (s *Row_pattern_concatenationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitRow_pattern_concatenation(s)

	default:
		return t.VisitChildren(s)
	}
}





func (p *GoogleSQLParser) Row_pattern_concatenation() (localctx IRow_pattern_concatenationContext) {
	return p.row_pattern_concatenation(0)
}

func (p *GoogleSQLParser) row_pattern_concatenation(_p int) (localctx IRow_pattern_concatenationContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewRow_pattern_concatenationContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRow_pattern_concatenationContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 128
	p.EnterRecursionRule(localctx, 128, GoogleSQLParserRULE_row_pattern_concatenation, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1201)
		p.Row_pattern_factor()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1207)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRow_pattern_concatenationContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_row_pattern_concatenation)
			p.SetState(1203)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(1204)
				p.Row_pattern_factor()
			}


		}
		p.SetState(1209)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRow_pattern_factorContext is an interface to support dynamic dispatch.
type IRow_pattern_factorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Row_pattern_expr() IRow_pattern_exprContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsRow_pattern_factorContext differentiates from other interfaces.
	IsRow_pattern_factorContext()
}

type Row_pattern_factorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_factorContext() *Row_pattern_factorContext {
	var p = new(Row_pattern_factorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_row_pattern_factor
	return p
}

func InitEmptyRow_pattern_factorContext(p *Row_pattern_factorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_row_pattern_factor
}

func (*Row_pattern_factorContext) IsRow_pattern_factorContext() {}

func NewRow_pattern_factorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_factorContext {
	var p = new(Row_pattern_factorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_row_pattern_factor

	return p
}

func (s *Row_pattern_factorContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_factorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Row_pattern_factorContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Row_pattern_factorContext) Row_pattern_expr() IRow_pattern_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_exprContext)
}

func (s *Row_pattern_factorContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Row_pattern_factorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_factorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Row_pattern_factorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterRow_pattern_factor(s)
	}
}

func (s *Row_pattern_factorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitRow_pattern_factor(s)
	}
}

func (s *Row_pattern_factorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitRow_pattern_factor(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Row_pattern_factor() (localctx IRow_pattern_factorContext) {
	localctx = NewRow_pattern_factorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, GoogleSQLParserRULE_row_pattern_factor)
	p.SetState(1215)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserINCLUDE_SYMBOL, GoogleSQLParserOFFSET_SYMBOL, GoogleSQLParserOPTIONS_SYMBOL, GoogleSQLParserPERCENT_SYMBOL, GoogleSQLParserPIVOT_SYMBOL, GoogleSQLParserREPLACE_SYMBOL, GoogleSQLParserUNPIVOT_SYMBOL, GoogleSQLParserSYSTEM_SYMBOL, GoogleSQLParserSYSTEM_TIME_SYMBOL, GoogleSQLParserVALUE_SYMBOL, GoogleSQLParserNUMERIC_SYMBOL, GoogleSQLParserDECIMAL_SYMBOL, GoogleSQLParserBIGNUMERIC_SYMBOL, GoogleSQLParserBIGDECIMAL_SYMBOL, GoogleSQLParserJSON_SYMBOL, GoogleSQLParserDATE_SYMBOL, GoogleSQLParserTIME_SYMBOL, GoogleSQLParserDATETIME_SYMBOL, GoogleSQLParserTIMESTAMP_SYMBOL, GoogleSQLParserSIMPLE_SYMBOL, GoogleSQLParserABORT_SYMBOL, GoogleSQLParserACCESS_SYMBOL, GoogleSQLParserACTION_SYMBOL, GoogleSQLParserAGGREGATE_SYMBOL, GoogleSQLParserADD_SYMBOL, GoogleSQLParserALTER_SYMBOL, GoogleSQLParserALWAYS_SYMBOL, GoogleSQLParserANALYZE_SYMBOL, GoogleSQLParserAPPROX_SYMBOL, GoogleSQLParserARE_SYMBOL, GoogleSQLParserASSERT_SYMBOL, GoogleSQLParserBATCH_SYMBOL, GoogleSQLParserBEGIN_SYMBOL, GoogleSQLParserBREAK_SYMBOL, GoogleSQLParserCALL_SYMBOL, GoogleSQLParserCASCADE_SYMBOL, GoogleSQLParserCHECK_SYMBOL, GoogleSQLParserCLAMPED_SYMBOL, GoogleSQLParserCLONE_SYMBOL, GoogleSQLParserCOPY_SYMBOL, GoogleSQLParserCLUSTER_SYMBOL, GoogleSQLParserCOLUMN_SYMBOL, GoogleSQLParserCOLUMNS_SYMBOL, GoogleSQLParserCOMMIT_SYMBOL, GoogleSQLParserCONNECTION_SYMBOL, GoogleSQLParserCONSTANT_SYMBOL, GoogleSQLParserCONSTRAINT_SYMBOL, GoogleSQLParserCONTINUE_SYMBOL, GoogleSQLParserCORRESPONDING_SYMBOL, GoogleSQLParserCYCLE_SYMBOL, GoogleSQLParserDATA_SYMBOL, GoogleSQLParserDATABASE_SYMBOL, GoogleSQLParserDECLARE_SYMBOL, GoogleSQLParserDEFINER_SYMBOL, GoogleSQLParserDELETE_SYMBOL, GoogleSQLParserDELETION_SYMBOL, GoogleSQLParserDEPTH_SYMBOL, GoogleSQLParserDESCRIBE_SYMBOL, GoogleSQLParserDETERMINISTIC_SYMBOL, GoogleSQLParserDO_SYMBOL, GoogleSQLParserDROP_SYMBOL, GoogleSQLParserELSEIF_SYMBOL, GoogleSQLParserENFORCED_SYMBOL, GoogleSQLParserERROR_SYMBOL, GoogleSQLParserEXCEPTION_SYMBOL, GoogleSQLParserEXECUTE_SYMBOL, GoogleSQLParserEXPLAIN_SYMBOL, GoogleSQLParserEXPORT_SYMBOL, GoogleSQLParserEXTEND_SYMBOL, GoogleSQLParserEXTERNAL_SYMBOL, GoogleSQLParserFILES_SYMBOL, GoogleSQLParserFILTER_SYMBOL, GoogleSQLParserFILL_SYMBOL, GoogleSQLParserFIRST_SYMBOL, GoogleSQLParserFOREIGN_SYMBOL, GoogleSQLParserFORMAT_SYMBOL, GoogleSQLParserFUNCTION_SYMBOL, GoogleSQLParserGENERATED_SYMBOL, GoogleSQLParserGRANT_SYMBOL, GoogleSQLParserGROUP_ROWS_SYMBOL, GoogleSQLParserHIDDEN_SYMBOL, GoogleSQLParserIDENTITY_SYMBOL, GoogleSQLParserIMMEDIATE_SYMBOL, GoogleSQLParserIMMUTABLE_SYMBOL, GoogleSQLParserIMPORT_SYMBOL, GoogleSQLParserINCREMENT_SYMBOL, GoogleSQLParserINDEX_SYMBOL, GoogleSQLParserINOUT_SYMBOL, GoogleSQLParserINPUT_SYMBOL, GoogleSQLParserINSERT_SYMBOL, GoogleSQLParserINVOKER_SYMBOL, GoogleSQLParserISOLATION_SYMBOL, GoogleSQLParserITERATE_SYMBOL, GoogleSQLParserKEY_SYMBOL, GoogleSQLParserLANGUAGE_SYMBOL, GoogleSQLParserLAST_SYMBOL, GoogleSQLParserLEAVE_SYMBOL, GoogleSQLParserLEVEL_SYMBOL, GoogleSQLParserLOAD_SYMBOL, GoogleSQLParserLOOP_SYMBOL, GoogleSQLParserMACRO_SYMBOL, GoogleSQLParserMAP_SYMBOL, GoogleSQLParserMATCH_SYMBOL, GoogleSQLParserKW_MATCH_RECOGNIZE_NONRESERVED_SYMBOL, GoogleSQLParserMATCHED_SYMBOL, GoogleSQLParserMATERIALIZED_SYMBOL, GoogleSQLParserMAX_SYMBOL, GoogleSQLParserMAXVALUE_SYMBOL, GoogleSQLParserMEASURES_SYMBOL, GoogleSQLParserMESSAGE_SYMBOL, GoogleSQLParserMETADATA_SYMBOL, GoogleSQLParserMIN_SYMBOL, GoogleSQLParserMINVALUE_SYMBOL, GoogleSQLParserMODEL_SYMBOL, GoogleSQLParserMODULE_SYMBOL, GoogleSQLParserONLY_SYMBOL, GoogleSQLParserOUT_SYMBOL, GoogleSQLParserOUTPUT_SYMBOL, GoogleSQLParserOVERWRITE_SYMBOL, GoogleSQLParserPARTITIONS_SYMBOL, GoogleSQLParserPATTERN_SYMBOL, GoogleSQLParserPOLICIES_SYMBOL, GoogleSQLParserPOLICY_SYMBOL, GoogleSQLParserPRIMARY_SYMBOL, GoogleSQLParserPRIVATE_SYMBOL, GoogleSQLParserPRIVILEGE_SYMBOL, GoogleSQLParserPRIVILEGES_SYMBOL, GoogleSQLParserPROCEDURE_SYMBOL, GoogleSQLParserPROJECT_SYMBOL, GoogleSQLParserPUBLIC_SYMBOL, GoogleSQLParserRAISE_SYMBOL, GoogleSQLParserREAD_SYMBOL, GoogleSQLParserREFERENCES_SYMBOL, GoogleSQLParserREMOTE_SYMBOL, GoogleSQLParserREMOVE_SYMBOL, GoogleSQLParserRENAME_SYMBOL, GoogleSQLParserREPEAT_SYMBOL, GoogleSQLParserREPEATABLE_SYMBOL, GoogleSQLParserREPLACE_FIELDS_SYMBOL, GoogleSQLParserREPLICA_SYMBOL, GoogleSQLParserREPORT_SYMBOL, GoogleSQLParserRESTRICT_SYMBOL, GoogleSQLParserRESTRICTION_SYMBOL, GoogleSQLParserRETURNS_SYMBOL, GoogleSQLParserRETURN_SYMBOL, GoogleSQLParserREVOKE_SYMBOL, GoogleSQLParserROLLBACK_SYMBOL, GoogleSQLParserROW_SYMBOL, GoogleSQLParserRUN_SYMBOL, GoogleSQLParserSAFE_CAST_SYMBOL, GoogleSQLParserSCHEMA_SYMBOL, GoogleSQLParserSEARCH_SYMBOL, GoogleSQLParserSECURITY_SYMBOL, GoogleSQLParserSEQUENCE_SYMBOL, GoogleSQLParserSETS_SYMBOL, GoogleSQLParserSHOW_SYMBOL, GoogleSQLParserSNAPSHOT_SYMBOL, GoogleSQLParserSOURCE_SYMBOL, GoogleSQLParserSQL_SYMBOL, GoogleSQLParserSTABLE_SYMBOL, GoogleSQLParserSTART_SYMBOL, GoogleSQLParserSTATIC_DESCRIBE_SYMBOL, GoogleSQLParserSTORED_SYMBOL, GoogleSQLParserSTORING_SYMBOL, GoogleSQLParserSTRICT_SYMBOL, GoogleSQLParserTABLE_SYMBOL, GoogleSQLParserTABLES_SYMBOL, GoogleSQLParserTARGET_SYMBOL, GoogleSQLParserTEMP_SYMBOL, GoogleSQLParserTEMPORARY_SYMBOL, GoogleSQLParserTRANSACTION_SYMBOL, GoogleSQLParserTRANSFORM_SYMBOL, GoogleSQLParserTRUNCATE_SYMBOL, GoogleSQLParserTYPE_SYMBOL, GoogleSQLParserUNDROP_SYMBOL, GoogleSQLParserUNIQUE_SYMBOL, GoogleSQLParserUNKNOWN_SYMBOL, GoogleSQLParserUNTIL_SYMBOL, GoogleSQLParserUPDATE_SYMBOL, GoogleSQLParserVALUES_SYMBOL, GoogleSQLParserVECTOR_SYMBOL, GoogleSQLParserVIEW_SYMBOL, GoogleSQLParserVIEWS_SYMBOL, GoogleSQLParserVOLATILE_SYMBOL, GoogleSQLParserWEIGHT_SYMBOL, GoogleSQLParserWHILE_SYMBOL, GoogleSQLParserWRITE_SYMBOL, GoogleSQLParserZONE_SYMBOL, GoogleSQLParserDESCRIPTOR_SYMBOL, GoogleSQLParserINTERLEAVE_SYMBOL, GoogleSQLParserNULL_FILTERED_SYMBOL, GoogleSQLParserPARENT_SYMBOL, GoogleSQLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1210)
			p.Identifier()
		}


	case GoogleSQLParserLR_BRACKET_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1211)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1212)
			p.row_pattern_expr(0)
		}
		{
			p.SetState(1213)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_list_prefix_with_as_aliasesContext is an interface to support dynamic dispatch.
type ISelect_list_prefix_with_as_aliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelect_column_expr_with_as_alias() []ISelect_column_expr_with_as_aliasContext
	Select_column_expr_with_as_alias(i int) ISelect_column_expr_with_as_aliasContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsSelect_list_prefix_with_as_aliasesContext differentiates from other interfaces.
	IsSelect_list_prefix_with_as_aliasesContext()
}

type Select_list_prefix_with_as_aliasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_list_prefix_with_as_aliasesContext() *Select_list_prefix_with_as_aliasesContext {
	var p = new(Select_list_prefix_with_as_aliasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select_list_prefix_with_as_aliases
	return p
}

func InitEmptySelect_list_prefix_with_as_aliasesContext(p *Select_list_prefix_with_as_aliasesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select_list_prefix_with_as_aliases
}

func (*Select_list_prefix_with_as_aliasesContext) IsSelect_list_prefix_with_as_aliasesContext() {}

func NewSelect_list_prefix_with_as_aliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_list_prefix_with_as_aliasesContext {
	var p = new(Select_list_prefix_with_as_aliasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_select_list_prefix_with_as_aliases

	return p
}

func (s *Select_list_prefix_with_as_aliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_list_prefix_with_as_aliasesContext) AllSelect_column_expr_with_as_alias() []ISelect_column_expr_with_as_aliasContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelect_column_expr_with_as_aliasContext); ok {
			len++
		}
	}

	tst := make([]ISelect_column_expr_with_as_aliasContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelect_column_expr_with_as_aliasContext); ok {
			tst[i] = t.(ISelect_column_expr_with_as_aliasContext)
			i++
		}
	}

	return tst
}

func (s *Select_list_prefix_with_as_aliasesContext) Select_column_expr_with_as_alias(i int) ISelect_column_expr_with_as_aliasContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_column_expr_with_as_aliasContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_column_expr_with_as_aliasContext)
}

func (s *Select_list_prefix_with_as_aliasesContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Select_list_prefix_with_as_aliasesContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Select_list_prefix_with_as_aliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_list_prefix_with_as_aliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_list_prefix_with_as_aliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSelect_list_prefix_with_as_aliases(s)
	}
}

func (s *Select_list_prefix_with_as_aliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSelect_list_prefix_with_as_aliases(s)
	}
}

func (s *Select_list_prefix_with_as_aliasesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSelect_list_prefix_with_as_aliases(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Select_list_prefix_with_as_aliases() (localctx ISelect_list_prefix_with_as_aliasesContext) {
	localctx = NewSelect_list_prefix_with_as_aliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, GoogleSQLParserRULE_select_list_prefix_with_as_aliases)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1217)
		p.Select_column_expr_with_as_alias()
	}
	p.SetState(1222)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(1218)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1219)
			p.Select_column_expr_with_as_alias()
		}


		p.SetState(1224)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_column_expr_with_as_aliasContext is an interface to support dynamic dispatch.
type ISelect_column_expr_with_as_aliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AS_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsSelect_column_expr_with_as_aliasContext differentiates from other interfaces.
	IsSelect_column_expr_with_as_aliasContext()
}

type Select_column_expr_with_as_aliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_column_expr_with_as_aliasContext() *Select_column_expr_with_as_aliasContext {
	var p = new(Select_column_expr_with_as_aliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select_column_expr_with_as_alias
	return p
}

func InitEmptySelect_column_expr_with_as_aliasContext(p *Select_column_expr_with_as_aliasContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select_column_expr_with_as_alias
}

func (*Select_column_expr_with_as_aliasContext) IsSelect_column_expr_with_as_aliasContext() {}

func NewSelect_column_expr_with_as_aliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_column_expr_with_as_aliasContext {
	var p = new(Select_column_expr_with_as_aliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_select_column_expr_with_as_alias

	return p
}

func (s *Select_column_expr_with_as_aliasContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_column_expr_with_as_aliasContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Select_column_expr_with_as_aliasContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAS_SYMBOL, 0)
}

func (s *Select_column_expr_with_as_aliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Select_column_expr_with_as_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_column_expr_with_as_aliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_column_expr_with_as_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSelect_column_expr_with_as_alias(s)
	}
}

func (s *Select_column_expr_with_as_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSelect_column_expr_with_as_alias(s)
	}
}

func (s *Select_column_expr_with_as_aliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSelect_column_expr_with_as_alias(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Select_column_expr_with_as_alias() (localctx ISelect_column_expr_with_as_aliasContext) {
	localctx = NewSelect_column_expr_with_as_aliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, GoogleSQLParserRULE_select_column_expr_with_as_alias)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1225)
		p.expression(0)
	}
	{
		p.SetState(1226)
		p.Match(GoogleSQLParserAS_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1227)
		p.Identifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_subqueryContext is an interface to support dynamic dispatch.
type ITable_subqueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Parenthesized_query() IParenthesized_queryContext
	Opt_pivot_or_unpivot_clause_and_alias() IOpt_pivot_or_unpivot_clause_and_aliasContext

	// IsTable_subqueryContext differentiates from other interfaces.
	IsTable_subqueryContext()
}

type Table_subqueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_subqueryContext() *Table_subqueryContext {
	var p = new(Table_subqueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_table_subquery
	return p
}

func InitEmptyTable_subqueryContext(p *Table_subqueryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_table_subquery
}

func (*Table_subqueryContext) IsTable_subqueryContext() {}

func NewTable_subqueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_subqueryContext {
	var p = new(Table_subqueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_table_subquery

	return p
}

func (s *Table_subqueryContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_subqueryContext) Parenthesized_query() IParenthesized_queryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesized_queryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesized_queryContext)
}

func (s *Table_subqueryContext) Opt_pivot_or_unpivot_clause_and_alias() IOpt_pivot_or_unpivot_clause_and_aliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_pivot_or_unpivot_clause_and_aliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_pivot_or_unpivot_clause_and_aliasContext)
}

func (s *Table_subqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_subqueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_subqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterTable_subquery(s)
	}
}

func (s *Table_subqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitTable_subquery(s)
	}
}

func (s *Table_subqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitTable_subquery(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Table_subquery() (localctx ITable_subqueryContext) {
	localctx = NewTable_subqueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, GoogleSQLParserRULE_table_subquery)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1229)
		p.Parenthesized_query()
	}
	p.SetState(1231)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1230)
			p.Opt_pivot_or_unpivot_clause_and_alias()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJoinContext is an interface to support dynamic dispatch.
type IJoinContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_primary() ITable_primaryContext
	AllJoin_item() []IJoin_itemContext
	Join_item(i int) IJoin_itemContext

	// IsJoinContext differentiates from other interfaces.
	IsJoinContext()
}

type JoinContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinContext() *JoinContext {
	var p = new(JoinContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_join
	return p
}

func InitEmptyJoinContext(p *JoinContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_join
}

func (*JoinContext) IsJoinContext() {}

func NewJoinContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinContext {
	var p = new(JoinContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_join

	return p
}

func (s *JoinContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinContext) Table_primary() ITable_primaryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_primaryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_primaryContext)
}

func (s *JoinContext) AllJoin_item() []IJoin_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoin_itemContext); ok {
			len++
		}
	}

	tst := make([]IJoin_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoin_itemContext); ok {
			tst[i] = t.(IJoin_itemContext)
			i++
		}
	}

	return tst
}

func (s *JoinContext) Join_item(i int) IJoin_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoin_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoin_itemContext)
}

func (s *JoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *JoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterJoin(s)
	}
}

func (s *JoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitJoin(s)
	}
}

func (s *JoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitJoin(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Join() (localctx IJoinContext) {
	localctx = NewJoinContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, GoogleSQLParserRULE_join)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1233)
		p.table_primary(0)
	}
	p.SetState(1237)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 68724850752) != 0) || _la == GoogleSQLParserNATURAL_SYMBOL {
		{
			p.SetState(1234)
			p.Join_item()
		}


		p.SetState(1239)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJoin_itemContext is an interface to support dynamic dispatch.
type IJoin_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Join_type() IJoin_typeContext
	JOIN_SYMBOL() antlr.TerminalNode
	Table_primary() ITable_primaryContext
	Opt_natural() IOpt_naturalContext
	Join_hint() IJoin_hintContext
	Hint() IHintContext
	On_or_using_clause_list() IOn_or_using_clause_listContext

	// IsJoin_itemContext differentiates from other interfaces.
	IsJoin_itemContext()
}

type Join_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_itemContext() *Join_itemContext {
	var p = new(Join_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_join_item
	return p
}

func InitEmptyJoin_itemContext(p *Join_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_join_item
}

func (*Join_itemContext) IsJoin_itemContext() {}

func NewJoin_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_itemContext {
	var p = new(Join_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_join_item

	return p
}

func (s *Join_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_itemContext) Join_type() IJoin_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoin_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoin_typeContext)
}

func (s *Join_itemContext) JOIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserJOIN_SYMBOL, 0)
}

func (s *Join_itemContext) Table_primary() ITable_primaryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_primaryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_primaryContext)
}

func (s *Join_itemContext) Opt_natural() IOpt_naturalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_naturalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_naturalContext)
}

func (s *Join_itemContext) Join_hint() IJoin_hintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoin_hintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoin_hintContext)
}

func (s *Join_itemContext) Hint() IHintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintContext)
}

func (s *Join_itemContext) On_or_using_clause_list() IOn_or_using_clause_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOn_or_using_clause_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOn_or_using_clause_listContext)
}

func (s *Join_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Join_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterJoin_item(s)
	}
}

func (s *Join_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitJoin_item(s)
	}
}

func (s *Join_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitJoin_item(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Join_item() (localctx IJoin_itemContext) {
	localctx = NewJoin_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, GoogleSQLParserRULE_join_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1241)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserNATURAL_SYMBOL {
		{
			p.SetState(1240)
			p.Opt_natural()
		}

	}
	{
		p.SetState(1243)
		p.Join_type()
	}
	p.SetState(1245)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserHASH_SYMBOL || _la == GoogleSQLParserLOOKUP_SYMBOL {
		{
			p.SetState(1244)
			p.Join_hint()
		}

	}
	{
		p.SetState(1247)
		p.Match(GoogleSQLParserJOIN_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserAT_SYMBOL {
		{
			p.SetState(1248)
			p.Hint()
		}

	}
	{
		p.SetState(1251)
		p.table_primary(0)
	}
	p.SetState(1253)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserON_SYMBOL || _la == GoogleSQLParserUSING_SYMBOL {
		{
			p.SetState(1252)
			p.On_or_using_clause_list()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOn_or_using_clause_listContext is an interface to support dynamic dispatch.
type IOn_or_using_clause_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOn_or_using_clause() []IOn_or_using_clauseContext
	On_or_using_clause(i int) IOn_or_using_clauseContext

	// IsOn_or_using_clause_listContext differentiates from other interfaces.
	IsOn_or_using_clause_listContext()
}

type On_or_using_clause_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOn_or_using_clause_listContext() *On_or_using_clause_listContext {
	var p = new(On_or_using_clause_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_on_or_using_clause_list
	return p
}

func InitEmptyOn_or_using_clause_listContext(p *On_or_using_clause_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_on_or_using_clause_list
}

func (*On_or_using_clause_listContext) IsOn_or_using_clause_listContext() {}

func NewOn_or_using_clause_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *On_or_using_clause_listContext {
	var p = new(On_or_using_clause_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_on_or_using_clause_list

	return p
}

func (s *On_or_using_clause_listContext) GetParser() antlr.Parser { return s.parser }

func (s *On_or_using_clause_listContext) AllOn_or_using_clause() []IOn_or_using_clauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOn_or_using_clauseContext); ok {
			len++
		}
	}

	tst := make([]IOn_or_using_clauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOn_or_using_clauseContext); ok {
			tst[i] = t.(IOn_or_using_clauseContext)
			i++
		}
	}

	return tst
}

func (s *On_or_using_clause_listContext) On_or_using_clause(i int) IOn_or_using_clauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOn_or_using_clauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOn_or_using_clauseContext)
}

func (s *On_or_using_clause_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *On_or_using_clause_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *On_or_using_clause_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOn_or_using_clause_list(s)
	}
}

func (s *On_or_using_clause_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOn_or_using_clause_list(s)
	}
}

func (s *On_or_using_clause_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOn_or_using_clause_list(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) On_or_using_clause_list() (localctx IOn_or_using_clause_listContext) {
	localctx = NewOn_or_using_clause_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, GoogleSQLParserRULE_on_or_using_clause_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1256)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == GoogleSQLParserON_SYMBOL || _la == GoogleSQLParserUSING_SYMBOL {
		{
			p.SetState(1255)
			p.On_or_using_clause()
		}


		p.SetState(1258)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOn_or_using_clauseContext is an interface to support dynamic dispatch.
type IOn_or_using_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	On_clause() IOn_clauseContext
	Using_clause() IUsing_clauseContext

	// IsOn_or_using_clauseContext differentiates from other interfaces.
	IsOn_or_using_clauseContext()
}

type On_or_using_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOn_or_using_clauseContext() *On_or_using_clauseContext {
	var p = new(On_or_using_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_on_or_using_clause
	return p
}

func InitEmptyOn_or_using_clauseContext(p *On_or_using_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_on_or_using_clause
}

func (*On_or_using_clauseContext) IsOn_or_using_clauseContext() {}

func NewOn_or_using_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *On_or_using_clauseContext {
	var p = new(On_or_using_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_on_or_using_clause

	return p
}

func (s *On_or_using_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *On_or_using_clauseContext) On_clause() IOn_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOn_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOn_clauseContext)
}

func (s *On_or_using_clauseContext) Using_clause() IUsing_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsing_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsing_clauseContext)
}

func (s *On_or_using_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *On_or_using_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *On_or_using_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOn_or_using_clause(s)
	}
}

func (s *On_or_using_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOn_or_using_clause(s)
	}
}

func (s *On_or_using_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOn_or_using_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) On_or_using_clause() (localctx IOn_or_using_clauseContext) {
	localctx = NewOn_or_using_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, GoogleSQLParserRULE_on_or_using_clause)
	p.SetState(1262)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserON_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1260)
			p.On_clause()
		}


	case GoogleSQLParserUSING_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1261)
			p.Using_clause()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJoin_hintContext is an interface to support dynamic dispatch.
type IJoin_hintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HASH_SYMBOL() antlr.TerminalNode
	LOOKUP_SYMBOL() antlr.TerminalNode

	// IsJoin_hintContext differentiates from other interfaces.
	IsJoin_hintContext()
}

type Join_hintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_hintContext() *Join_hintContext {
	var p = new(Join_hintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_join_hint
	return p
}

func InitEmptyJoin_hintContext(p *Join_hintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_join_hint
}

func (*Join_hintContext) IsJoin_hintContext() {}

func NewJoin_hintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_hintContext {
	var p = new(Join_hintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_join_hint

	return p
}

func (s *Join_hintContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_hintContext) HASH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserHASH_SYMBOL, 0)
}

func (s *Join_hintContext) LOOKUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLOOKUP_SYMBOL, 0)
}

func (s *Join_hintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_hintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Join_hintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterJoin_hint(s)
	}
}

func (s *Join_hintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitJoin_hint(s)
	}
}

func (s *Join_hintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitJoin_hint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Join_hint() (localctx IJoin_hintContext) {
	localctx = NewJoin_hintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, GoogleSQLParserRULE_join_hint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1264)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GoogleSQLParserHASH_SYMBOL || _la == GoogleSQLParserLOOKUP_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_path_expressionContext is an interface to support dynamic dispatch.
type ITable_path_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_path_expression_base() ITable_path_expression_baseContext
	Hint() IHintContext
	Opt_pivot_or_unpivot_clause_and_alias() IOpt_pivot_or_unpivot_clause_and_aliasContext
	Opt_with_offset_and_alias() IOpt_with_offset_and_aliasContext
	Opt_at_system_time() IOpt_at_system_timeContext

	// IsTable_path_expressionContext differentiates from other interfaces.
	IsTable_path_expressionContext()
}

type Table_path_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_path_expressionContext() *Table_path_expressionContext {
	var p = new(Table_path_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_table_path_expression
	return p
}

func InitEmptyTable_path_expressionContext(p *Table_path_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_table_path_expression
}

func (*Table_path_expressionContext) IsTable_path_expressionContext() {}

func NewTable_path_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_path_expressionContext {
	var p = new(Table_path_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_table_path_expression

	return p
}

func (s *Table_path_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_path_expressionContext) Table_path_expression_base() ITable_path_expression_baseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_path_expression_baseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_path_expression_baseContext)
}

func (s *Table_path_expressionContext) Hint() IHintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintContext)
}

func (s *Table_path_expressionContext) Opt_pivot_or_unpivot_clause_and_alias() IOpt_pivot_or_unpivot_clause_and_aliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_pivot_or_unpivot_clause_and_aliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_pivot_or_unpivot_clause_and_aliasContext)
}

func (s *Table_path_expressionContext) Opt_with_offset_and_alias() IOpt_with_offset_and_aliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_with_offset_and_aliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_with_offset_and_aliasContext)
}

func (s *Table_path_expressionContext) Opt_at_system_time() IOpt_at_system_timeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_at_system_timeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_at_system_timeContext)
}

func (s *Table_path_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_path_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_path_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterTable_path_expression(s)
	}
}

func (s *Table_path_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitTable_path_expression(s)
	}
}

func (s *Table_path_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitTable_path_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Table_path_expression() (localctx ITable_path_expressionContext) {
	localctx = NewTable_path_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, GoogleSQLParserRULE_table_path_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1266)
		p.Table_path_expression_base()
	}
	p.SetState(1268)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1267)
			p.Hint()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(1271)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 109, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1270)
			p.Opt_pivot_or_unpivot_clause_and_alias()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(1274)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1273)
			p.Opt_with_offset_and_alias()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(1277)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1276)
			p.Opt_at_system_time()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_at_system_timeContext is an interface to support dynamic dispatch.
type IOpt_at_system_timeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR_SYMBOL() antlr.TerminalNode
	SYSTEM_SYMBOL() antlr.TerminalNode
	TIME_SYMBOL() antlr.TerminalNode
	AS_SYMBOL() antlr.TerminalNode
	OF_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext
	SYSTEM_TIME_SYMBOL() antlr.TerminalNode

	// IsOpt_at_system_timeContext differentiates from other interfaces.
	IsOpt_at_system_timeContext()
}

type Opt_at_system_timeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_at_system_timeContext() *Opt_at_system_timeContext {
	var p = new(Opt_at_system_timeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_at_system_time
	return p
}

func InitEmptyOpt_at_system_timeContext(p *Opt_at_system_timeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_at_system_time
}

func (*Opt_at_system_timeContext) IsOpt_at_system_timeContext() {}

func NewOpt_at_system_timeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_at_system_timeContext {
	var p = new(Opt_at_system_timeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_at_system_time

	return p
}

func (s *Opt_at_system_timeContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_at_system_timeContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFOR_SYMBOL, 0)
}

func (s *Opt_at_system_timeContext) SYSTEM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSYSTEM_SYMBOL, 0)
}

func (s *Opt_at_system_timeContext) TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTIME_SYMBOL, 0)
}

func (s *Opt_at_system_timeContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAS_SYMBOL, 0)
}

func (s *Opt_at_system_timeContext) OF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserOF_SYMBOL, 0)
}

func (s *Opt_at_system_timeContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Opt_at_system_timeContext) SYSTEM_TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSYSTEM_TIME_SYMBOL, 0)
}

func (s *Opt_at_system_timeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_at_system_timeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_at_system_timeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_at_system_time(s)
	}
}

func (s *Opt_at_system_timeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_at_system_time(s)
	}
}

func (s *Opt_at_system_timeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_at_system_time(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_at_system_time() (localctx IOpt_at_system_timeContext) {
	localctx = NewOpt_at_system_timeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, GoogleSQLParserRULE_opt_at_system_time)
	p.SetState(1290)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1279)
			p.Match(GoogleSQLParserFOR_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1280)
			p.Match(GoogleSQLParserSYSTEM_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1281)
			p.Match(GoogleSQLParserTIME_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1282)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1283)
			p.Match(GoogleSQLParserOF_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1284)
			p.expression(0)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1285)
			p.Match(GoogleSQLParserFOR_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1286)
			p.Match(GoogleSQLParserSYSTEM_TIME_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1287)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1288)
			p.Match(GoogleSQLParserOF_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1289)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_with_offset_and_aliasContext is an interface to support dynamic dispatch.
type IOpt_with_offset_and_aliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	OFFSET_SYMBOL() antlr.TerminalNode
	As_alias() IAs_aliasContext

	// IsOpt_with_offset_and_aliasContext differentiates from other interfaces.
	IsOpt_with_offset_and_aliasContext()
}

type Opt_with_offset_and_aliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_with_offset_and_aliasContext() *Opt_with_offset_and_aliasContext {
	var p = new(Opt_with_offset_and_aliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_with_offset_and_alias
	return p
}

func InitEmptyOpt_with_offset_and_aliasContext(p *Opt_with_offset_and_aliasContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_with_offset_and_alias
}

func (*Opt_with_offset_and_aliasContext) IsOpt_with_offset_and_aliasContext() {}

func NewOpt_with_offset_and_aliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_with_offset_and_aliasContext {
	var p = new(Opt_with_offset_and_aliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_with_offset_and_alias

	return p
}

func (s *Opt_with_offset_and_aliasContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_with_offset_and_aliasContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWITH_SYMBOL, 0)
}

func (s *Opt_with_offset_and_aliasContext) OFFSET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserOFFSET_SYMBOL, 0)
}

func (s *Opt_with_offset_and_aliasContext) As_alias() IAs_aliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAs_aliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAs_aliasContext)
}

func (s *Opt_with_offset_and_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_with_offset_and_aliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_with_offset_and_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_with_offset_and_alias(s)
	}
}

func (s *Opt_with_offset_and_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_with_offset_and_alias(s)
	}
}

func (s *Opt_with_offset_and_aliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_with_offset_and_alias(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_with_offset_and_alias() (localctx IOpt_with_offset_and_aliasContext) {
	localctx = NewOpt_with_offset_and_aliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, GoogleSQLParserRULE_opt_with_offset_and_alias)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1292)
		p.Match(GoogleSQLParserWITH_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1293)
		p.Match(GoogleSQLParserOFFSET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1295)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1294)
			p.As_alias()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_pivot_or_unpivot_clause_and_aliasContext is an interface to support dynamic dispatch.
type IOpt_pivot_or_unpivot_clause_and_aliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	Pivot_clause() IPivot_clauseContext
	As_alias() IAs_aliasContext
	Unpivot_clause() IUnpivot_clauseContext
	Qualify_clause_nonreserved() IQualify_clause_nonreservedContext

	// IsOpt_pivot_or_unpivot_clause_and_aliasContext differentiates from other interfaces.
	IsOpt_pivot_or_unpivot_clause_and_aliasContext()
}

type Opt_pivot_or_unpivot_clause_and_aliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_pivot_or_unpivot_clause_and_aliasContext() *Opt_pivot_or_unpivot_clause_and_aliasContext {
	var p = new(Opt_pivot_or_unpivot_clause_and_aliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_pivot_or_unpivot_clause_and_alias
	return p
}

func InitEmptyOpt_pivot_or_unpivot_clause_and_aliasContext(p *Opt_pivot_or_unpivot_clause_and_aliasContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_pivot_or_unpivot_clause_and_alias
}

func (*Opt_pivot_or_unpivot_clause_and_aliasContext) IsOpt_pivot_or_unpivot_clause_and_aliasContext() {}

func NewOpt_pivot_or_unpivot_clause_and_aliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_pivot_or_unpivot_clause_and_aliasContext {
	var p = new(Opt_pivot_or_unpivot_clause_and_aliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_pivot_or_unpivot_clause_and_alias

	return p
}

func (s *Opt_pivot_or_unpivot_clause_and_aliasContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_pivot_or_unpivot_clause_and_aliasContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAS_SYMBOL, 0)
}

func (s *Opt_pivot_or_unpivot_clause_and_aliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Opt_pivot_or_unpivot_clause_and_aliasContext) Pivot_clause() IPivot_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivot_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivot_clauseContext)
}

func (s *Opt_pivot_or_unpivot_clause_and_aliasContext) As_alias() IAs_aliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAs_aliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAs_aliasContext)
}

func (s *Opt_pivot_or_unpivot_clause_and_aliasContext) Unpivot_clause() IUnpivot_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivot_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivot_clauseContext)
}

func (s *Opt_pivot_or_unpivot_clause_and_aliasContext) Qualify_clause_nonreserved() IQualify_clause_nonreservedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualify_clause_nonreservedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualify_clause_nonreservedContext)
}

func (s *Opt_pivot_or_unpivot_clause_and_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_pivot_or_unpivot_clause_and_aliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_pivot_or_unpivot_clause_and_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_pivot_or_unpivot_clause_and_alias(s)
	}
}

func (s *Opt_pivot_or_unpivot_clause_and_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_pivot_or_unpivot_clause_and_alias(s)
	}
}

func (s *Opt_pivot_or_unpivot_clause_and_aliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_pivot_or_unpivot_clause_and_alias(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_pivot_or_unpivot_clause_and_alias() (localctx IOpt_pivot_or_unpivot_clause_and_aliasContext) {
	localctx = NewOpt_pivot_or_unpivot_clause_and_aliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, GoogleSQLParserRULE_opt_pivot_or_unpivot_clause_and_alias)
	p.SetState(1342)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1297)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1298)
			p.Identifier()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1299)
			p.Identifier()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1300)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1301)
			p.Identifier()
		}
		{
			p.SetState(1302)
			p.Pivot_clause()
		}
		p.SetState(1304)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1303)
				p.As_alias()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1306)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1307)
			p.Identifier()
		}
		{
			p.SetState(1308)
			p.Unpivot_clause()
		}
		p.SetState(1310)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1309)
				p.As_alias()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1312)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1313)
			p.Identifier()
		}
		{
			p.SetState(1314)
			p.Qualify_clause_nonreserved()
		}
		p.NotifyErrorListeners("QUALIFY clause must be used in conjunction with WHERE or GROUP BY "
		        "or HAVING clause", nil, nil)


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1317)
			p.Identifier()
		}
		{
			p.SetState(1318)
			p.Pivot_clause()
		}
		p.SetState(1320)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 116, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1319)
				p.As_alias()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1322)
			p.Identifier()
		}
		{
			p.SetState(1323)
			p.Unpivot_clause()
		}
		p.SetState(1325)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1324)
				p.As_alias()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1327)
			p.Identifier()
		}
		{
			p.SetState(1328)
			p.Qualify_clause_nonreserved()
		}
		p.NotifyErrorListeners("QUALIFY clause must be used in conjunction with WHERE or GROUP BY "
		        "or HAVING clause", nil, nil)


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1331)
			p.Pivot_clause()
		}
		p.SetState(1333)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1332)
				p.As_alias()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1335)
			p.Unpivot_clause()
		}
		p.SetState(1337)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1336)
				p.As_alias()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1339)
			p.Qualify_clause_nonreserved()
		}
		p.NotifyErrorListeners("QUALIFY clause must be used in conjunction with WHERE or GROUP BY "
		        "or HAVING clause", nil, nil)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_path_expression_baseContext is an interface to support dynamic dispatch.
type ITable_path_expression_baseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Unnest_expression() IUnnest_expressionContext
	Maybe_slashed_or_dashed_path_expression() IMaybe_slashed_or_dashed_path_expressionContext
	Path_expression() IPath_expressionContext
	LS_BRACKET_SYMBOL() antlr.TerminalNode
	DOT_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsTable_path_expression_baseContext differentiates from other interfaces.
	IsTable_path_expression_baseContext()
}

type Table_path_expression_baseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_path_expression_baseContext() *Table_path_expression_baseContext {
	var p = new(Table_path_expression_baseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_table_path_expression_base
	return p
}

func InitEmptyTable_path_expression_baseContext(p *Table_path_expression_baseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_table_path_expression_base
}

func (*Table_path_expression_baseContext) IsTable_path_expression_baseContext() {}

func NewTable_path_expression_baseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_path_expression_baseContext {
	var p = new(Table_path_expression_baseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_table_path_expression_base

	return p
}

func (s *Table_path_expression_baseContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_path_expression_baseContext) Unnest_expression() IUnnest_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnnest_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnnest_expressionContext)
}

func (s *Table_path_expression_baseContext) Maybe_slashed_or_dashed_path_expression() IMaybe_slashed_or_dashed_path_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaybe_slashed_or_dashed_path_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaybe_slashed_or_dashed_path_expressionContext)
}

func (s *Table_path_expression_baseContext) Path_expression() IPath_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPath_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPath_expressionContext)
}

func (s *Table_path_expression_baseContext) LS_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLS_BRACKET_SYMBOL, 0)
}

func (s *Table_path_expression_baseContext) DOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDOT_SYMBOL, 0)
}

func (s *Table_path_expression_baseContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Table_path_expression_baseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_path_expression_baseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_path_expression_baseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterTable_path_expression_base(s)
	}
}

func (s *Table_path_expression_baseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitTable_path_expression_base(s)
	}
}

func (s *Table_path_expression_baseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitTable_path_expression_base(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Table_path_expression_base() (localctx ITable_path_expression_baseContext) {
	localctx = NewTable_path_expression_baseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, GoogleSQLParserRULE_table_path_expression_base)
	p.SetState(1364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1344)
			p.Unnest_expression()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1345)
			p.Maybe_slashed_or_dashed_path_expression()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1346)
			p.path_expression(0)
		}
		{
			p.SetState(1347)
			p.Match(GoogleSQLParserLS_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.NotifyErrorListeners("Syntax error: Array element access is not allowed in the FROM "
		            "clause without UNNEST; Use UNNEST(<expression>)",nil,nil)


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1350)
			p.path_expression(0)
		}
		{
			p.SetState(1351)
			p.Match(GoogleSQLParserDOT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1352)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.NotifyErrorListeners("Syntax error: Generalized field access is not allowed in the FROM "
		            "clause without UNNEST; Use UNNEST(<expression>)",nil,nil)


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1355)
			p.Unnest_expression()
		}
		{
			p.SetState(1356)
			p.Match(GoogleSQLParserLS_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.NotifyErrorListeners("Syntax error: Array element access is not allowed in the FROM "
		            "clause without UNNEST; Use UNNEST(<expression>)",nil,nil)


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1359)
			p.Unnest_expression()
		}
		{
			p.SetState(1360)
			p.Match(GoogleSQLParserDOT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1361)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.NotifyErrorListeners("Syntax error: Generalized field access is not allowed in the FROM "
		            "clause without UNNEST; Use UNNEST(<expression>)",nil,nil)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMaybe_slashed_or_dashed_path_expressionContext is an interface to support dynamic dispatch.
type IMaybe_slashed_or_dashed_path_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Maybe_dashed_path_expression() IMaybe_dashed_path_expressionContext
	Slashed_path_expression() ISlashed_path_expressionContext

	// IsMaybe_slashed_or_dashed_path_expressionContext differentiates from other interfaces.
	IsMaybe_slashed_or_dashed_path_expressionContext()
}

type Maybe_slashed_or_dashed_path_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaybe_slashed_or_dashed_path_expressionContext() *Maybe_slashed_or_dashed_path_expressionContext {
	var p = new(Maybe_slashed_or_dashed_path_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_maybe_slashed_or_dashed_path_expression
	return p
}

func InitEmptyMaybe_slashed_or_dashed_path_expressionContext(p *Maybe_slashed_or_dashed_path_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_maybe_slashed_or_dashed_path_expression
}

func (*Maybe_slashed_or_dashed_path_expressionContext) IsMaybe_slashed_or_dashed_path_expressionContext() {}

func NewMaybe_slashed_or_dashed_path_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Maybe_slashed_or_dashed_path_expressionContext {
	var p = new(Maybe_slashed_or_dashed_path_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_maybe_slashed_or_dashed_path_expression

	return p
}

func (s *Maybe_slashed_or_dashed_path_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Maybe_slashed_or_dashed_path_expressionContext) Maybe_dashed_path_expression() IMaybe_dashed_path_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaybe_dashed_path_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaybe_dashed_path_expressionContext)
}

func (s *Maybe_slashed_or_dashed_path_expressionContext) Slashed_path_expression() ISlashed_path_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISlashed_path_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISlashed_path_expressionContext)
}

func (s *Maybe_slashed_or_dashed_path_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Maybe_slashed_or_dashed_path_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Maybe_slashed_or_dashed_path_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterMaybe_slashed_or_dashed_path_expression(s)
	}
}

func (s *Maybe_slashed_or_dashed_path_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitMaybe_slashed_or_dashed_path_expression(s)
	}
}

func (s *Maybe_slashed_or_dashed_path_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitMaybe_slashed_or_dashed_path_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Maybe_slashed_or_dashed_path_expression() (localctx IMaybe_slashed_or_dashed_path_expressionContext) {
	localctx = NewMaybe_slashed_or_dashed_path_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, GoogleSQLParserRULE_maybe_slashed_or_dashed_path_expression)
	p.SetState(1368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserINCLUDE_SYMBOL, GoogleSQLParserOFFSET_SYMBOL, GoogleSQLParserOPTIONS_SYMBOL, GoogleSQLParserPERCENT_SYMBOL, GoogleSQLParserPIVOT_SYMBOL, GoogleSQLParserREPLACE_SYMBOL, GoogleSQLParserUNPIVOT_SYMBOL, GoogleSQLParserSYSTEM_SYMBOL, GoogleSQLParserSYSTEM_TIME_SYMBOL, GoogleSQLParserVALUE_SYMBOL, GoogleSQLParserNUMERIC_SYMBOL, GoogleSQLParserDECIMAL_SYMBOL, GoogleSQLParserBIGNUMERIC_SYMBOL, GoogleSQLParserBIGDECIMAL_SYMBOL, GoogleSQLParserJSON_SYMBOL, GoogleSQLParserDATE_SYMBOL, GoogleSQLParserTIME_SYMBOL, GoogleSQLParserDATETIME_SYMBOL, GoogleSQLParserTIMESTAMP_SYMBOL, GoogleSQLParserSIMPLE_SYMBOL, GoogleSQLParserABORT_SYMBOL, GoogleSQLParserACCESS_SYMBOL, GoogleSQLParserACTION_SYMBOL, GoogleSQLParserAGGREGATE_SYMBOL, GoogleSQLParserADD_SYMBOL, GoogleSQLParserALTER_SYMBOL, GoogleSQLParserALWAYS_SYMBOL, GoogleSQLParserANALYZE_SYMBOL, GoogleSQLParserAPPROX_SYMBOL, GoogleSQLParserARE_SYMBOL, GoogleSQLParserASSERT_SYMBOL, GoogleSQLParserBATCH_SYMBOL, GoogleSQLParserBEGIN_SYMBOL, GoogleSQLParserBREAK_SYMBOL, GoogleSQLParserCALL_SYMBOL, GoogleSQLParserCASCADE_SYMBOL, GoogleSQLParserCHECK_SYMBOL, GoogleSQLParserCLAMPED_SYMBOL, GoogleSQLParserCLONE_SYMBOL, GoogleSQLParserCOPY_SYMBOL, GoogleSQLParserCLUSTER_SYMBOL, GoogleSQLParserCOLUMN_SYMBOL, GoogleSQLParserCOLUMNS_SYMBOL, GoogleSQLParserCOMMIT_SYMBOL, GoogleSQLParserCONNECTION_SYMBOL, GoogleSQLParserCONSTANT_SYMBOL, GoogleSQLParserCONSTRAINT_SYMBOL, GoogleSQLParserCONTINUE_SYMBOL, GoogleSQLParserCORRESPONDING_SYMBOL, GoogleSQLParserCYCLE_SYMBOL, GoogleSQLParserDATA_SYMBOL, GoogleSQLParserDATABASE_SYMBOL, GoogleSQLParserDECLARE_SYMBOL, GoogleSQLParserDEFINER_SYMBOL, GoogleSQLParserDELETE_SYMBOL, GoogleSQLParserDELETION_SYMBOL, GoogleSQLParserDEPTH_SYMBOL, GoogleSQLParserDESCRIBE_SYMBOL, GoogleSQLParserDETERMINISTIC_SYMBOL, GoogleSQLParserDO_SYMBOL, GoogleSQLParserDROP_SYMBOL, GoogleSQLParserELSEIF_SYMBOL, GoogleSQLParserENFORCED_SYMBOL, GoogleSQLParserERROR_SYMBOL, GoogleSQLParserEXCEPTION_SYMBOL, GoogleSQLParserEXECUTE_SYMBOL, GoogleSQLParserEXPLAIN_SYMBOL, GoogleSQLParserEXPORT_SYMBOL, GoogleSQLParserEXTEND_SYMBOL, GoogleSQLParserEXTERNAL_SYMBOL, GoogleSQLParserFILES_SYMBOL, GoogleSQLParserFILTER_SYMBOL, GoogleSQLParserFILL_SYMBOL, GoogleSQLParserFIRST_SYMBOL, GoogleSQLParserFOREIGN_SYMBOL, GoogleSQLParserFORMAT_SYMBOL, GoogleSQLParserFUNCTION_SYMBOL, GoogleSQLParserGENERATED_SYMBOL, GoogleSQLParserGRANT_SYMBOL, GoogleSQLParserGROUP_ROWS_SYMBOL, GoogleSQLParserHIDDEN_SYMBOL, GoogleSQLParserIDENTITY_SYMBOL, GoogleSQLParserIMMEDIATE_SYMBOL, GoogleSQLParserIMMUTABLE_SYMBOL, GoogleSQLParserIMPORT_SYMBOL, GoogleSQLParserINCREMENT_SYMBOL, GoogleSQLParserINDEX_SYMBOL, GoogleSQLParserINOUT_SYMBOL, GoogleSQLParserINPUT_SYMBOL, GoogleSQLParserINSERT_SYMBOL, GoogleSQLParserINVOKER_SYMBOL, GoogleSQLParserISOLATION_SYMBOL, GoogleSQLParserITERATE_SYMBOL, GoogleSQLParserKEY_SYMBOL, GoogleSQLParserLANGUAGE_SYMBOL, GoogleSQLParserLAST_SYMBOL, GoogleSQLParserLEAVE_SYMBOL, GoogleSQLParserLEVEL_SYMBOL, GoogleSQLParserLOAD_SYMBOL, GoogleSQLParserLOOP_SYMBOL, GoogleSQLParserMACRO_SYMBOL, GoogleSQLParserMAP_SYMBOL, GoogleSQLParserMATCH_SYMBOL, GoogleSQLParserKW_MATCH_RECOGNIZE_NONRESERVED_SYMBOL, GoogleSQLParserMATCHED_SYMBOL, GoogleSQLParserMATERIALIZED_SYMBOL, GoogleSQLParserMAX_SYMBOL, GoogleSQLParserMAXVALUE_SYMBOL, GoogleSQLParserMEASURES_SYMBOL, GoogleSQLParserMESSAGE_SYMBOL, GoogleSQLParserMETADATA_SYMBOL, GoogleSQLParserMIN_SYMBOL, GoogleSQLParserMINVALUE_SYMBOL, GoogleSQLParserMODEL_SYMBOL, GoogleSQLParserMODULE_SYMBOL, GoogleSQLParserONLY_SYMBOL, GoogleSQLParserOUT_SYMBOL, GoogleSQLParserOUTPUT_SYMBOL, GoogleSQLParserOVERWRITE_SYMBOL, GoogleSQLParserPARTITIONS_SYMBOL, GoogleSQLParserPATTERN_SYMBOL, GoogleSQLParserPOLICIES_SYMBOL, GoogleSQLParserPOLICY_SYMBOL, GoogleSQLParserPRIMARY_SYMBOL, GoogleSQLParserPRIVATE_SYMBOL, GoogleSQLParserPRIVILEGE_SYMBOL, GoogleSQLParserPRIVILEGES_SYMBOL, GoogleSQLParserPROCEDURE_SYMBOL, GoogleSQLParserPROJECT_SYMBOL, GoogleSQLParserPUBLIC_SYMBOL, GoogleSQLParserRAISE_SYMBOL, GoogleSQLParserREAD_SYMBOL, GoogleSQLParserREFERENCES_SYMBOL, GoogleSQLParserREMOTE_SYMBOL, GoogleSQLParserREMOVE_SYMBOL, GoogleSQLParserRENAME_SYMBOL, GoogleSQLParserREPEAT_SYMBOL, GoogleSQLParserREPEATABLE_SYMBOL, GoogleSQLParserREPLACE_FIELDS_SYMBOL, GoogleSQLParserREPLICA_SYMBOL, GoogleSQLParserREPORT_SYMBOL, GoogleSQLParserRESTRICT_SYMBOL, GoogleSQLParserRESTRICTION_SYMBOL, GoogleSQLParserRETURNS_SYMBOL, GoogleSQLParserRETURN_SYMBOL, GoogleSQLParserREVOKE_SYMBOL, GoogleSQLParserROLLBACK_SYMBOL, GoogleSQLParserROW_SYMBOL, GoogleSQLParserRUN_SYMBOL, GoogleSQLParserSAFE_CAST_SYMBOL, GoogleSQLParserSCHEMA_SYMBOL, GoogleSQLParserSEARCH_SYMBOL, GoogleSQLParserSECURITY_SYMBOL, GoogleSQLParserSEQUENCE_SYMBOL, GoogleSQLParserSETS_SYMBOL, GoogleSQLParserSHOW_SYMBOL, GoogleSQLParserSNAPSHOT_SYMBOL, GoogleSQLParserSOURCE_SYMBOL, GoogleSQLParserSQL_SYMBOL, GoogleSQLParserSTABLE_SYMBOL, GoogleSQLParserSTART_SYMBOL, GoogleSQLParserSTATIC_DESCRIBE_SYMBOL, GoogleSQLParserSTORED_SYMBOL, GoogleSQLParserSTORING_SYMBOL, GoogleSQLParserSTRICT_SYMBOL, GoogleSQLParserTABLE_SYMBOL, GoogleSQLParserTABLES_SYMBOL, GoogleSQLParserTARGET_SYMBOL, GoogleSQLParserTEMP_SYMBOL, GoogleSQLParserTEMPORARY_SYMBOL, GoogleSQLParserTRANSACTION_SYMBOL, GoogleSQLParserTRANSFORM_SYMBOL, GoogleSQLParserTRUNCATE_SYMBOL, GoogleSQLParserTYPE_SYMBOL, GoogleSQLParserUNDROP_SYMBOL, GoogleSQLParserUNIQUE_SYMBOL, GoogleSQLParserUNKNOWN_SYMBOL, GoogleSQLParserUNTIL_SYMBOL, GoogleSQLParserUPDATE_SYMBOL, GoogleSQLParserVALUES_SYMBOL, GoogleSQLParserVECTOR_SYMBOL, GoogleSQLParserVIEW_SYMBOL, GoogleSQLParserVIEWS_SYMBOL, GoogleSQLParserVOLATILE_SYMBOL, GoogleSQLParserWEIGHT_SYMBOL, GoogleSQLParserWHILE_SYMBOL, GoogleSQLParserWRITE_SYMBOL, GoogleSQLParserZONE_SYMBOL, GoogleSQLParserDESCRIPTOR_SYMBOL, GoogleSQLParserINTERLEAVE_SYMBOL, GoogleSQLParserNULL_FILTERED_SYMBOL, GoogleSQLParserPARENT_SYMBOL, GoogleSQLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1366)
			p.Maybe_dashed_path_expression()
		}


	case GoogleSQLParserSLASH_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1367)
			p.Slashed_path_expression()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMaybe_dashed_path_expressionContext is an interface to support dynamic dispatch.
type IMaybe_dashed_path_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Path_expression() IPath_expressionContext
	Dashed_path_expression() IDashed_path_expressionContext

	// IsMaybe_dashed_path_expressionContext differentiates from other interfaces.
	IsMaybe_dashed_path_expressionContext()
}

type Maybe_dashed_path_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaybe_dashed_path_expressionContext() *Maybe_dashed_path_expressionContext {
	var p = new(Maybe_dashed_path_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_maybe_dashed_path_expression
	return p
}

func InitEmptyMaybe_dashed_path_expressionContext(p *Maybe_dashed_path_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_maybe_dashed_path_expression
}

func (*Maybe_dashed_path_expressionContext) IsMaybe_dashed_path_expressionContext() {}

func NewMaybe_dashed_path_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Maybe_dashed_path_expressionContext {
	var p = new(Maybe_dashed_path_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_maybe_dashed_path_expression

	return p
}

func (s *Maybe_dashed_path_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Maybe_dashed_path_expressionContext) Path_expression() IPath_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPath_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPath_expressionContext)
}

func (s *Maybe_dashed_path_expressionContext) Dashed_path_expression() IDashed_path_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDashed_path_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDashed_path_expressionContext)
}

func (s *Maybe_dashed_path_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Maybe_dashed_path_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Maybe_dashed_path_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterMaybe_dashed_path_expression(s)
	}
}

func (s *Maybe_dashed_path_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitMaybe_dashed_path_expression(s)
	}
}

func (s *Maybe_dashed_path_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitMaybe_dashed_path_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Maybe_dashed_path_expression() (localctx IMaybe_dashed_path_expressionContext) {
	localctx = NewMaybe_dashed_path_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, GoogleSQLParserRULE_maybe_dashed_path_expression)
	p.SetState(1372)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1370)
			p.path_expression(0)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1371)
			p.dashed_path_expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDashed_path_expressionContext is an interface to support dynamic dispatch.
type IDashed_path_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Dashed_identifier() IDashed_identifierContext
	Dashed_path_expression() IDashed_path_expressionContext
	DOT_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDashed_path_expressionContext differentiates from other interfaces.
	IsDashed_path_expressionContext()
}

type Dashed_path_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDashed_path_expressionContext() *Dashed_path_expressionContext {
	var p = new(Dashed_path_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_dashed_path_expression
	return p
}

func InitEmptyDashed_path_expressionContext(p *Dashed_path_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_dashed_path_expression
}

func (*Dashed_path_expressionContext) IsDashed_path_expressionContext() {}

func NewDashed_path_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dashed_path_expressionContext {
	var p = new(Dashed_path_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_dashed_path_expression

	return p
}

func (s *Dashed_path_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Dashed_path_expressionContext) Dashed_identifier() IDashed_identifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDashed_identifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDashed_identifierContext)
}

func (s *Dashed_path_expressionContext) Dashed_path_expression() IDashed_path_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDashed_path_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDashed_path_expressionContext)
}

func (s *Dashed_path_expressionContext) DOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDOT_SYMBOL, 0)
}

func (s *Dashed_path_expressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Dashed_path_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dashed_path_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Dashed_path_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterDashed_path_expression(s)
	}
}

func (s *Dashed_path_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitDashed_path_expression(s)
	}
}

func (s *Dashed_path_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitDashed_path_expression(s)

	default:
		return t.VisitChildren(s)
	}
}





func (p *GoogleSQLParser) Dashed_path_expression() (localctx IDashed_path_expressionContext) {
	return p.dashed_path_expression(0)
}

func (p *GoogleSQLParser) dashed_path_expression(_p int) (localctx IDashed_path_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewDashed_path_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IDashed_path_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 162
	p.EnterRecursionRule(localctx, 162, GoogleSQLParserRULE_dashed_path_expression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1375)
		p.dashed_identifier(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1382)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewDashed_path_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_dashed_path_expression)
			p.SetState(1377)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(1378)
				p.Match(GoogleSQLParserDOT_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1379)
				p.Identifier()
			}


		}
		p.SetState(1384)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDashed_identifierContext is an interface to support dynamic dispatch.
type IDashed_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	DASH_SYMBOL() antlr.TerminalNode
	INTEGER_LITERAL() antlr.TerminalNode
	Floating_point_literal() IFloating_point_literalContext
	AllDashed_identifier() []IDashed_identifierContext
	Dashed_identifier(i int) IDashed_identifierContext

	// IsDashed_identifierContext differentiates from other interfaces.
	IsDashed_identifierContext()
}

type Dashed_identifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDashed_identifierContext() *Dashed_identifierContext {
	var p = new(Dashed_identifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_dashed_identifier
	return p
}

func InitEmptyDashed_identifierContext(p *Dashed_identifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_dashed_identifier
}

func (*Dashed_identifierContext) IsDashed_identifierContext() {}

func NewDashed_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dashed_identifierContext {
	var p = new(Dashed_identifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_dashed_identifier

	return p
}

func (s *Dashed_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Dashed_identifierContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Dashed_identifierContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Dashed_identifierContext) DASH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDASH_SYMBOL, 0)
}

func (s *Dashed_identifierContext) INTEGER_LITERAL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINTEGER_LITERAL, 0)
}

func (s *Dashed_identifierContext) Floating_point_literal() IFloating_point_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloating_point_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloating_point_literalContext)
}

func (s *Dashed_identifierContext) AllDashed_identifier() []IDashed_identifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDashed_identifierContext); ok {
			len++
		}
	}

	tst := make([]IDashed_identifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDashed_identifierContext); ok {
			tst[i] = t.(IDashed_identifierContext)
			i++
		}
	}

	return tst
}

func (s *Dashed_identifierContext) Dashed_identifier(i int) IDashed_identifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDashed_identifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDashed_identifierContext)
}

func (s *Dashed_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dashed_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Dashed_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterDashed_identifier(s)
	}
}

func (s *Dashed_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitDashed_identifier(s)
	}
}

func (s *Dashed_identifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitDashed_identifier(s)

	default:
		return t.VisitChildren(s)
	}
}





func (p *GoogleSQLParser) Dashed_identifier() (localctx IDashed_identifierContext) {
	return p.dashed_identifier(0)
}

func (p *GoogleSQLParser) dashed_identifier(_p int) (localctx IDashed_identifierContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewDashed_identifierContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IDashed_identifierContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 164
	p.EnterRecursionRule(localctx, 164, GoogleSQLParserRULE_dashed_identifier, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1386)
			p.Identifier()
		}
		{
			p.SetState(1387)
			p.Match(GoogleSQLParserDASH_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1388)
			p.Identifier()
		}


	case 2:
		{
			p.SetState(1390)
			p.Identifier()
		}
		{
			p.SetState(1391)
			p.Match(GoogleSQLParserDASH_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1392)
			p.Match(GoogleSQLParserINTEGER_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		{
			p.SetState(1394)
			p.Identifier()
		}
		{
			p.SetState(1395)
			p.Match(GoogleSQLParserDASH_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1396)
			p.Floating_point_literal()
		}
		{
			p.SetState(1397)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1412)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) {
			case 1:
				localctx = NewDashed_identifierContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_dashed_identifier)
				p.SetState(1401)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(1402)
					p.Match(GoogleSQLParserDASH_SYMBOL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(1403)
					p.dashed_identifier(6)
				}


			case 2:
				localctx = NewDashed_identifierContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_dashed_identifier)
				p.SetState(1404)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(1405)
					p.Match(GoogleSQLParserDASH_SYMBOL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(1406)
					p.Match(GoogleSQLParserINTEGER_LITERAL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			case 3:
				localctx = NewDashed_identifierContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_dashed_identifier)
				p.SetState(1407)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(1408)
					p.Match(GoogleSQLParserDASH_SYMBOL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(1409)
					p.Floating_point_literal()
				}
				{
					p.SetState(1410)
					p.Identifier()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1416)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISlashed_identifierContext is an interface to support dynamic dispatch.
type ISlashed_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SLASH_SYMBOL() antlr.TerminalNode
	Identifier_or_integer() IIdentifier_or_integerContext
	Slashed_identifier() ISlashed_identifierContext
	AllSlashed_identifier_separator() []ISlashed_identifier_separatorContext
	Slashed_identifier_separator(i int) ISlashed_identifier_separatorContext
	Floating_point_literal() IFloating_point_literalContext

	// IsSlashed_identifierContext differentiates from other interfaces.
	IsSlashed_identifierContext()
}

type Slashed_identifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySlashed_identifierContext() *Slashed_identifierContext {
	var p = new(Slashed_identifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_slashed_identifier
	return p
}

func InitEmptySlashed_identifierContext(p *Slashed_identifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_slashed_identifier
}

func (*Slashed_identifierContext) IsSlashed_identifierContext() {}

func NewSlashed_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Slashed_identifierContext {
	var p = new(Slashed_identifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_slashed_identifier

	return p
}

func (s *Slashed_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Slashed_identifierContext) SLASH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSLASH_SYMBOL, 0)
}

func (s *Slashed_identifierContext) Identifier_or_integer() IIdentifier_or_integerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifier_or_integerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifier_or_integerContext)
}

func (s *Slashed_identifierContext) Slashed_identifier() ISlashed_identifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISlashed_identifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISlashed_identifierContext)
}

func (s *Slashed_identifierContext) AllSlashed_identifier_separator() []ISlashed_identifier_separatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISlashed_identifier_separatorContext); ok {
			len++
		}
	}

	tst := make([]ISlashed_identifier_separatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISlashed_identifier_separatorContext); ok {
			tst[i] = t.(ISlashed_identifier_separatorContext)
			i++
		}
	}

	return tst
}

func (s *Slashed_identifierContext) Slashed_identifier_separator(i int) ISlashed_identifier_separatorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISlashed_identifier_separatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISlashed_identifier_separatorContext)
}

func (s *Slashed_identifierContext) Floating_point_literal() IFloating_point_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloating_point_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloating_point_literalContext)
}

func (s *Slashed_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Slashed_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Slashed_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSlashed_identifier(s)
	}
}

func (s *Slashed_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSlashed_identifier(s)
	}
}

func (s *Slashed_identifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSlashed_identifier(s)

	default:
		return t.VisitChildren(s)
	}
}





func (p *GoogleSQLParser) Slashed_identifier() (localctx ISlashed_identifierContext) {
	return p.slashed_identifier(0)
}

func (p *GoogleSQLParser) slashed_identifier(_p int) (localctx ISlashed_identifierContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewSlashed_identifierContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISlashed_identifierContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 166
	p.EnterRecursionRule(localctx, 166, GoogleSQLParserRULE_slashed_identifier, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1418)
		p.Match(GoogleSQLParserSLASH_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1419)
		p.Identifier_or_integer()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1433)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1431)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 128, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSlashed_identifierContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_slashed_identifier)
				p.SetState(1421)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(1422)
					p.Slashed_identifier_separator()
				}
				{
					p.SetState(1423)
					p.Identifier_or_integer()
				}


			case 2:
				localctx = NewSlashed_identifierContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_slashed_identifier)
				p.SetState(1425)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(1426)
					p.Slashed_identifier_separator()
				}
				{
					p.SetState(1427)
					p.Floating_point_literal()
				}
				{
					p.SetState(1428)
					p.Slashed_identifier_separator()
				}
				{
					p.SetState(1429)
					p.Identifier_or_integer()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1435)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIdentifier_or_integerContext is an interface to support dynamic dispatch.
type IIdentifier_or_integerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	INTEGER_LITERAL() antlr.TerminalNode

	// IsIdentifier_or_integerContext differentiates from other interfaces.
	IsIdentifier_or_integerContext()
}

type Identifier_or_integerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifier_or_integerContext() *Identifier_or_integerContext {
	var p = new(Identifier_or_integerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_identifier_or_integer
	return p
}

func InitEmptyIdentifier_or_integerContext(p *Identifier_or_integerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_identifier_or_integer
}

func (*Identifier_or_integerContext) IsIdentifier_or_integerContext() {}

func NewIdentifier_or_integerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Identifier_or_integerContext {
	var p = new(Identifier_or_integerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_identifier_or_integer

	return p
}

func (s *Identifier_or_integerContext) GetParser() antlr.Parser { return s.parser }

func (s *Identifier_or_integerContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Identifier_or_integerContext) INTEGER_LITERAL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINTEGER_LITERAL, 0)
}

func (s *Identifier_or_integerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Identifier_or_integerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Identifier_or_integerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterIdentifier_or_integer(s)
	}
}

func (s *Identifier_or_integerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitIdentifier_or_integer(s)
	}
}

func (s *Identifier_or_integerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitIdentifier_or_integer(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Identifier_or_integer() (localctx IIdentifier_or_integerContext) {
	localctx = NewIdentifier_or_integerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, GoogleSQLParserRULE_identifier_or_integer)
	p.SetState(1438)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserINCLUDE_SYMBOL, GoogleSQLParserOFFSET_SYMBOL, GoogleSQLParserOPTIONS_SYMBOL, GoogleSQLParserPERCENT_SYMBOL, GoogleSQLParserPIVOT_SYMBOL, GoogleSQLParserREPLACE_SYMBOL, GoogleSQLParserUNPIVOT_SYMBOL, GoogleSQLParserSYSTEM_SYMBOL, GoogleSQLParserSYSTEM_TIME_SYMBOL, GoogleSQLParserVALUE_SYMBOL, GoogleSQLParserNUMERIC_SYMBOL, GoogleSQLParserDECIMAL_SYMBOL, GoogleSQLParserBIGNUMERIC_SYMBOL, GoogleSQLParserBIGDECIMAL_SYMBOL, GoogleSQLParserJSON_SYMBOL, GoogleSQLParserDATE_SYMBOL, GoogleSQLParserTIME_SYMBOL, GoogleSQLParserDATETIME_SYMBOL, GoogleSQLParserTIMESTAMP_SYMBOL, GoogleSQLParserSIMPLE_SYMBOL, GoogleSQLParserABORT_SYMBOL, GoogleSQLParserACCESS_SYMBOL, GoogleSQLParserACTION_SYMBOL, GoogleSQLParserAGGREGATE_SYMBOL, GoogleSQLParserADD_SYMBOL, GoogleSQLParserALTER_SYMBOL, GoogleSQLParserALWAYS_SYMBOL, GoogleSQLParserANALYZE_SYMBOL, GoogleSQLParserAPPROX_SYMBOL, GoogleSQLParserARE_SYMBOL, GoogleSQLParserASSERT_SYMBOL, GoogleSQLParserBATCH_SYMBOL, GoogleSQLParserBEGIN_SYMBOL, GoogleSQLParserBREAK_SYMBOL, GoogleSQLParserCALL_SYMBOL, GoogleSQLParserCASCADE_SYMBOL, GoogleSQLParserCHECK_SYMBOL, GoogleSQLParserCLAMPED_SYMBOL, GoogleSQLParserCLONE_SYMBOL, GoogleSQLParserCOPY_SYMBOL, GoogleSQLParserCLUSTER_SYMBOL, GoogleSQLParserCOLUMN_SYMBOL, GoogleSQLParserCOLUMNS_SYMBOL, GoogleSQLParserCOMMIT_SYMBOL, GoogleSQLParserCONNECTION_SYMBOL, GoogleSQLParserCONSTANT_SYMBOL, GoogleSQLParserCONSTRAINT_SYMBOL, GoogleSQLParserCONTINUE_SYMBOL, GoogleSQLParserCORRESPONDING_SYMBOL, GoogleSQLParserCYCLE_SYMBOL, GoogleSQLParserDATA_SYMBOL, GoogleSQLParserDATABASE_SYMBOL, GoogleSQLParserDECLARE_SYMBOL, GoogleSQLParserDEFINER_SYMBOL, GoogleSQLParserDELETE_SYMBOL, GoogleSQLParserDELETION_SYMBOL, GoogleSQLParserDEPTH_SYMBOL, GoogleSQLParserDESCRIBE_SYMBOL, GoogleSQLParserDETERMINISTIC_SYMBOL, GoogleSQLParserDO_SYMBOL, GoogleSQLParserDROP_SYMBOL, GoogleSQLParserELSEIF_SYMBOL, GoogleSQLParserENFORCED_SYMBOL, GoogleSQLParserERROR_SYMBOL, GoogleSQLParserEXCEPTION_SYMBOL, GoogleSQLParserEXECUTE_SYMBOL, GoogleSQLParserEXPLAIN_SYMBOL, GoogleSQLParserEXPORT_SYMBOL, GoogleSQLParserEXTEND_SYMBOL, GoogleSQLParserEXTERNAL_SYMBOL, GoogleSQLParserFILES_SYMBOL, GoogleSQLParserFILTER_SYMBOL, GoogleSQLParserFILL_SYMBOL, GoogleSQLParserFIRST_SYMBOL, GoogleSQLParserFOREIGN_SYMBOL, GoogleSQLParserFORMAT_SYMBOL, GoogleSQLParserFUNCTION_SYMBOL, GoogleSQLParserGENERATED_SYMBOL, GoogleSQLParserGRANT_SYMBOL, GoogleSQLParserGROUP_ROWS_SYMBOL, GoogleSQLParserHIDDEN_SYMBOL, GoogleSQLParserIDENTITY_SYMBOL, GoogleSQLParserIMMEDIATE_SYMBOL, GoogleSQLParserIMMUTABLE_SYMBOL, GoogleSQLParserIMPORT_SYMBOL, GoogleSQLParserINCREMENT_SYMBOL, GoogleSQLParserINDEX_SYMBOL, GoogleSQLParserINOUT_SYMBOL, GoogleSQLParserINPUT_SYMBOL, GoogleSQLParserINSERT_SYMBOL, GoogleSQLParserINVOKER_SYMBOL, GoogleSQLParserISOLATION_SYMBOL, GoogleSQLParserITERATE_SYMBOL, GoogleSQLParserKEY_SYMBOL, GoogleSQLParserLANGUAGE_SYMBOL, GoogleSQLParserLAST_SYMBOL, GoogleSQLParserLEAVE_SYMBOL, GoogleSQLParserLEVEL_SYMBOL, GoogleSQLParserLOAD_SYMBOL, GoogleSQLParserLOOP_SYMBOL, GoogleSQLParserMACRO_SYMBOL, GoogleSQLParserMAP_SYMBOL, GoogleSQLParserMATCH_SYMBOL, GoogleSQLParserKW_MATCH_RECOGNIZE_NONRESERVED_SYMBOL, GoogleSQLParserMATCHED_SYMBOL, GoogleSQLParserMATERIALIZED_SYMBOL, GoogleSQLParserMAX_SYMBOL, GoogleSQLParserMAXVALUE_SYMBOL, GoogleSQLParserMEASURES_SYMBOL, GoogleSQLParserMESSAGE_SYMBOL, GoogleSQLParserMETADATA_SYMBOL, GoogleSQLParserMIN_SYMBOL, GoogleSQLParserMINVALUE_SYMBOL, GoogleSQLParserMODEL_SYMBOL, GoogleSQLParserMODULE_SYMBOL, GoogleSQLParserONLY_SYMBOL, GoogleSQLParserOUT_SYMBOL, GoogleSQLParserOUTPUT_SYMBOL, GoogleSQLParserOVERWRITE_SYMBOL, GoogleSQLParserPARTITIONS_SYMBOL, GoogleSQLParserPATTERN_SYMBOL, GoogleSQLParserPOLICIES_SYMBOL, GoogleSQLParserPOLICY_SYMBOL, GoogleSQLParserPRIMARY_SYMBOL, GoogleSQLParserPRIVATE_SYMBOL, GoogleSQLParserPRIVILEGE_SYMBOL, GoogleSQLParserPRIVILEGES_SYMBOL, GoogleSQLParserPROCEDURE_SYMBOL, GoogleSQLParserPROJECT_SYMBOL, GoogleSQLParserPUBLIC_SYMBOL, GoogleSQLParserRAISE_SYMBOL, GoogleSQLParserREAD_SYMBOL, GoogleSQLParserREFERENCES_SYMBOL, GoogleSQLParserREMOTE_SYMBOL, GoogleSQLParserREMOVE_SYMBOL, GoogleSQLParserRENAME_SYMBOL, GoogleSQLParserREPEAT_SYMBOL, GoogleSQLParserREPEATABLE_SYMBOL, GoogleSQLParserREPLACE_FIELDS_SYMBOL, GoogleSQLParserREPLICA_SYMBOL, GoogleSQLParserREPORT_SYMBOL, GoogleSQLParserRESTRICT_SYMBOL, GoogleSQLParserRESTRICTION_SYMBOL, GoogleSQLParserRETURNS_SYMBOL, GoogleSQLParserRETURN_SYMBOL, GoogleSQLParserREVOKE_SYMBOL, GoogleSQLParserROLLBACK_SYMBOL, GoogleSQLParserROW_SYMBOL, GoogleSQLParserRUN_SYMBOL, GoogleSQLParserSAFE_CAST_SYMBOL, GoogleSQLParserSCHEMA_SYMBOL, GoogleSQLParserSEARCH_SYMBOL, GoogleSQLParserSECURITY_SYMBOL, GoogleSQLParserSEQUENCE_SYMBOL, GoogleSQLParserSETS_SYMBOL, GoogleSQLParserSHOW_SYMBOL, GoogleSQLParserSNAPSHOT_SYMBOL, GoogleSQLParserSOURCE_SYMBOL, GoogleSQLParserSQL_SYMBOL, GoogleSQLParserSTABLE_SYMBOL, GoogleSQLParserSTART_SYMBOL, GoogleSQLParserSTATIC_DESCRIBE_SYMBOL, GoogleSQLParserSTORED_SYMBOL, GoogleSQLParserSTORING_SYMBOL, GoogleSQLParserSTRICT_SYMBOL, GoogleSQLParserTABLE_SYMBOL, GoogleSQLParserTABLES_SYMBOL, GoogleSQLParserTARGET_SYMBOL, GoogleSQLParserTEMP_SYMBOL, GoogleSQLParserTEMPORARY_SYMBOL, GoogleSQLParserTRANSACTION_SYMBOL, GoogleSQLParserTRANSFORM_SYMBOL, GoogleSQLParserTRUNCATE_SYMBOL, GoogleSQLParserTYPE_SYMBOL, GoogleSQLParserUNDROP_SYMBOL, GoogleSQLParserUNIQUE_SYMBOL, GoogleSQLParserUNKNOWN_SYMBOL, GoogleSQLParserUNTIL_SYMBOL, GoogleSQLParserUPDATE_SYMBOL, GoogleSQLParserVALUES_SYMBOL, GoogleSQLParserVECTOR_SYMBOL, GoogleSQLParserVIEW_SYMBOL, GoogleSQLParserVIEWS_SYMBOL, GoogleSQLParserVOLATILE_SYMBOL, GoogleSQLParserWEIGHT_SYMBOL, GoogleSQLParserWHILE_SYMBOL, GoogleSQLParserWRITE_SYMBOL, GoogleSQLParserZONE_SYMBOL, GoogleSQLParserDESCRIPTOR_SYMBOL, GoogleSQLParserINTERLEAVE_SYMBOL, GoogleSQLParserNULL_FILTERED_SYMBOL, GoogleSQLParserPARENT_SYMBOL, GoogleSQLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1436)
			p.Identifier()
		}


	case GoogleSQLParserINTEGER_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1437)
			p.Match(GoogleSQLParserINTEGER_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISlashed_identifier_separatorContext is an interface to support dynamic dispatch.
type ISlashed_identifier_separatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DASH_SYMBOL() antlr.TerminalNode
	SLASH_SYMBOL() antlr.TerminalNode
	COLON_SYMBOL() antlr.TerminalNode

	// IsSlashed_identifier_separatorContext differentiates from other interfaces.
	IsSlashed_identifier_separatorContext()
}

type Slashed_identifier_separatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySlashed_identifier_separatorContext() *Slashed_identifier_separatorContext {
	var p = new(Slashed_identifier_separatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_slashed_identifier_separator
	return p
}

func InitEmptySlashed_identifier_separatorContext(p *Slashed_identifier_separatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_slashed_identifier_separator
}

func (*Slashed_identifier_separatorContext) IsSlashed_identifier_separatorContext() {}

func NewSlashed_identifier_separatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Slashed_identifier_separatorContext {
	var p = new(Slashed_identifier_separatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_slashed_identifier_separator

	return p
}

func (s *Slashed_identifier_separatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Slashed_identifier_separatorContext) DASH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDASH_SYMBOL, 0)
}

func (s *Slashed_identifier_separatorContext) SLASH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSLASH_SYMBOL, 0)
}

func (s *Slashed_identifier_separatorContext) COLON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOLON_SYMBOL, 0)
}

func (s *Slashed_identifier_separatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Slashed_identifier_separatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Slashed_identifier_separatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSlashed_identifier_separator(s)
	}
}

func (s *Slashed_identifier_separatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSlashed_identifier_separator(s)
	}
}

func (s *Slashed_identifier_separatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSlashed_identifier_separator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Slashed_identifier_separator() (localctx ISlashed_identifier_separatorContext) {
	localctx = NewSlashed_identifier_separatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, GoogleSQLParserRULE_slashed_identifier_separator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1440)
		p.Match(GoogleSQLParserDASH_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1441)
		p.Match(GoogleSQLParserSLASH_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1442)
		p.Match(GoogleSQLParserCOLON_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISlashed_path_expressionContext is an interface to support dynamic dispatch.
type ISlashed_path_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Slashed_identifier() ISlashed_identifierContext
	Slashed_identifier_separator() ISlashed_identifier_separatorContext
	Floating_point_literal() IFloating_point_literalContext
	Identifier() IIdentifierContext

	// IsSlashed_path_expressionContext differentiates from other interfaces.
	IsSlashed_path_expressionContext()
}

type Slashed_path_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySlashed_path_expressionContext() *Slashed_path_expressionContext {
	var p = new(Slashed_path_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_slashed_path_expression
	return p
}

func InitEmptySlashed_path_expressionContext(p *Slashed_path_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_slashed_path_expression
}

func (*Slashed_path_expressionContext) IsSlashed_path_expressionContext() {}

func NewSlashed_path_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Slashed_path_expressionContext {
	var p = new(Slashed_path_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_slashed_path_expression

	return p
}

func (s *Slashed_path_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Slashed_path_expressionContext) Slashed_identifier() ISlashed_identifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISlashed_identifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISlashed_identifierContext)
}

func (s *Slashed_path_expressionContext) Slashed_identifier_separator() ISlashed_identifier_separatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISlashed_identifier_separatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISlashed_identifier_separatorContext)
}

func (s *Slashed_path_expressionContext) Floating_point_literal() IFloating_point_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloating_point_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloating_point_literalContext)
}

func (s *Slashed_path_expressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Slashed_path_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Slashed_path_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Slashed_path_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSlashed_path_expression(s)
	}
}

func (s *Slashed_path_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSlashed_path_expression(s)
	}
}

func (s *Slashed_path_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSlashed_path_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Slashed_path_expression() (localctx ISlashed_path_expressionContext) {
	localctx = NewSlashed_path_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, GoogleSQLParserRULE_slashed_path_expression)
	p.SetState(1450)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1444)
			p.slashed_identifier(0)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1445)
			p.slashed_identifier(0)
		}
		{
			p.SetState(1446)
			p.Slashed_identifier_separator()
		}
		{
			p.SetState(1447)
			p.Floating_point_literal()
		}
		{
			p.SetState(1448)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnnest_expressionContext is an interface to support dynamic dispatch.
type IUnnest_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Unnest_expression_prefix() IUnnest_expression_prefixContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	Opt_array_zip_mode() IOpt_array_zip_modeContext
	UNNEST_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	SELECT_SYMBOL() antlr.TerminalNode

	// IsUnnest_expressionContext differentiates from other interfaces.
	IsUnnest_expressionContext()
}

type Unnest_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnnest_expressionContext() *Unnest_expressionContext {
	var p = new(Unnest_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_unnest_expression
	return p
}

func InitEmptyUnnest_expressionContext(p *Unnest_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_unnest_expression
}

func (*Unnest_expressionContext) IsUnnest_expressionContext() {}

func NewUnnest_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unnest_expressionContext {
	var p = new(Unnest_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_unnest_expression

	return p
}

func (s *Unnest_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Unnest_expressionContext) Unnest_expression_prefix() IUnnest_expression_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnnest_expression_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnnest_expression_prefixContext)
}

func (s *Unnest_expressionContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Unnest_expressionContext) Opt_array_zip_mode() IOpt_array_zip_modeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_array_zip_modeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_array_zip_modeContext)
}

func (s *Unnest_expressionContext) UNNEST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserUNNEST_SYMBOL, 0)
}

func (s *Unnest_expressionContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Unnest_expressionContext) SELECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSELECT_SYMBOL, 0)
}

func (s *Unnest_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unnest_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Unnest_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterUnnest_expression(s)
	}
}

func (s *Unnest_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitUnnest_expression(s)
	}
}

func (s *Unnest_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitUnnest_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Unnest_expression() (localctx IUnnest_expressionContext) {
	localctx = NewUnnest_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, GoogleSQLParserRULE_unnest_expression)
	var _la int

	p.SetState(1462)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1452)
			p.Unnest_expression_prefix()
		}
		p.SetState(1454)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserCOMMA_SYMBOL {
			{
				p.SetState(1453)
				p.Opt_array_zip_mode()
			}

		}
		{
			p.SetState(1456)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1458)
			p.Match(GoogleSQLParserUNNEST_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1459)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1460)
			p.Match(GoogleSQLParserSELECT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.NotifyErrorListeners("The argument to UNNEST is an expression, not a query; to use a query "
		        "as an expression, the query must be wrapped with additional "
		        "parentheses to make it a scalar subquery expression", nil, nil)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnnest_expression_prefixContext is an interface to support dynamic dispatch.
type IUnnest_expression_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNNEST_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	AllExpression_with_opt_alias() []IExpression_with_opt_aliasContext
	Expression_with_opt_alias(i int) IExpression_with_opt_aliasContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsUnnest_expression_prefixContext differentiates from other interfaces.
	IsUnnest_expression_prefixContext()
}

type Unnest_expression_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnnest_expression_prefixContext() *Unnest_expression_prefixContext {
	var p = new(Unnest_expression_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_unnest_expression_prefix
	return p
}

func InitEmptyUnnest_expression_prefixContext(p *Unnest_expression_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_unnest_expression_prefix
}

func (*Unnest_expression_prefixContext) IsUnnest_expression_prefixContext() {}

func NewUnnest_expression_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unnest_expression_prefixContext {
	var p = new(Unnest_expression_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_unnest_expression_prefix

	return p
}

func (s *Unnest_expression_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Unnest_expression_prefixContext) UNNEST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserUNNEST_SYMBOL, 0)
}

func (s *Unnest_expression_prefixContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Unnest_expression_prefixContext) AllExpression_with_opt_alias() []IExpression_with_opt_aliasContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpression_with_opt_aliasContext); ok {
			len++
		}
	}

	tst := make([]IExpression_with_opt_aliasContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpression_with_opt_aliasContext); ok {
			tst[i] = t.(IExpression_with_opt_aliasContext)
			i++
		}
	}

	return tst
}

func (s *Unnest_expression_prefixContext) Expression_with_opt_alias(i int) IExpression_with_opt_aliasContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpression_with_opt_aliasContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpression_with_opt_aliasContext)
}

func (s *Unnest_expression_prefixContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Unnest_expression_prefixContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Unnest_expression_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unnest_expression_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Unnest_expression_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterUnnest_expression_prefix(s)
	}
}

func (s *Unnest_expression_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitUnnest_expression_prefix(s)
	}
}

func (s *Unnest_expression_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitUnnest_expression_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Unnest_expression_prefix() (localctx IUnnest_expression_prefixContext) {
	localctx = NewUnnest_expression_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, GoogleSQLParserRULE_unnest_expression_prefix)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1464)
		p.Match(GoogleSQLParserUNNEST_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1465)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1466)
		p.Expression_with_opt_alias()
	}
	p.SetState(1471)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1467)
				p.Match(GoogleSQLParserCOMMA_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1468)
				p.Expression_with_opt_alias()
			}


		}
		p.SetState(1473)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_array_zip_modeContext is an interface to support dynamic dispatch.
type IOpt_array_zip_modeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMA_SYMBOL() antlr.TerminalNode
	Named_argument() INamed_argumentContext

	// IsOpt_array_zip_modeContext differentiates from other interfaces.
	IsOpt_array_zip_modeContext()
}

type Opt_array_zip_modeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_array_zip_modeContext() *Opt_array_zip_modeContext {
	var p = new(Opt_array_zip_modeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_array_zip_mode
	return p
}

func InitEmptyOpt_array_zip_modeContext(p *Opt_array_zip_modeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_array_zip_mode
}

func (*Opt_array_zip_modeContext) IsOpt_array_zip_modeContext() {}

func NewOpt_array_zip_modeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_array_zip_modeContext {
	var p = new(Opt_array_zip_modeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_array_zip_mode

	return p
}

func (s *Opt_array_zip_modeContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_array_zip_modeContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, 0)
}

func (s *Opt_array_zip_modeContext) Named_argument() INamed_argumentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_argumentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_argumentContext)
}

func (s *Opt_array_zip_modeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_array_zip_modeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_array_zip_modeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_array_zip_mode(s)
	}
}

func (s *Opt_array_zip_modeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_array_zip_mode(s)
	}
}

func (s *Opt_array_zip_modeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_array_zip_mode(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_array_zip_mode() (localctx IOpt_array_zip_modeContext) {
	localctx = NewOpt_array_zip_modeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, GoogleSQLParserRULE_opt_array_zip_mode)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1474)
		p.Match(GoogleSQLParserCOMMA_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1475)
		p.Named_argument()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpression_with_opt_aliasContext is an interface to support dynamic dispatch.
type IExpression_with_opt_aliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Opt_as_alias_with_required_as() IOpt_as_alias_with_required_asContext

	// IsExpression_with_opt_aliasContext differentiates from other interfaces.
	IsExpression_with_opt_aliasContext()
}

type Expression_with_opt_aliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_with_opt_aliasContext() *Expression_with_opt_aliasContext {
	var p = new(Expression_with_opt_aliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_expression_with_opt_alias
	return p
}

func InitEmptyExpression_with_opt_aliasContext(p *Expression_with_opt_aliasContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_expression_with_opt_alias
}

func (*Expression_with_opt_aliasContext) IsExpression_with_opt_aliasContext() {}

func NewExpression_with_opt_aliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_with_opt_aliasContext {
	var p = new(Expression_with_opt_aliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_expression_with_opt_alias

	return p
}

func (s *Expression_with_opt_aliasContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_with_opt_aliasContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expression_with_opt_aliasContext) Opt_as_alias_with_required_as() IOpt_as_alias_with_required_asContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_as_alias_with_required_asContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_as_alias_with_required_asContext)
}

func (s *Expression_with_opt_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_with_opt_aliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expression_with_opt_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterExpression_with_opt_alias(s)
	}
}

func (s *Expression_with_opt_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitExpression_with_opt_alias(s)
	}
}

func (s *Expression_with_opt_aliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitExpression_with_opt_alias(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Expression_with_opt_alias() (localctx IExpression_with_opt_aliasContext) {
	localctx = NewExpression_with_opt_aliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, GoogleSQLParserRULE_expression_with_opt_alias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1477)
		p.expression(0)
	}
	p.SetState(1479)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserAS_SYMBOL {
		{
			p.SetState(1478)
			p.Opt_as_alias_with_required_as()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITvf_prefixContext is an interface to support dynamic dispatch.
type ITvf_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Tvf_prefix_no_args() ITvf_prefix_no_argsContext
	AllTvf_argument() []ITvf_argumentContext
	Tvf_argument(i int) ITvf_argumentContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsTvf_prefixContext differentiates from other interfaces.
	IsTvf_prefixContext()
}

type Tvf_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTvf_prefixContext() *Tvf_prefixContext {
	var p = new(Tvf_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_tvf_prefix
	return p
}

func InitEmptyTvf_prefixContext(p *Tvf_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_tvf_prefix
}

func (*Tvf_prefixContext) IsTvf_prefixContext() {}

func NewTvf_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tvf_prefixContext {
	var p = new(Tvf_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_tvf_prefix

	return p
}

func (s *Tvf_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Tvf_prefixContext) Tvf_prefix_no_args() ITvf_prefix_no_argsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITvf_prefix_no_argsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITvf_prefix_no_argsContext)
}

func (s *Tvf_prefixContext) AllTvf_argument() []ITvf_argumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITvf_argumentContext); ok {
			len++
		}
	}

	tst := make([]ITvf_argumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITvf_argumentContext); ok {
			tst[i] = t.(ITvf_argumentContext)
			i++
		}
	}

	return tst
}

func (s *Tvf_prefixContext) Tvf_argument(i int) ITvf_argumentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITvf_argumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITvf_argumentContext)
}

func (s *Tvf_prefixContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Tvf_prefixContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Tvf_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tvf_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Tvf_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterTvf_prefix(s)
	}
}

func (s *Tvf_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitTvf_prefix(s)
	}
}

func (s *Tvf_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitTvf_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Tvf_prefix() (localctx ITvf_prefixContext) {
	localctx = NewTvf_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, GoogleSQLParserRULE_tvf_prefix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1481)
		p.Tvf_prefix_no_args()
	}
	{
		p.SetState(1482)
		p.Tvf_argument()
	}
	p.SetState(1487)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(1483)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1484)
			p.Tvf_argument()
		}


		p.SetState(1489)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITvf_argumentContext is an interface to support dynamic dispatch.
type ITvf_argumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Descriptor_argument() IDescriptor_argumentContext
	Table_clause() ITable_clauseContext
	Model_clause() IModel_clauseContext
	Connection_clause() IConnection_clauseContext
	Named_argument() INamed_argumentContext
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	SELECT_SYMBOL() antlr.TerminalNode
	WITH_SYMBOL() antlr.TerminalNode

	// IsTvf_argumentContext differentiates from other interfaces.
	IsTvf_argumentContext()
}

type Tvf_argumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTvf_argumentContext() *Tvf_argumentContext {
	var p = new(Tvf_argumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_tvf_argument
	return p
}

func InitEmptyTvf_argumentContext(p *Tvf_argumentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_tvf_argument
}

func (*Tvf_argumentContext) IsTvf_argumentContext() {}

func NewTvf_argumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tvf_argumentContext {
	var p = new(Tvf_argumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_tvf_argument

	return p
}

func (s *Tvf_argumentContext) GetParser() antlr.Parser { return s.parser }

func (s *Tvf_argumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Tvf_argumentContext) Descriptor_argument() IDescriptor_argumentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptor_argumentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptor_argumentContext)
}

func (s *Tvf_argumentContext) Table_clause() ITable_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_clauseContext)
}

func (s *Tvf_argumentContext) Model_clause() IModel_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModel_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModel_clauseContext)
}

func (s *Tvf_argumentContext) Connection_clause() IConnection_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConnection_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConnection_clauseContext)
}

func (s *Tvf_argumentContext) Named_argument() INamed_argumentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_argumentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_argumentContext)
}

func (s *Tvf_argumentContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Tvf_argumentContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Tvf_argumentContext) SELECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSELECT_SYMBOL, 0)
}

func (s *Tvf_argumentContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWITH_SYMBOL, 0)
}

func (s *Tvf_argumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tvf_argumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Tvf_argumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterTvf_argument(s)
	}
}

func (s *Tvf_argumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitTvf_argument(s)
	}
}

func (s *Tvf_argumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitTvf_argument(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Tvf_argument() (localctx ITvf_argumentContext) {
	localctx = NewTvf_argumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, GoogleSQLParserRULE_tvf_argument)
	p.SetState(1520)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 137, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1490)
			p.expression(0)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1491)
			p.Descriptor_argument()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1492)
			p.Table_clause()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1493)
			p.Model_clause()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1494)
			p.Connection_clause()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1495)
			p.Named_argument()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1496)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1497)
			p.Table_clause()
		}
		{
			p.SetState(1498)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.NotifyErrorListeners("Syntax error: Table arguments for table-valued function "
		            "calls written as \"TABLE path\" must not be enclosed in "
		            "parentheses. To fix this, replace (TABLE path) with TABLE path",nil,nil)


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1501)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1502)
			p.Model_clause()
		}
		{
			p.SetState(1503)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.NotifyErrorListeners("Syntax error: Model arguments for table-valued function "
		            "calls written as \"MODEL path\" must not be enclosed in "
		            "parentheses. To fix this, replace (MODEL path) with MODEL path",nil,nil)


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1506)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1507)
			p.Connection_clause()
		}
		{
			p.SetState(1508)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.NotifyErrorListeners("Syntax error: Connection arguments for table-valued function "
		            "calls written as \"CONNECTION path\" must not be enclosed in "
		            "parentheses. To fix this, replace (CONNECTION path) with "
		            "CONNECTION path",nil,nil)


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1511)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1512)
			p.Named_argument()
		}
		{
			p.SetState(1513)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.NotifyErrorListeners("Syntax error: Named arguments for table-valued function "
		            "calls written as \"name => value\" must not be enclosed in "
		            "parentheses. To fix this, replace (name => value) with "
		            "name => value",nil,nil)


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1516)
			p.Match(GoogleSQLParserSELECT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.NotifyErrorListeners("Syntax error: Each subquery argument for table-valued function "
		            "calls must be enclosed in parentheses. To fix this, replace "
		            "SELECT... with (SELECT...)",nil,nil)


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1518)
			p.Match(GoogleSQLParserWITH_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.NotifyErrorListeners("Syntax error: Each subquery argument for table-valued function "
		            "calls must be enclosed in parentheses. To fix this, replace "
		            "WITH... with (WITH...)",nil,nil)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IConnection_clauseContext is an interface to support dynamic dispatch.
type IConnection_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONNECTION_SYMBOL() antlr.TerminalNode
	Path_expression_or_default() IPath_expression_or_defaultContext

	// IsConnection_clauseContext differentiates from other interfaces.
	IsConnection_clauseContext()
}

type Connection_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConnection_clauseContext() *Connection_clauseContext {
	var p = new(Connection_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_connection_clause
	return p
}

func InitEmptyConnection_clauseContext(p *Connection_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_connection_clause
}

func (*Connection_clauseContext) IsConnection_clauseContext() {}

func NewConnection_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Connection_clauseContext {
	var p = new(Connection_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_connection_clause

	return p
}

func (s *Connection_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Connection_clauseContext) CONNECTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCONNECTION_SYMBOL, 0)
}

func (s *Connection_clauseContext) Path_expression_or_default() IPath_expression_or_defaultContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPath_expression_or_defaultContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPath_expression_or_defaultContext)
}

func (s *Connection_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Connection_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Connection_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterConnection_clause(s)
	}
}

func (s *Connection_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitConnection_clause(s)
	}
}

func (s *Connection_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitConnection_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Connection_clause() (localctx IConnection_clauseContext) {
	localctx = NewConnection_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, GoogleSQLParserRULE_connection_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1522)
		p.Match(GoogleSQLParserCONNECTION_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1523)
		p.Path_expression_or_default()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPath_expression_or_defaultContext is an interface to support dynamic dispatch.
type IPath_expression_or_defaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Path_expression() IPath_expressionContext
	DEFAULT_SYMBOL() antlr.TerminalNode

	// IsPath_expression_or_defaultContext differentiates from other interfaces.
	IsPath_expression_or_defaultContext()
}

type Path_expression_or_defaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPath_expression_or_defaultContext() *Path_expression_or_defaultContext {
	var p = new(Path_expression_or_defaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_path_expression_or_default
	return p
}

func InitEmptyPath_expression_or_defaultContext(p *Path_expression_or_defaultContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_path_expression_or_default
}

func (*Path_expression_or_defaultContext) IsPath_expression_or_defaultContext() {}

func NewPath_expression_or_defaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Path_expression_or_defaultContext {
	var p = new(Path_expression_or_defaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_path_expression_or_default

	return p
}

func (s *Path_expression_or_defaultContext) GetParser() antlr.Parser { return s.parser }

func (s *Path_expression_or_defaultContext) Path_expression() IPath_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPath_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPath_expressionContext)
}

func (s *Path_expression_or_defaultContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDEFAULT_SYMBOL, 0)
}

func (s *Path_expression_or_defaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Path_expression_or_defaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Path_expression_or_defaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterPath_expression_or_default(s)
	}
}

func (s *Path_expression_or_defaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitPath_expression_or_default(s)
	}
}

func (s *Path_expression_or_defaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitPath_expression_or_default(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Path_expression_or_default() (localctx IPath_expression_or_defaultContext) {
	localctx = NewPath_expression_or_defaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, GoogleSQLParserRULE_path_expression_or_default)
	p.SetState(1527)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserINCLUDE_SYMBOL, GoogleSQLParserOFFSET_SYMBOL, GoogleSQLParserOPTIONS_SYMBOL, GoogleSQLParserPERCENT_SYMBOL, GoogleSQLParserPIVOT_SYMBOL, GoogleSQLParserREPLACE_SYMBOL, GoogleSQLParserUNPIVOT_SYMBOL, GoogleSQLParserSYSTEM_SYMBOL, GoogleSQLParserSYSTEM_TIME_SYMBOL, GoogleSQLParserVALUE_SYMBOL, GoogleSQLParserNUMERIC_SYMBOL, GoogleSQLParserDECIMAL_SYMBOL, GoogleSQLParserBIGNUMERIC_SYMBOL, GoogleSQLParserBIGDECIMAL_SYMBOL, GoogleSQLParserJSON_SYMBOL, GoogleSQLParserDATE_SYMBOL, GoogleSQLParserTIME_SYMBOL, GoogleSQLParserDATETIME_SYMBOL, GoogleSQLParserTIMESTAMP_SYMBOL, GoogleSQLParserSIMPLE_SYMBOL, GoogleSQLParserABORT_SYMBOL, GoogleSQLParserACCESS_SYMBOL, GoogleSQLParserACTION_SYMBOL, GoogleSQLParserAGGREGATE_SYMBOL, GoogleSQLParserADD_SYMBOL, GoogleSQLParserALTER_SYMBOL, GoogleSQLParserALWAYS_SYMBOL, GoogleSQLParserANALYZE_SYMBOL, GoogleSQLParserAPPROX_SYMBOL, GoogleSQLParserARE_SYMBOL, GoogleSQLParserASSERT_SYMBOL, GoogleSQLParserBATCH_SYMBOL, GoogleSQLParserBEGIN_SYMBOL, GoogleSQLParserBREAK_SYMBOL, GoogleSQLParserCALL_SYMBOL, GoogleSQLParserCASCADE_SYMBOL, GoogleSQLParserCHECK_SYMBOL, GoogleSQLParserCLAMPED_SYMBOL, GoogleSQLParserCLONE_SYMBOL, GoogleSQLParserCOPY_SYMBOL, GoogleSQLParserCLUSTER_SYMBOL, GoogleSQLParserCOLUMN_SYMBOL, GoogleSQLParserCOLUMNS_SYMBOL, GoogleSQLParserCOMMIT_SYMBOL, GoogleSQLParserCONNECTION_SYMBOL, GoogleSQLParserCONSTANT_SYMBOL, GoogleSQLParserCONSTRAINT_SYMBOL, GoogleSQLParserCONTINUE_SYMBOL, GoogleSQLParserCORRESPONDING_SYMBOL, GoogleSQLParserCYCLE_SYMBOL, GoogleSQLParserDATA_SYMBOL, GoogleSQLParserDATABASE_SYMBOL, GoogleSQLParserDECLARE_SYMBOL, GoogleSQLParserDEFINER_SYMBOL, GoogleSQLParserDELETE_SYMBOL, GoogleSQLParserDELETION_SYMBOL, GoogleSQLParserDEPTH_SYMBOL, GoogleSQLParserDESCRIBE_SYMBOL, GoogleSQLParserDETERMINISTIC_SYMBOL, GoogleSQLParserDO_SYMBOL, GoogleSQLParserDROP_SYMBOL, GoogleSQLParserELSEIF_SYMBOL, GoogleSQLParserENFORCED_SYMBOL, GoogleSQLParserERROR_SYMBOL, GoogleSQLParserEXCEPTION_SYMBOL, GoogleSQLParserEXECUTE_SYMBOL, GoogleSQLParserEXPLAIN_SYMBOL, GoogleSQLParserEXPORT_SYMBOL, GoogleSQLParserEXTEND_SYMBOL, GoogleSQLParserEXTERNAL_SYMBOL, GoogleSQLParserFILES_SYMBOL, GoogleSQLParserFILTER_SYMBOL, GoogleSQLParserFILL_SYMBOL, GoogleSQLParserFIRST_SYMBOL, GoogleSQLParserFOREIGN_SYMBOL, GoogleSQLParserFORMAT_SYMBOL, GoogleSQLParserFUNCTION_SYMBOL, GoogleSQLParserGENERATED_SYMBOL, GoogleSQLParserGRANT_SYMBOL, GoogleSQLParserGROUP_ROWS_SYMBOL, GoogleSQLParserHIDDEN_SYMBOL, GoogleSQLParserIDENTITY_SYMBOL, GoogleSQLParserIMMEDIATE_SYMBOL, GoogleSQLParserIMMUTABLE_SYMBOL, GoogleSQLParserIMPORT_SYMBOL, GoogleSQLParserINCREMENT_SYMBOL, GoogleSQLParserINDEX_SYMBOL, GoogleSQLParserINOUT_SYMBOL, GoogleSQLParserINPUT_SYMBOL, GoogleSQLParserINSERT_SYMBOL, GoogleSQLParserINVOKER_SYMBOL, GoogleSQLParserISOLATION_SYMBOL, GoogleSQLParserITERATE_SYMBOL, GoogleSQLParserKEY_SYMBOL, GoogleSQLParserLANGUAGE_SYMBOL, GoogleSQLParserLAST_SYMBOL, GoogleSQLParserLEAVE_SYMBOL, GoogleSQLParserLEVEL_SYMBOL, GoogleSQLParserLOAD_SYMBOL, GoogleSQLParserLOOP_SYMBOL, GoogleSQLParserMACRO_SYMBOL, GoogleSQLParserMAP_SYMBOL, GoogleSQLParserMATCH_SYMBOL, GoogleSQLParserKW_MATCH_RECOGNIZE_NONRESERVED_SYMBOL, GoogleSQLParserMATCHED_SYMBOL, GoogleSQLParserMATERIALIZED_SYMBOL, GoogleSQLParserMAX_SYMBOL, GoogleSQLParserMAXVALUE_SYMBOL, GoogleSQLParserMEASURES_SYMBOL, GoogleSQLParserMESSAGE_SYMBOL, GoogleSQLParserMETADATA_SYMBOL, GoogleSQLParserMIN_SYMBOL, GoogleSQLParserMINVALUE_SYMBOL, GoogleSQLParserMODEL_SYMBOL, GoogleSQLParserMODULE_SYMBOL, GoogleSQLParserONLY_SYMBOL, GoogleSQLParserOUT_SYMBOL, GoogleSQLParserOUTPUT_SYMBOL, GoogleSQLParserOVERWRITE_SYMBOL, GoogleSQLParserPARTITIONS_SYMBOL, GoogleSQLParserPATTERN_SYMBOL, GoogleSQLParserPOLICIES_SYMBOL, GoogleSQLParserPOLICY_SYMBOL, GoogleSQLParserPRIMARY_SYMBOL, GoogleSQLParserPRIVATE_SYMBOL, GoogleSQLParserPRIVILEGE_SYMBOL, GoogleSQLParserPRIVILEGES_SYMBOL, GoogleSQLParserPROCEDURE_SYMBOL, GoogleSQLParserPROJECT_SYMBOL, GoogleSQLParserPUBLIC_SYMBOL, GoogleSQLParserRAISE_SYMBOL, GoogleSQLParserREAD_SYMBOL, GoogleSQLParserREFERENCES_SYMBOL, GoogleSQLParserREMOTE_SYMBOL, GoogleSQLParserREMOVE_SYMBOL, GoogleSQLParserRENAME_SYMBOL, GoogleSQLParserREPEAT_SYMBOL, GoogleSQLParserREPEATABLE_SYMBOL, GoogleSQLParserREPLACE_FIELDS_SYMBOL, GoogleSQLParserREPLICA_SYMBOL, GoogleSQLParserREPORT_SYMBOL, GoogleSQLParserRESTRICT_SYMBOL, GoogleSQLParserRESTRICTION_SYMBOL, GoogleSQLParserRETURNS_SYMBOL, GoogleSQLParserRETURN_SYMBOL, GoogleSQLParserREVOKE_SYMBOL, GoogleSQLParserROLLBACK_SYMBOL, GoogleSQLParserROW_SYMBOL, GoogleSQLParserRUN_SYMBOL, GoogleSQLParserSAFE_CAST_SYMBOL, GoogleSQLParserSCHEMA_SYMBOL, GoogleSQLParserSEARCH_SYMBOL, GoogleSQLParserSECURITY_SYMBOL, GoogleSQLParserSEQUENCE_SYMBOL, GoogleSQLParserSETS_SYMBOL, GoogleSQLParserSHOW_SYMBOL, GoogleSQLParserSNAPSHOT_SYMBOL, GoogleSQLParserSOURCE_SYMBOL, GoogleSQLParserSQL_SYMBOL, GoogleSQLParserSTABLE_SYMBOL, GoogleSQLParserSTART_SYMBOL, GoogleSQLParserSTATIC_DESCRIBE_SYMBOL, GoogleSQLParserSTORED_SYMBOL, GoogleSQLParserSTORING_SYMBOL, GoogleSQLParserSTRICT_SYMBOL, GoogleSQLParserTABLE_SYMBOL, GoogleSQLParserTABLES_SYMBOL, GoogleSQLParserTARGET_SYMBOL, GoogleSQLParserTEMP_SYMBOL, GoogleSQLParserTEMPORARY_SYMBOL, GoogleSQLParserTRANSACTION_SYMBOL, GoogleSQLParserTRANSFORM_SYMBOL, GoogleSQLParserTRUNCATE_SYMBOL, GoogleSQLParserTYPE_SYMBOL, GoogleSQLParserUNDROP_SYMBOL, GoogleSQLParserUNIQUE_SYMBOL, GoogleSQLParserUNKNOWN_SYMBOL, GoogleSQLParserUNTIL_SYMBOL, GoogleSQLParserUPDATE_SYMBOL, GoogleSQLParserVALUES_SYMBOL, GoogleSQLParserVECTOR_SYMBOL, GoogleSQLParserVIEW_SYMBOL, GoogleSQLParserVIEWS_SYMBOL, GoogleSQLParserVOLATILE_SYMBOL, GoogleSQLParserWEIGHT_SYMBOL, GoogleSQLParserWHILE_SYMBOL, GoogleSQLParserWRITE_SYMBOL, GoogleSQLParserZONE_SYMBOL, GoogleSQLParserDESCRIPTOR_SYMBOL, GoogleSQLParserINTERLEAVE_SYMBOL, GoogleSQLParserNULL_FILTERED_SYMBOL, GoogleSQLParserPARENT_SYMBOL, GoogleSQLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1525)
			p.path_expression(0)
		}


	case GoogleSQLParserDEFAULT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1526)
			p.Match(GoogleSQLParserDEFAULT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDescriptor_argumentContext is an interface to support dynamic dispatch.
type IDescriptor_argumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DESCRIPTOR_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Descriptor_column_list() IDescriptor_column_listContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsDescriptor_argumentContext differentiates from other interfaces.
	IsDescriptor_argumentContext()
}

type Descriptor_argumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescriptor_argumentContext() *Descriptor_argumentContext {
	var p = new(Descriptor_argumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_descriptor_argument
	return p
}

func InitEmptyDescriptor_argumentContext(p *Descriptor_argumentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_descriptor_argument
}

func (*Descriptor_argumentContext) IsDescriptor_argumentContext() {}

func NewDescriptor_argumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Descriptor_argumentContext {
	var p = new(Descriptor_argumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_descriptor_argument

	return p
}

func (s *Descriptor_argumentContext) GetParser() antlr.Parser { return s.parser }

func (s *Descriptor_argumentContext) DESCRIPTOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDESCRIPTOR_SYMBOL, 0)
}

func (s *Descriptor_argumentContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Descriptor_argumentContext) Descriptor_column_list() IDescriptor_column_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptor_column_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptor_column_listContext)
}

func (s *Descriptor_argumentContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Descriptor_argumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Descriptor_argumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Descriptor_argumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterDescriptor_argument(s)
	}
}

func (s *Descriptor_argumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitDescriptor_argument(s)
	}
}

func (s *Descriptor_argumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitDescriptor_argument(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Descriptor_argument() (localctx IDescriptor_argumentContext) {
	localctx = NewDescriptor_argumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, GoogleSQLParserRULE_descriptor_argument)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1529)
		p.Match(GoogleSQLParserDESCRIPTOR_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1530)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1531)
		p.Descriptor_column_list()
	}
	{
		p.SetState(1532)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDescriptor_column_listContext is an interface to support dynamic dispatch.
type IDescriptor_column_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDescriptor_column() []IDescriptor_columnContext
	Descriptor_column(i int) IDescriptor_columnContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsDescriptor_column_listContext differentiates from other interfaces.
	IsDescriptor_column_listContext()
}

type Descriptor_column_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescriptor_column_listContext() *Descriptor_column_listContext {
	var p = new(Descriptor_column_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_descriptor_column_list
	return p
}

func InitEmptyDescriptor_column_listContext(p *Descriptor_column_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_descriptor_column_list
}

func (*Descriptor_column_listContext) IsDescriptor_column_listContext() {}

func NewDescriptor_column_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Descriptor_column_listContext {
	var p = new(Descriptor_column_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_descriptor_column_list

	return p
}

func (s *Descriptor_column_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Descriptor_column_listContext) AllDescriptor_column() []IDescriptor_columnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDescriptor_columnContext); ok {
			len++
		}
	}

	tst := make([]IDescriptor_columnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDescriptor_columnContext); ok {
			tst[i] = t.(IDescriptor_columnContext)
			i++
		}
	}

	return tst
}

func (s *Descriptor_column_listContext) Descriptor_column(i int) IDescriptor_columnContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptor_columnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptor_columnContext)
}

func (s *Descriptor_column_listContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Descriptor_column_listContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Descriptor_column_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Descriptor_column_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Descriptor_column_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterDescriptor_column_list(s)
	}
}

func (s *Descriptor_column_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitDescriptor_column_list(s)
	}
}

func (s *Descriptor_column_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitDescriptor_column_list(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Descriptor_column_list() (localctx IDescriptor_column_listContext) {
	localctx = NewDescriptor_column_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, GoogleSQLParserRULE_descriptor_column_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1534)
		p.Descriptor_column()
	}
	p.SetState(1539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(1535)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1536)
			p.Descriptor_column()
		}


		p.SetState(1541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDescriptor_columnContext is an interface to support dynamic dispatch.
type IDescriptor_columnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsDescriptor_columnContext differentiates from other interfaces.
	IsDescriptor_columnContext()
}

type Descriptor_columnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescriptor_columnContext() *Descriptor_columnContext {
	var p = new(Descriptor_columnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_descriptor_column
	return p
}

func InitEmptyDescriptor_columnContext(p *Descriptor_columnContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_descriptor_column
}

func (*Descriptor_columnContext) IsDescriptor_columnContext() {}

func NewDescriptor_columnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Descriptor_columnContext {
	var p = new(Descriptor_columnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_descriptor_column

	return p
}

func (s *Descriptor_columnContext) GetParser() antlr.Parser { return s.parser }

func (s *Descriptor_columnContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Descriptor_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Descriptor_columnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Descriptor_columnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterDescriptor_column(s)
	}
}

func (s *Descriptor_columnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitDescriptor_column(s)
	}
}

func (s *Descriptor_columnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitDescriptor_column(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Descriptor_column() (localctx IDescriptor_columnContext) {
	localctx = NewDescriptor_columnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, GoogleSQLParserRULE_descriptor_column)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1542)
		p.Identifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_clauseContext is an interface to support dynamic dispatch.
type ITable_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLE_SYMBOL() antlr.TerminalNode
	Tvf_with_suffixes() ITvf_with_suffixesContext
	Path_expression() IPath_expressionContext

	// IsTable_clauseContext differentiates from other interfaces.
	IsTable_clauseContext()
}

type Table_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_clauseContext() *Table_clauseContext {
	var p = new(Table_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_table_clause
	return p
}

func InitEmptyTable_clauseContext(p *Table_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_table_clause
}

func (*Table_clauseContext) IsTable_clauseContext() {}

func NewTable_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_clauseContext {
	var p = new(Table_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_table_clause

	return p
}

func (s *Table_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_clauseContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTABLE_SYMBOL, 0)
}

func (s *Table_clauseContext) Tvf_with_suffixes() ITvf_with_suffixesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITvf_with_suffixesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITvf_with_suffixesContext)
}

func (s *Table_clauseContext) Path_expression() IPath_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPath_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPath_expressionContext)
}

func (s *Table_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterTable_clause(s)
	}
}

func (s *Table_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitTable_clause(s)
	}
}

func (s *Table_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitTable_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Table_clause() (localctx ITable_clauseContext) {
	localctx = NewTable_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, GoogleSQLParserRULE_table_clause)
	p.SetState(1548)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 140, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1544)
			p.Match(GoogleSQLParserTABLE_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1545)
			p.Tvf_with_suffixes()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1546)
			p.Match(GoogleSQLParserTABLE_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1547)
			p.path_expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IModel_clauseContext is an interface to support dynamic dispatch.
type IModel_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODEL_SYMBOL() antlr.TerminalNode
	Path_expression() IPath_expressionContext

	// IsModel_clauseContext differentiates from other interfaces.
	IsModel_clauseContext()
}

type Model_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModel_clauseContext() *Model_clauseContext {
	var p = new(Model_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_model_clause
	return p
}

func InitEmptyModel_clauseContext(p *Model_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_model_clause
}

func (*Model_clauseContext) IsModel_clauseContext() {}

func NewModel_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Model_clauseContext {
	var p = new(Model_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_model_clause

	return p
}

func (s *Model_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Model_clauseContext) MODEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMODEL_SYMBOL, 0)
}

func (s *Model_clauseContext) Path_expression() IPath_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPath_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPath_expressionContext)
}

func (s *Model_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Model_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Model_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterModel_clause(s)
	}
}

func (s *Model_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitModel_clause(s)
	}
}

func (s *Model_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitModel_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Model_clause() (localctx IModel_clauseContext) {
	localctx = NewModel_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, GoogleSQLParserRULE_model_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1550)
		p.Match(GoogleSQLParserMODEL_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1551)
		p.path_expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQualify_clause_nonreservedContext is an interface to support dynamic dispatch.
type IQualify_clause_nonreservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUALIFY_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsQualify_clause_nonreservedContext differentiates from other interfaces.
	IsQualify_clause_nonreservedContext()
}

type Qualify_clause_nonreservedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualify_clause_nonreservedContext() *Qualify_clause_nonreservedContext {
	var p = new(Qualify_clause_nonreservedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_qualify_clause_nonreserved
	return p
}

func InitEmptyQualify_clause_nonreservedContext(p *Qualify_clause_nonreservedContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_qualify_clause_nonreserved
}

func (*Qualify_clause_nonreservedContext) IsQualify_clause_nonreservedContext() {}

func NewQualify_clause_nonreservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Qualify_clause_nonreservedContext {
	var p = new(Qualify_clause_nonreservedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_qualify_clause_nonreserved

	return p
}

func (s *Qualify_clause_nonreservedContext) GetParser() antlr.Parser { return s.parser }

func (s *Qualify_clause_nonreservedContext) QUALIFY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserQUALIFY_SYMBOL, 0)
}

func (s *Qualify_clause_nonreservedContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Qualify_clause_nonreservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Qualify_clause_nonreservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Qualify_clause_nonreservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterQualify_clause_nonreserved(s)
	}
}

func (s *Qualify_clause_nonreservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitQualify_clause_nonreserved(s)
	}
}

func (s *Qualify_clause_nonreservedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitQualify_clause_nonreserved(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Qualify_clause_nonreserved() (localctx IQualify_clause_nonreservedContext) {
	localctx = NewQualify_clause_nonreservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, GoogleSQLParserRULE_qualify_clause_nonreserved)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1553)
		p.Match(GoogleSQLParserQUALIFY_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1554)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnpivot_clauseContext is an interface to support dynamic dispatch.
type IUnpivot_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNPIVOT_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Path_expression_list_with_opt_parens() IPath_expression_list_with_opt_parensContext
	FOR_SYMBOL() antlr.TerminalNode
	Path_expression() IPath_expressionContext
	IN_SYMBOL() antlr.TerminalNode
	Unpivot_in_item_list() IUnpivot_in_item_listContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	Unpivot_nulls_filter() IUnpivot_nulls_filterContext

	// IsUnpivot_clauseContext differentiates from other interfaces.
	IsUnpivot_clauseContext()
}

type Unpivot_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivot_clauseContext() *Unpivot_clauseContext {
	var p = new(Unpivot_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_unpivot_clause
	return p
}

func InitEmptyUnpivot_clauseContext(p *Unpivot_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_unpivot_clause
}

func (*Unpivot_clauseContext) IsUnpivot_clauseContext() {}

func NewUnpivot_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unpivot_clauseContext {
	var p = new(Unpivot_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_unpivot_clause

	return p
}

func (s *Unpivot_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Unpivot_clauseContext) UNPIVOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserUNPIVOT_SYMBOL, 0)
}

func (s *Unpivot_clauseContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Unpivot_clauseContext) Path_expression_list_with_opt_parens() IPath_expression_list_with_opt_parensContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPath_expression_list_with_opt_parensContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPath_expression_list_with_opt_parensContext)
}

func (s *Unpivot_clauseContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFOR_SYMBOL, 0)
}

func (s *Unpivot_clauseContext) Path_expression() IPath_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPath_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPath_expressionContext)
}

func (s *Unpivot_clauseContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserIN_SYMBOL, 0)
}

func (s *Unpivot_clauseContext) Unpivot_in_item_list() IUnpivot_in_item_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivot_in_item_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivot_in_item_listContext)
}

func (s *Unpivot_clauseContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Unpivot_clauseContext) Unpivot_nulls_filter() IUnpivot_nulls_filterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivot_nulls_filterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivot_nulls_filterContext)
}

func (s *Unpivot_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unpivot_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Unpivot_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterUnpivot_clause(s)
	}
}

func (s *Unpivot_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitUnpivot_clause(s)
	}
}

func (s *Unpivot_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitUnpivot_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Unpivot_clause() (localctx IUnpivot_clauseContext) {
	localctx = NewUnpivot_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, GoogleSQLParserRULE_unpivot_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1556)
		p.Match(GoogleSQLParserUNPIVOT_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1558)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserEXCLUDE_SYMBOL || _la == GoogleSQLParserINCLUDE_SYMBOL {
		{
			p.SetState(1557)
			p.Unpivot_nulls_filter()
		}

	}
	{
		p.SetState(1560)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1561)
		p.Path_expression_list_with_opt_parens()
	}
	{
		p.SetState(1562)
		p.Match(GoogleSQLParserFOR_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1563)
		p.path_expression(0)
	}
	{
		p.SetState(1564)
		p.Match(GoogleSQLParserIN_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1565)
		p.Unpivot_in_item_list()
	}
	{
		p.SetState(1566)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnpivot_in_item_listContext is an interface to support dynamic dispatch.
type IUnpivot_in_item_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Unpivot_in_item_list_prefix() IUnpivot_in_item_list_prefixContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsUnpivot_in_item_listContext differentiates from other interfaces.
	IsUnpivot_in_item_listContext()
}

type Unpivot_in_item_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivot_in_item_listContext() *Unpivot_in_item_listContext {
	var p = new(Unpivot_in_item_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_unpivot_in_item_list
	return p
}

func InitEmptyUnpivot_in_item_listContext(p *Unpivot_in_item_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_unpivot_in_item_list
}

func (*Unpivot_in_item_listContext) IsUnpivot_in_item_listContext() {}

func NewUnpivot_in_item_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unpivot_in_item_listContext {
	var p = new(Unpivot_in_item_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_unpivot_in_item_list

	return p
}

func (s *Unpivot_in_item_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Unpivot_in_item_listContext) Unpivot_in_item_list_prefix() IUnpivot_in_item_list_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivot_in_item_list_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivot_in_item_list_prefixContext)
}

func (s *Unpivot_in_item_listContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Unpivot_in_item_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unpivot_in_item_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Unpivot_in_item_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterUnpivot_in_item_list(s)
	}
}

func (s *Unpivot_in_item_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitUnpivot_in_item_list(s)
	}
}

func (s *Unpivot_in_item_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitUnpivot_in_item_list(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Unpivot_in_item_list() (localctx IUnpivot_in_item_listContext) {
	localctx = NewUnpivot_in_item_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, GoogleSQLParserRULE_unpivot_in_item_list)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1568)
		p.unpivot_in_item_list_prefix(0)
	}
	{
		p.SetState(1569)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnpivot_in_item_list_prefixContext is an interface to support dynamic dispatch.
type IUnpivot_in_item_list_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Unpivot_in_item() IUnpivot_in_itemContext
	Unpivot_in_item_list_prefix() IUnpivot_in_item_list_prefixContext
	COMMA_SYMBOL() antlr.TerminalNode

	// IsUnpivot_in_item_list_prefixContext differentiates from other interfaces.
	IsUnpivot_in_item_list_prefixContext()
}

type Unpivot_in_item_list_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivot_in_item_list_prefixContext() *Unpivot_in_item_list_prefixContext {
	var p = new(Unpivot_in_item_list_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_unpivot_in_item_list_prefix
	return p
}

func InitEmptyUnpivot_in_item_list_prefixContext(p *Unpivot_in_item_list_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_unpivot_in_item_list_prefix
}

func (*Unpivot_in_item_list_prefixContext) IsUnpivot_in_item_list_prefixContext() {}

func NewUnpivot_in_item_list_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unpivot_in_item_list_prefixContext {
	var p = new(Unpivot_in_item_list_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_unpivot_in_item_list_prefix

	return p
}

func (s *Unpivot_in_item_list_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Unpivot_in_item_list_prefixContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Unpivot_in_item_list_prefixContext) Unpivot_in_item() IUnpivot_in_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivot_in_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivot_in_itemContext)
}

func (s *Unpivot_in_item_list_prefixContext) Unpivot_in_item_list_prefix() IUnpivot_in_item_list_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivot_in_item_list_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivot_in_item_list_prefixContext)
}

func (s *Unpivot_in_item_list_prefixContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, 0)
}

func (s *Unpivot_in_item_list_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unpivot_in_item_list_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Unpivot_in_item_list_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterUnpivot_in_item_list_prefix(s)
	}
}

func (s *Unpivot_in_item_list_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitUnpivot_in_item_list_prefix(s)
	}
}

func (s *Unpivot_in_item_list_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitUnpivot_in_item_list_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}





func (p *GoogleSQLParser) Unpivot_in_item_list_prefix() (localctx IUnpivot_in_item_list_prefixContext) {
	return p.unpivot_in_item_list_prefix(0)
}

func (p *GoogleSQLParser) unpivot_in_item_list_prefix(_p int) (localctx IUnpivot_in_item_list_prefixContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewUnpivot_in_item_list_prefixContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IUnpivot_in_item_list_prefixContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 206
	p.EnterRecursionRule(localctx, 206, GoogleSQLParserRULE_unpivot_in_item_list_prefix, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1572)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1573)
		p.Unpivot_in_item()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewUnpivot_in_item_list_prefixContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_unpivot_in_item_list_prefix)
			p.SetState(1575)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(1576)
				p.Match(GoogleSQLParserCOMMA_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1577)
				p.Unpivot_in_item()
			}


		}
		p.SetState(1582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnpivot_in_itemContext is an interface to support dynamic dispatch.
type IUnpivot_in_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Path_expression_list_with_opt_parens() IPath_expression_list_with_opt_parensContext
	Opt_as_string_or_integer() IOpt_as_string_or_integerContext

	// IsUnpivot_in_itemContext differentiates from other interfaces.
	IsUnpivot_in_itemContext()
}

type Unpivot_in_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivot_in_itemContext() *Unpivot_in_itemContext {
	var p = new(Unpivot_in_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_unpivot_in_item
	return p
}

func InitEmptyUnpivot_in_itemContext(p *Unpivot_in_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_unpivot_in_item
}

func (*Unpivot_in_itemContext) IsUnpivot_in_itemContext() {}

func NewUnpivot_in_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unpivot_in_itemContext {
	var p = new(Unpivot_in_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_unpivot_in_item

	return p
}

func (s *Unpivot_in_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Unpivot_in_itemContext) Path_expression_list_with_opt_parens() IPath_expression_list_with_opt_parensContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPath_expression_list_with_opt_parensContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPath_expression_list_with_opt_parensContext)
}

func (s *Unpivot_in_itemContext) Opt_as_string_or_integer() IOpt_as_string_or_integerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_as_string_or_integerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_as_string_or_integerContext)
}

func (s *Unpivot_in_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unpivot_in_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Unpivot_in_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterUnpivot_in_item(s)
	}
}

func (s *Unpivot_in_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitUnpivot_in_item(s)
	}
}

func (s *Unpivot_in_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitUnpivot_in_item(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Unpivot_in_item() (localctx IUnpivot_in_itemContext) {
	localctx = NewUnpivot_in_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, GoogleSQLParserRULE_unpivot_in_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1583)
		p.Path_expression_list_with_opt_parens()
	}
	p.SetState(1585)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1584)
			p.Opt_as_string_or_integer()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_as_string_or_integerContext is an interface to support dynamic dispatch.
type IOpt_as_string_or_integerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	String_literal() IString_literalContext
	AS_SYMBOL() antlr.TerminalNode
	Integer_literal() IInteger_literalContext

	// IsOpt_as_string_or_integerContext differentiates from other interfaces.
	IsOpt_as_string_or_integerContext()
}

type Opt_as_string_or_integerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_as_string_or_integerContext() *Opt_as_string_or_integerContext {
	var p = new(Opt_as_string_or_integerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_as_string_or_integer
	return p
}

func InitEmptyOpt_as_string_or_integerContext(p *Opt_as_string_or_integerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_as_string_or_integer
}

func (*Opt_as_string_or_integerContext) IsOpt_as_string_or_integerContext() {}

func NewOpt_as_string_or_integerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_as_string_or_integerContext {
	var p = new(Opt_as_string_or_integerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_as_string_or_integer

	return p
}

func (s *Opt_as_string_or_integerContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_as_string_or_integerContext) String_literal() IString_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_literalContext)
}

func (s *Opt_as_string_or_integerContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAS_SYMBOL, 0)
}

func (s *Opt_as_string_or_integerContext) Integer_literal() IInteger_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInteger_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInteger_literalContext)
}

func (s *Opt_as_string_or_integerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_as_string_or_integerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_as_string_or_integerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_as_string_or_integer(s)
	}
}

func (s *Opt_as_string_or_integerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_as_string_or_integer(s)
	}
}

func (s *Opt_as_string_or_integerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_as_string_or_integer(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_as_string_or_integer() (localctx IOpt_as_string_or_integerContext) {
	localctx = NewOpt_as_string_or_integerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, GoogleSQLParserRULE_opt_as_string_or_integer)
	var _la int

	p.SetState(1595)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1588)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserAS_SYMBOL {
			{
				p.SetState(1587)
				p.Match(GoogleSQLParserAS_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1590)
			p.string_literal(0)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1592)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserAS_SYMBOL {
			{
				p.SetState(1591)
				p.Match(GoogleSQLParserAS_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1594)
			p.Integer_literal()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPath_expression_list_with_opt_parensContext is an interface to support dynamic dispatch.
type IPath_expression_list_with_opt_parensContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Path_expression_list() IPath_expression_listContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsPath_expression_list_with_opt_parensContext differentiates from other interfaces.
	IsPath_expression_list_with_opt_parensContext()
}

type Path_expression_list_with_opt_parensContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPath_expression_list_with_opt_parensContext() *Path_expression_list_with_opt_parensContext {
	var p = new(Path_expression_list_with_opt_parensContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_path_expression_list_with_opt_parens
	return p
}

func InitEmptyPath_expression_list_with_opt_parensContext(p *Path_expression_list_with_opt_parensContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_path_expression_list_with_opt_parens
}

func (*Path_expression_list_with_opt_parensContext) IsPath_expression_list_with_opt_parensContext() {}

func NewPath_expression_list_with_opt_parensContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Path_expression_list_with_opt_parensContext {
	var p = new(Path_expression_list_with_opt_parensContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_path_expression_list_with_opt_parens

	return p
}

func (s *Path_expression_list_with_opt_parensContext) GetParser() antlr.Parser { return s.parser }

func (s *Path_expression_list_with_opt_parensContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Path_expression_list_with_opt_parensContext) Path_expression_list() IPath_expression_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPath_expression_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPath_expression_listContext)
}

func (s *Path_expression_list_with_opt_parensContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Path_expression_list_with_opt_parensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Path_expression_list_with_opt_parensContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Path_expression_list_with_opt_parensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterPath_expression_list_with_opt_parens(s)
	}
}

func (s *Path_expression_list_with_opt_parensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitPath_expression_list_with_opt_parens(s)
	}
}

func (s *Path_expression_list_with_opt_parensContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitPath_expression_list_with_opt_parens(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Path_expression_list_with_opt_parens() (localctx IPath_expression_list_with_opt_parensContext) {
	localctx = NewPath_expression_list_with_opt_parensContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, GoogleSQLParserRULE_path_expression_list_with_opt_parens)
	p.SetState(1602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserLR_BRACKET_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1597)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1598)
			p.Path_expression_list()
		}
		{
			p.SetState(1599)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case GoogleSQLParserINCLUDE_SYMBOL, GoogleSQLParserOFFSET_SYMBOL, GoogleSQLParserOPTIONS_SYMBOL, GoogleSQLParserPERCENT_SYMBOL, GoogleSQLParserPIVOT_SYMBOL, GoogleSQLParserREPLACE_SYMBOL, GoogleSQLParserUNPIVOT_SYMBOL, GoogleSQLParserSYSTEM_SYMBOL, GoogleSQLParserSYSTEM_TIME_SYMBOL, GoogleSQLParserVALUE_SYMBOL, GoogleSQLParserNUMERIC_SYMBOL, GoogleSQLParserDECIMAL_SYMBOL, GoogleSQLParserBIGNUMERIC_SYMBOL, GoogleSQLParserBIGDECIMAL_SYMBOL, GoogleSQLParserJSON_SYMBOL, GoogleSQLParserDATE_SYMBOL, GoogleSQLParserTIME_SYMBOL, GoogleSQLParserDATETIME_SYMBOL, GoogleSQLParserTIMESTAMP_SYMBOL, GoogleSQLParserSIMPLE_SYMBOL, GoogleSQLParserABORT_SYMBOL, GoogleSQLParserACCESS_SYMBOL, GoogleSQLParserACTION_SYMBOL, GoogleSQLParserAGGREGATE_SYMBOL, GoogleSQLParserADD_SYMBOL, GoogleSQLParserALTER_SYMBOL, GoogleSQLParserALWAYS_SYMBOL, GoogleSQLParserANALYZE_SYMBOL, GoogleSQLParserAPPROX_SYMBOL, GoogleSQLParserARE_SYMBOL, GoogleSQLParserASSERT_SYMBOL, GoogleSQLParserBATCH_SYMBOL, GoogleSQLParserBEGIN_SYMBOL, GoogleSQLParserBREAK_SYMBOL, GoogleSQLParserCALL_SYMBOL, GoogleSQLParserCASCADE_SYMBOL, GoogleSQLParserCHECK_SYMBOL, GoogleSQLParserCLAMPED_SYMBOL, GoogleSQLParserCLONE_SYMBOL, GoogleSQLParserCOPY_SYMBOL, GoogleSQLParserCLUSTER_SYMBOL, GoogleSQLParserCOLUMN_SYMBOL, GoogleSQLParserCOLUMNS_SYMBOL, GoogleSQLParserCOMMIT_SYMBOL, GoogleSQLParserCONNECTION_SYMBOL, GoogleSQLParserCONSTANT_SYMBOL, GoogleSQLParserCONSTRAINT_SYMBOL, GoogleSQLParserCONTINUE_SYMBOL, GoogleSQLParserCORRESPONDING_SYMBOL, GoogleSQLParserCYCLE_SYMBOL, GoogleSQLParserDATA_SYMBOL, GoogleSQLParserDATABASE_SYMBOL, GoogleSQLParserDECLARE_SYMBOL, GoogleSQLParserDEFINER_SYMBOL, GoogleSQLParserDELETE_SYMBOL, GoogleSQLParserDELETION_SYMBOL, GoogleSQLParserDEPTH_SYMBOL, GoogleSQLParserDESCRIBE_SYMBOL, GoogleSQLParserDETERMINISTIC_SYMBOL, GoogleSQLParserDO_SYMBOL, GoogleSQLParserDROP_SYMBOL, GoogleSQLParserELSEIF_SYMBOL, GoogleSQLParserENFORCED_SYMBOL, GoogleSQLParserERROR_SYMBOL, GoogleSQLParserEXCEPTION_SYMBOL, GoogleSQLParserEXECUTE_SYMBOL, GoogleSQLParserEXPLAIN_SYMBOL, GoogleSQLParserEXPORT_SYMBOL, GoogleSQLParserEXTEND_SYMBOL, GoogleSQLParserEXTERNAL_SYMBOL, GoogleSQLParserFILES_SYMBOL, GoogleSQLParserFILTER_SYMBOL, GoogleSQLParserFILL_SYMBOL, GoogleSQLParserFIRST_SYMBOL, GoogleSQLParserFOREIGN_SYMBOL, GoogleSQLParserFORMAT_SYMBOL, GoogleSQLParserFUNCTION_SYMBOL, GoogleSQLParserGENERATED_SYMBOL, GoogleSQLParserGRANT_SYMBOL, GoogleSQLParserGROUP_ROWS_SYMBOL, GoogleSQLParserHIDDEN_SYMBOL, GoogleSQLParserIDENTITY_SYMBOL, GoogleSQLParserIMMEDIATE_SYMBOL, GoogleSQLParserIMMUTABLE_SYMBOL, GoogleSQLParserIMPORT_SYMBOL, GoogleSQLParserINCREMENT_SYMBOL, GoogleSQLParserINDEX_SYMBOL, GoogleSQLParserINOUT_SYMBOL, GoogleSQLParserINPUT_SYMBOL, GoogleSQLParserINSERT_SYMBOL, GoogleSQLParserINVOKER_SYMBOL, GoogleSQLParserISOLATION_SYMBOL, GoogleSQLParserITERATE_SYMBOL, GoogleSQLParserKEY_SYMBOL, GoogleSQLParserLANGUAGE_SYMBOL, GoogleSQLParserLAST_SYMBOL, GoogleSQLParserLEAVE_SYMBOL, GoogleSQLParserLEVEL_SYMBOL, GoogleSQLParserLOAD_SYMBOL, GoogleSQLParserLOOP_SYMBOL, GoogleSQLParserMACRO_SYMBOL, GoogleSQLParserMAP_SYMBOL, GoogleSQLParserMATCH_SYMBOL, GoogleSQLParserKW_MATCH_RECOGNIZE_NONRESERVED_SYMBOL, GoogleSQLParserMATCHED_SYMBOL, GoogleSQLParserMATERIALIZED_SYMBOL, GoogleSQLParserMAX_SYMBOL, GoogleSQLParserMAXVALUE_SYMBOL, GoogleSQLParserMEASURES_SYMBOL, GoogleSQLParserMESSAGE_SYMBOL, GoogleSQLParserMETADATA_SYMBOL, GoogleSQLParserMIN_SYMBOL, GoogleSQLParserMINVALUE_SYMBOL, GoogleSQLParserMODEL_SYMBOL, GoogleSQLParserMODULE_SYMBOL, GoogleSQLParserONLY_SYMBOL, GoogleSQLParserOUT_SYMBOL, GoogleSQLParserOUTPUT_SYMBOL, GoogleSQLParserOVERWRITE_SYMBOL, GoogleSQLParserPARTITIONS_SYMBOL, GoogleSQLParserPATTERN_SYMBOL, GoogleSQLParserPOLICIES_SYMBOL, GoogleSQLParserPOLICY_SYMBOL, GoogleSQLParserPRIMARY_SYMBOL, GoogleSQLParserPRIVATE_SYMBOL, GoogleSQLParserPRIVILEGE_SYMBOL, GoogleSQLParserPRIVILEGES_SYMBOL, GoogleSQLParserPROCEDURE_SYMBOL, GoogleSQLParserPROJECT_SYMBOL, GoogleSQLParserPUBLIC_SYMBOL, GoogleSQLParserRAISE_SYMBOL, GoogleSQLParserREAD_SYMBOL, GoogleSQLParserREFERENCES_SYMBOL, GoogleSQLParserREMOTE_SYMBOL, GoogleSQLParserREMOVE_SYMBOL, GoogleSQLParserRENAME_SYMBOL, GoogleSQLParserREPEAT_SYMBOL, GoogleSQLParserREPEATABLE_SYMBOL, GoogleSQLParserREPLACE_FIELDS_SYMBOL, GoogleSQLParserREPLICA_SYMBOL, GoogleSQLParserREPORT_SYMBOL, GoogleSQLParserRESTRICT_SYMBOL, GoogleSQLParserRESTRICTION_SYMBOL, GoogleSQLParserRETURNS_SYMBOL, GoogleSQLParserRETURN_SYMBOL, GoogleSQLParserREVOKE_SYMBOL, GoogleSQLParserROLLBACK_SYMBOL, GoogleSQLParserROW_SYMBOL, GoogleSQLParserRUN_SYMBOL, GoogleSQLParserSAFE_CAST_SYMBOL, GoogleSQLParserSCHEMA_SYMBOL, GoogleSQLParserSEARCH_SYMBOL, GoogleSQLParserSECURITY_SYMBOL, GoogleSQLParserSEQUENCE_SYMBOL, GoogleSQLParserSETS_SYMBOL, GoogleSQLParserSHOW_SYMBOL, GoogleSQLParserSNAPSHOT_SYMBOL, GoogleSQLParserSOURCE_SYMBOL, GoogleSQLParserSQL_SYMBOL, GoogleSQLParserSTABLE_SYMBOL, GoogleSQLParserSTART_SYMBOL, GoogleSQLParserSTATIC_DESCRIBE_SYMBOL, GoogleSQLParserSTORED_SYMBOL, GoogleSQLParserSTORING_SYMBOL, GoogleSQLParserSTRICT_SYMBOL, GoogleSQLParserTABLE_SYMBOL, GoogleSQLParserTABLES_SYMBOL, GoogleSQLParserTARGET_SYMBOL, GoogleSQLParserTEMP_SYMBOL, GoogleSQLParserTEMPORARY_SYMBOL, GoogleSQLParserTRANSACTION_SYMBOL, GoogleSQLParserTRANSFORM_SYMBOL, GoogleSQLParserTRUNCATE_SYMBOL, GoogleSQLParserTYPE_SYMBOL, GoogleSQLParserUNDROP_SYMBOL, GoogleSQLParserUNIQUE_SYMBOL, GoogleSQLParserUNKNOWN_SYMBOL, GoogleSQLParserUNTIL_SYMBOL, GoogleSQLParserUPDATE_SYMBOL, GoogleSQLParserVALUES_SYMBOL, GoogleSQLParserVECTOR_SYMBOL, GoogleSQLParserVIEW_SYMBOL, GoogleSQLParserVIEWS_SYMBOL, GoogleSQLParserVOLATILE_SYMBOL, GoogleSQLParserWEIGHT_SYMBOL, GoogleSQLParserWHILE_SYMBOL, GoogleSQLParserWRITE_SYMBOL, GoogleSQLParserZONE_SYMBOL, GoogleSQLParserDESCRIPTOR_SYMBOL, GoogleSQLParserINTERLEAVE_SYMBOL, GoogleSQLParserNULL_FILTERED_SYMBOL, GoogleSQLParserPARENT_SYMBOL, GoogleSQLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1601)
			p.Path_expression_list()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPath_expression_listContext is an interface to support dynamic dispatch.
type IPath_expression_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPath_expression() []IPath_expressionContext
	Path_expression(i int) IPath_expressionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsPath_expression_listContext differentiates from other interfaces.
	IsPath_expression_listContext()
}

type Path_expression_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPath_expression_listContext() *Path_expression_listContext {
	var p = new(Path_expression_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_path_expression_list
	return p
}

func InitEmptyPath_expression_listContext(p *Path_expression_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_path_expression_list
}

func (*Path_expression_listContext) IsPath_expression_listContext() {}

func NewPath_expression_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Path_expression_listContext {
	var p = new(Path_expression_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_path_expression_list

	return p
}

func (s *Path_expression_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Path_expression_listContext) AllPath_expression() []IPath_expressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPath_expressionContext); ok {
			len++
		}
	}

	tst := make([]IPath_expressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPath_expressionContext); ok {
			tst[i] = t.(IPath_expressionContext)
			i++
		}
	}

	return tst
}

func (s *Path_expression_listContext) Path_expression(i int) IPath_expressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPath_expressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPath_expressionContext)
}

func (s *Path_expression_listContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Path_expression_listContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Path_expression_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Path_expression_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Path_expression_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterPath_expression_list(s)
	}
}

func (s *Path_expression_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitPath_expression_list(s)
	}
}

func (s *Path_expression_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitPath_expression_list(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Path_expression_list() (localctx IPath_expression_listContext) {
	localctx = NewPath_expression_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, GoogleSQLParserRULE_path_expression_list)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1604)
		p.path_expression(0)
	}
	p.SetState(1609)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1605)
				p.Match(GoogleSQLParserCOMMA_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1606)
				p.path_expression(0)
			}


		}
		p.SetState(1611)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnpivot_nulls_filterContext is an interface to support dynamic dispatch.
type IUnpivot_nulls_filterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCLUDE_SYMBOL() antlr.TerminalNode
	NULLS_SYMBOL() antlr.TerminalNode
	INCLUDE_SYMBOL() antlr.TerminalNode

	// IsUnpivot_nulls_filterContext differentiates from other interfaces.
	IsUnpivot_nulls_filterContext()
}

type Unpivot_nulls_filterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivot_nulls_filterContext() *Unpivot_nulls_filterContext {
	var p = new(Unpivot_nulls_filterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_unpivot_nulls_filter
	return p
}

func InitEmptyUnpivot_nulls_filterContext(p *Unpivot_nulls_filterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_unpivot_nulls_filter
}

func (*Unpivot_nulls_filterContext) IsUnpivot_nulls_filterContext() {}

func NewUnpivot_nulls_filterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unpivot_nulls_filterContext {
	var p = new(Unpivot_nulls_filterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_unpivot_nulls_filter

	return p
}

func (s *Unpivot_nulls_filterContext) GetParser() antlr.Parser { return s.parser }

func (s *Unpivot_nulls_filterContext) EXCLUDE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEXCLUDE_SYMBOL, 0)
}

func (s *Unpivot_nulls_filterContext) NULLS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserNULLS_SYMBOL, 0)
}

func (s *Unpivot_nulls_filterContext) INCLUDE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINCLUDE_SYMBOL, 0)
}

func (s *Unpivot_nulls_filterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unpivot_nulls_filterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Unpivot_nulls_filterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterUnpivot_nulls_filter(s)
	}
}

func (s *Unpivot_nulls_filterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitUnpivot_nulls_filter(s)
	}
}

func (s *Unpivot_nulls_filterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitUnpivot_nulls_filter(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Unpivot_nulls_filter() (localctx IUnpivot_nulls_filterContext) {
	localctx = NewUnpivot_nulls_filterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, GoogleSQLParserRULE_unpivot_nulls_filter)
	p.SetState(1616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserEXCLUDE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1612)
			p.Match(GoogleSQLParserEXCLUDE_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1613)
			p.Match(GoogleSQLParserNULLS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case GoogleSQLParserINCLUDE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1614)
			p.Match(GoogleSQLParserINCLUDE_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1615)
			p.Match(GoogleSQLParserNULLS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPivot_clauseContext is an interface to support dynamic dispatch.
type IPivot_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PIVOT_SYMBOL() antlr.TerminalNode
	AllLR_BRACKET_SYMBOL() []antlr.TerminalNode
	LR_BRACKET_SYMBOL(i int) antlr.TerminalNode
	Pivot_expression_list() IPivot_expression_listContext
	FOR_SYMBOL() antlr.TerminalNode
	Expression_higher_prec_than_and() IExpression_higher_prec_than_andContext
	IN_SYMBOL() antlr.TerminalNode
	Pivot_value_list() IPivot_value_listContext
	AllRR_BRACKET_SYMBOL() []antlr.TerminalNode
	RR_BRACKET_SYMBOL(i int) antlr.TerminalNode

	// IsPivot_clauseContext differentiates from other interfaces.
	IsPivot_clauseContext()
}

type Pivot_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivot_clauseContext() *Pivot_clauseContext {
	var p = new(Pivot_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_pivot_clause
	return p
}

func InitEmptyPivot_clauseContext(p *Pivot_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_pivot_clause
}

func (*Pivot_clauseContext) IsPivot_clauseContext() {}

func NewPivot_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pivot_clauseContext {
	var p = new(Pivot_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_pivot_clause

	return p
}

func (s *Pivot_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Pivot_clauseContext) PIVOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPIVOT_SYMBOL, 0)
}

func (s *Pivot_clauseContext) AllLR_BRACKET_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserLR_BRACKET_SYMBOL)
}

func (s *Pivot_clauseContext) LR_BRACKET_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, i)
}

func (s *Pivot_clauseContext) Pivot_expression_list() IPivot_expression_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivot_expression_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivot_expression_listContext)
}

func (s *Pivot_clauseContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFOR_SYMBOL, 0)
}

func (s *Pivot_clauseContext) Expression_higher_prec_than_and() IExpression_higher_prec_than_andContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpression_higher_prec_than_andContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpression_higher_prec_than_andContext)
}

func (s *Pivot_clauseContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserIN_SYMBOL, 0)
}

func (s *Pivot_clauseContext) Pivot_value_list() IPivot_value_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivot_value_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivot_value_listContext)
}

func (s *Pivot_clauseContext) AllRR_BRACKET_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserRR_BRACKET_SYMBOL)
}

func (s *Pivot_clauseContext) RR_BRACKET_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, i)
}

func (s *Pivot_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pivot_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Pivot_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterPivot_clause(s)
	}
}

func (s *Pivot_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitPivot_clause(s)
	}
}

func (s *Pivot_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitPivot_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Pivot_clause() (localctx IPivot_clauseContext) {
	localctx = NewPivot_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, GoogleSQLParserRULE_pivot_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1618)
		p.Match(GoogleSQLParserPIVOT_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1619)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1620)
		p.Pivot_expression_list()
	}
	{
		p.SetState(1621)
		p.Match(GoogleSQLParserFOR_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1622)
		p.Expression_higher_prec_than_and()
	}
	{
		p.SetState(1623)
		p.Match(GoogleSQLParserIN_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1624)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1625)
		p.Pivot_value_list()
	}
	{
		p.SetState(1626)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1627)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPivot_expression_listContext is an interface to support dynamic dispatch.
type IPivot_expression_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPivot_expression() []IPivot_expressionContext
	Pivot_expression(i int) IPivot_expressionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsPivot_expression_listContext differentiates from other interfaces.
	IsPivot_expression_listContext()
}

type Pivot_expression_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivot_expression_listContext() *Pivot_expression_listContext {
	var p = new(Pivot_expression_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_pivot_expression_list
	return p
}

func InitEmptyPivot_expression_listContext(p *Pivot_expression_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_pivot_expression_list
}

func (*Pivot_expression_listContext) IsPivot_expression_listContext() {}

func NewPivot_expression_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pivot_expression_listContext {
	var p = new(Pivot_expression_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_pivot_expression_list

	return p
}

func (s *Pivot_expression_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Pivot_expression_listContext) AllPivot_expression() []IPivot_expressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPivot_expressionContext); ok {
			len++
		}
	}

	tst := make([]IPivot_expressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPivot_expressionContext); ok {
			tst[i] = t.(IPivot_expressionContext)
			i++
		}
	}

	return tst
}

func (s *Pivot_expression_listContext) Pivot_expression(i int) IPivot_expressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivot_expressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivot_expressionContext)
}

func (s *Pivot_expression_listContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Pivot_expression_listContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Pivot_expression_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pivot_expression_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Pivot_expression_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterPivot_expression_list(s)
	}
}

func (s *Pivot_expression_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitPivot_expression_list(s)
	}
}

func (s *Pivot_expression_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitPivot_expression_list(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Pivot_expression_list() (localctx IPivot_expression_listContext) {
	localctx = NewPivot_expression_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, GoogleSQLParserRULE_pivot_expression_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1629)
		p.Pivot_expression()
	}
	p.SetState(1634)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(1630)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1631)
			p.Pivot_expression()
		}


		p.SetState(1636)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPivot_expressionContext is an interface to support dynamic dispatch.
type IPivot_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	As_alias() IAs_aliasContext

	// IsPivot_expressionContext differentiates from other interfaces.
	IsPivot_expressionContext()
}

type Pivot_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivot_expressionContext() *Pivot_expressionContext {
	var p = new(Pivot_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_pivot_expression
	return p
}

func InitEmptyPivot_expressionContext(p *Pivot_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_pivot_expression
}

func (*Pivot_expressionContext) IsPivot_expressionContext() {}

func NewPivot_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pivot_expressionContext {
	var p = new(Pivot_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_pivot_expression

	return p
}

func (s *Pivot_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Pivot_expressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Pivot_expressionContext) As_alias() IAs_aliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAs_aliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAs_aliasContext)
}

func (s *Pivot_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pivot_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Pivot_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterPivot_expression(s)
	}
}

func (s *Pivot_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitPivot_expression(s)
	}
}

func (s *Pivot_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitPivot_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Pivot_expression() (localctx IPivot_expressionContext) {
	localctx = NewPivot_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, GoogleSQLParserRULE_pivot_expression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1637)
		p.expression(0)
	}
	p.SetState(1639)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserAS_SYMBOL || _la == GoogleSQLParserQUOTED_ID || _la == GoogleSQLParserID {
		{
			p.SetState(1638)
			p.As_alias()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPivot_value_listContext is an interface to support dynamic dispatch.
type IPivot_value_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPivot_value() []IPivot_valueContext
	Pivot_value(i int) IPivot_valueContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsPivot_value_listContext differentiates from other interfaces.
	IsPivot_value_listContext()
}

type Pivot_value_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivot_value_listContext() *Pivot_value_listContext {
	var p = new(Pivot_value_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_pivot_value_list
	return p
}

func InitEmptyPivot_value_listContext(p *Pivot_value_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_pivot_value_list
}

func (*Pivot_value_listContext) IsPivot_value_listContext() {}

func NewPivot_value_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pivot_value_listContext {
	var p = new(Pivot_value_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_pivot_value_list

	return p
}

func (s *Pivot_value_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Pivot_value_listContext) AllPivot_value() []IPivot_valueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPivot_valueContext); ok {
			len++
		}
	}

	tst := make([]IPivot_valueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPivot_valueContext); ok {
			tst[i] = t.(IPivot_valueContext)
			i++
		}
	}

	return tst
}

func (s *Pivot_value_listContext) Pivot_value(i int) IPivot_valueContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivot_valueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivot_valueContext)
}

func (s *Pivot_value_listContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Pivot_value_listContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Pivot_value_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pivot_value_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Pivot_value_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterPivot_value_list(s)
	}
}

func (s *Pivot_value_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitPivot_value_list(s)
	}
}

func (s *Pivot_value_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitPivot_value_list(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Pivot_value_list() (localctx IPivot_value_listContext) {
	localctx = NewPivot_value_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, GoogleSQLParserRULE_pivot_value_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1641)
		p.Pivot_value()
	}
	p.SetState(1646)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(1642)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1643)
			p.Pivot_value()
		}


		p.SetState(1648)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPivot_valueContext is an interface to support dynamic dispatch.
type IPivot_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	As_alias() IAs_aliasContext

	// IsPivot_valueContext differentiates from other interfaces.
	IsPivot_valueContext()
}

type Pivot_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivot_valueContext() *Pivot_valueContext {
	var p = new(Pivot_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_pivot_value
	return p
}

func InitEmptyPivot_valueContext(p *Pivot_valueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_pivot_value
}

func (*Pivot_valueContext) IsPivot_valueContext() {}

func NewPivot_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pivot_valueContext {
	var p = new(Pivot_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_pivot_value

	return p
}

func (s *Pivot_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Pivot_valueContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Pivot_valueContext) As_alias() IAs_aliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAs_aliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAs_aliasContext)
}

func (s *Pivot_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pivot_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Pivot_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterPivot_value(s)
	}
}

func (s *Pivot_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitPivot_value(s)
	}
}

func (s *Pivot_valueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitPivot_value(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Pivot_value() (localctx IPivot_valueContext) {
	localctx = NewPivot_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, GoogleSQLParserRULE_pivot_value)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1649)
		p.expression(0)
	}
	p.SetState(1651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserAS_SYMBOL || _la == GoogleSQLParserQUOTED_ID || _la == GoogleSQLParserID {
		{
			p.SetState(1650)
			p.As_alias()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITvf_prefix_no_argsContext is an interface to support dynamic dispatch.
type ITvf_prefix_no_argsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Path_expression() IPath_expressionContext
	IF_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsTvf_prefix_no_argsContext differentiates from other interfaces.
	IsTvf_prefix_no_argsContext()
}

type Tvf_prefix_no_argsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTvf_prefix_no_argsContext() *Tvf_prefix_no_argsContext {
	var p = new(Tvf_prefix_no_argsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_tvf_prefix_no_args
	return p
}

func InitEmptyTvf_prefix_no_argsContext(p *Tvf_prefix_no_argsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_tvf_prefix_no_args
}

func (*Tvf_prefix_no_argsContext) IsTvf_prefix_no_argsContext() {}

func NewTvf_prefix_no_argsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tvf_prefix_no_argsContext {
	var p = new(Tvf_prefix_no_argsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_tvf_prefix_no_args

	return p
}

func (s *Tvf_prefix_no_argsContext) GetParser() antlr.Parser { return s.parser }

func (s *Tvf_prefix_no_argsContext) Path_expression() IPath_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPath_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPath_expressionContext)
}

func (s *Tvf_prefix_no_argsContext) IF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserIF_SYMBOL, 0)
}

func (s *Tvf_prefix_no_argsContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Tvf_prefix_no_argsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tvf_prefix_no_argsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Tvf_prefix_no_argsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterTvf_prefix_no_args(s)
	}
}

func (s *Tvf_prefix_no_argsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitTvf_prefix_no_args(s)
	}
}

func (s *Tvf_prefix_no_argsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitTvf_prefix_no_args(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Tvf_prefix_no_args() (localctx ITvf_prefix_no_argsContext) {
	localctx = NewTvf_prefix_no_argsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, GoogleSQLParserRULE_tvf_prefix_no_args)
	p.SetState(1656)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserINCLUDE_SYMBOL, GoogleSQLParserOFFSET_SYMBOL, GoogleSQLParserOPTIONS_SYMBOL, GoogleSQLParserPERCENT_SYMBOL, GoogleSQLParserPIVOT_SYMBOL, GoogleSQLParserREPLACE_SYMBOL, GoogleSQLParserUNPIVOT_SYMBOL, GoogleSQLParserSYSTEM_SYMBOL, GoogleSQLParserSYSTEM_TIME_SYMBOL, GoogleSQLParserVALUE_SYMBOL, GoogleSQLParserNUMERIC_SYMBOL, GoogleSQLParserDECIMAL_SYMBOL, GoogleSQLParserBIGNUMERIC_SYMBOL, GoogleSQLParserBIGDECIMAL_SYMBOL, GoogleSQLParserJSON_SYMBOL, GoogleSQLParserDATE_SYMBOL, GoogleSQLParserTIME_SYMBOL, GoogleSQLParserDATETIME_SYMBOL, GoogleSQLParserTIMESTAMP_SYMBOL, GoogleSQLParserSIMPLE_SYMBOL, GoogleSQLParserABORT_SYMBOL, GoogleSQLParserACCESS_SYMBOL, GoogleSQLParserACTION_SYMBOL, GoogleSQLParserAGGREGATE_SYMBOL, GoogleSQLParserADD_SYMBOL, GoogleSQLParserALTER_SYMBOL, GoogleSQLParserALWAYS_SYMBOL, GoogleSQLParserANALYZE_SYMBOL, GoogleSQLParserAPPROX_SYMBOL, GoogleSQLParserARE_SYMBOL, GoogleSQLParserASSERT_SYMBOL, GoogleSQLParserBATCH_SYMBOL, GoogleSQLParserBEGIN_SYMBOL, GoogleSQLParserBREAK_SYMBOL, GoogleSQLParserCALL_SYMBOL, GoogleSQLParserCASCADE_SYMBOL, GoogleSQLParserCHECK_SYMBOL, GoogleSQLParserCLAMPED_SYMBOL, GoogleSQLParserCLONE_SYMBOL, GoogleSQLParserCOPY_SYMBOL, GoogleSQLParserCLUSTER_SYMBOL, GoogleSQLParserCOLUMN_SYMBOL, GoogleSQLParserCOLUMNS_SYMBOL, GoogleSQLParserCOMMIT_SYMBOL, GoogleSQLParserCONNECTION_SYMBOL, GoogleSQLParserCONSTANT_SYMBOL, GoogleSQLParserCONSTRAINT_SYMBOL, GoogleSQLParserCONTINUE_SYMBOL, GoogleSQLParserCORRESPONDING_SYMBOL, GoogleSQLParserCYCLE_SYMBOL, GoogleSQLParserDATA_SYMBOL, GoogleSQLParserDATABASE_SYMBOL, GoogleSQLParserDECLARE_SYMBOL, GoogleSQLParserDEFINER_SYMBOL, GoogleSQLParserDELETE_SYMBOL, GoogleSQLParserDELETION_SYMBOL, GoogleSQLParserDEPTH_SYMBOL, GoogleSQLParserDESCRIBE_SYMBOL, GoogleSQLParserDETERMINISTIC_SYMBOL, GoogleSQLParserDO_SYMBOL, GoogleSQLParserDROP_SYMBOL, GoogleSQLParserELSEIF_SYMBOL, GoogleSQLParserENFORCED_SYMBOL, GoogleSQLParserERROR_SYMBOL, GoogleSQLParserEXCEPTION_SYMBOL, GoogleSQLParserEXECUTE_SYMBOL, GoogleSQLParserEXPLAIN_SYMBOL, GoogleSQLParserEXPORT_SYMBOL, GoogleSQLParserEXTEND_SYMBOL, GoogleSQLParserEXTERNAL_SYMBOL, GoogleSQLParserFILES_SYMBOL, GoogleSQLParserFILTER_SYMBOL, GoogleSQLParserFILL_SYMBOL, GoogleSQLParserFIRST_SYMBOL, GoogleSQLParserFOREIGN_SYMBOL, GoogleSQLParserFORMAT_SYMBOL, GoogleSQLParserFUNCTION_SYMBOL, GoogleSQLParserGENERATED_SYMBOL, GoogleSQLParserGRANT_SYMBOL, GoogleSQLParserGROUP_ROWS_SYMBOL, GoogleSQLParserHIDDEN_SYMBOL, GoogleSQLParserIDENTITY_SYMBOL, GoogleSQLParserIMMEDIATE_SYMBOL, GoogleSQLParserIMMUTABLE_SYMBOL, GoogleSQLParserIMPORT_SYMBOL, GoogleSQLParserINCREMENT_SYMBOL, GoogleSQLParserINDEX_SYMBOL, GoogleSQLParserINOUT_SYMBOL, GoogleSQLParserINPUT_SYMBOL, GoogleSQLParserINSERT_SYMBOL, GoogleSQLParserINVOKER_SYMBOL, GoogleSQLParserISOLATION_SYMBOL, GoogleSQLParserITERATE_SYMBOL, GoogleSQLParserKEY_SYMBOL, GoogleSQLParserLANGUAGE_SYMBOL, GoogleSQLParserLAST_SYMBOL, GoogleSQLParserLEAVE_SYMBOL, GoogleSQLParserLEVEL_SYMBOL, GoogleSQLParserLOAD_SYMBOL, GoogleSQLParserLOOP_SYMBOL, GoogleSQLParserMACRO_SYMBOL, GoogleSQLParserMAP_SYMBOL, GoogleSQLParserMATCH_SYMBOL, GoogleSQLParserKW_MATCH_RECOGNIZE_NONRESERVED_SYMBOL, GoogleSQLParserMATCHED_SYMBOL, GoogleSQLParserMATERIALIZED_SYMBOL, GoogleSQLParserMAX_SYMBOL, GoogleSQLParserMAXVALUE_SYMBOL, GoogleSQLParserMEASURES_SYMBOL, GoogleSQLParserMESSAGE_SYMBOL, GoogleSQLParserMETADATA_SYMBOL, GoogleSQLParserMIN_SYMBOL, GoogleSQLParserMINVALUE_SYMBOL, GoogleSQLParserMODEL_SYMBOL, GoogleSQLParserMODULE_SYMBOL, GoogleSQLParserONLY_SYMBOL, GoogleSQLParserOUT_SYMBOL, GoogleSQLParserOUTPUT_SYMBOL, GoogleSQLParserOVERWRITE_SYMBOL, GoogleSQLParserPARTITIONS_SYMBOL, GoogleSQLParserPATTERN_SYMBOL, GoogleSQLParserPOLICIES_SYMBOL, GoogleSQLParserPOLICY_SYMBOL, GoogleSQLParserPRIMARY_SYMBOL, GoogleSQLParserPRIVATE_SYMBOL, GoogleSQLParserPRIVILEGE_SYMBOL, GoogleSQLParserPRIVILEGES_SYMBOL, GoogleSQLParserPROCEDURE_SYMBOL, GoogleSQLParserPROJECT_SYMBOL, GoogleSQLParserPUBLIC_SYMBOL, GoogleSQLParserRAISE_SYMBOL, GoogleSQLParserREAD_SYMBOL, GoogleSQLParserREFERENCES_SYMBOL, GoogleSQLParserREMOTE_SYMBOL, GoogleSQLParserREMOVE_SYMBOL, GoogleSQLParserRENAME_SYMBOL, GoogleSQLParserREPEAT_SYMBOL, GoogleSQLParserREPEATABLE_SYMBOL, GoogleSQLParserREPLACE_FIELDS_SYMBOL, GoogleSQLParserREPLICA_SYMBOL, GoogleSQLParserREPORT_SYMBOL, GoogleSQLParserRESTRICT_SYMBOL, GoogleSQLParserRESTRICTION_SYMBOL, GoogleSQLParserRETURNS_SYMBOL, GoogleSQLParserRETURN_SYMBOL, GoogleSQLParserREVOKE_SYMBOL, GoogleSQLParserROLLBACK_SYMBOL, GoogleSQLParserROW_SYMBOL, GoogleSQLParserRUN_SYMBOL, GoogleSQLParserSAFE_CAST_SYMBOL, GoogleSQLParserSCHEMA_SYMBOL, GoogleSQLParserSEARCH_SYMBOL, GoogleSQLParserSECURITY_SYMBOL, GoogleSQLParserSEQUENCE_SYMBOL, GoogleSQLParserSETS_SYMBOL, GoogleSQLParserSHOW_SYMBOL, GoogleSQLParserSNAPSHOT_SYMBOL, GoogleSQLParserSOURCE_SYMBOL, GoogleSQLParserSQL_SYMBOL, GoogleSQLParserSTABLE_SYMBOL, GoogleSQLParserSTART_SYMBOL, GoogleSQLParserSTATIC_DESCRIBE_SYMBOL, GoogleSQLParserSTORED_SYMBOL, GoogleSQLParserSTORING_SYMBOL, GoogleSQLParserSTRICT_SYMBOL, GoogleSQLParserTABLE_SYMBOL, GoogleSQLParserTABLES_SYMBOL, GoogleSQLParserTARGET_SYMBOL, GoogleSQLParserTEMP_SYMBOL, GoogleSQLParserTEMPORARY_SYMBOL, GoogleSQLParserTRANSACTION_SYMBOL, GoogleSQLParserTRANSFORM_SYMBOL, GoogleSQLParserTRUNCATE_SYMBOL, GoogleSQLParserTYPE_SYMBOL, GoogleSQLParserUNDROP_SYMBOL, GoogleSQLParserUNIQUE_SYMBOL, GoogleSQLParserUNKNOWN_SYMBOL, GoogleSQLParserUNTIL_SYMBOL, GoogleSQLParserUPDATE_SYMBOL, GoogleSQLParserVALUES_SYMBOL, GoogleSQLParserVECTOR_SYMBOL, GoogleSQLParserVIEW_SYMBOL, GoogleSQLParserVIEWS_SYMBOL, GoogleSQLParserVOLATILE_SYMBOL, GoogleSQLParserWEIGHT_SYMBOL, GoogleSQLParserWHILE_SYMBOL, GoogleSQLParserWRITE_SYMBOL, GoogleSQLParserZONE_SYMBOL, GoogleSQLParserDESCRIPTOR_SYMBOL, GoogleSQLParserINTERLEAVE_SYMBOL, GoogleSQLParserNULL_FILTERED_SYMBOL, GoogleSQLParserPARENT_SYMBOL, GoogleSQLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1653)
			p.path_expression(0)
		}


	case GoogleSQLParserIF_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1654)
			p.Match(GoogleSQLParserIF_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1655)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJoin_typeContext is an interface to support dynamic dispatch.
type IJoin_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CROSS_SYMBOL() antlr.TerminalNode
	FULL_SYMBOL() antlr.TerminalNode
	Opt_outer() IOpt_outerContext
	INNER_SYMBOL() antlr.TerminalNode
	LEFT_SYMBOL() antlr.TerminalNode
	RIGHT_SYMBOL() antlr.TerminalNode

	// IsJoin_typeContext differentiates from other interfaces.
	IsJoin_typeContext()
}

type Join_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_typeContext() *Join_typeContext {
	var p = new(Join_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_join_type
	return p
}

func InitEmptyJoin_typeContext(p *Join_typeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_join_type
}

func (*Join_typeContext) IsJoin_typeContext() {}

func NewJoin_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_typeContext {
	var p = new(Join_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_join_type

	return p
}

func (s *Join_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_typeContext) CROSS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCROSS_SYMBOL, 0)
}

func (s *Join_typeContext) FULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFULL_SYMBOL, 0)
}

func (s *Join_typeContext) Opt_outer() IOpt_outerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_outerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_outerContext)
}

func (s *Join_typeContext) INNER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINNER_SYMBOL, 0)
}

func (s *Join_typeContext) LEFT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLEFT_SYMBOL, 0)
}

func (s *Join_typeContext) RIGHT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRIGHT_SYMBOL, 0)
}

func (s *Join_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Join_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterJoin_type(s)
	}
}

func (s *Join_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitJoin_type(s)
	}
}

func (s *Join_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitJoin_type(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Join_type() (localctx IJoin_typeContext) {
	localctx = NewJoin_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, GoogleSQLParserRULE_join_type)
	var _la int

	p.SetState(1672)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserCROSS_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1658)
			p.Match(GoogleSQLParserCROSS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case GoogleSQLParserFULL_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1659)
			p.Match(GoogleSQLParserFULL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1661)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserOUTER_SYMBOL {
			{
				p.SetState(1660)
				p.Opt_outer()
			}

		}


	case GoogleSQLParserINNER_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1663)
			p.Match(GoogleSQLParserINNER_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case GoogleSQLParserLEFT_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1664)
			p.Match(GoogleSQLParserLEFT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1666)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserOUTER_SYMBOL {
			{
				p.SetState(1665)
				p.Opt_outer()
			}

		}


	case GoogleSQLParserRIGHT_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1668)
			p.Match(GoogleSQLParserRIGHT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1670)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserOUTER_SYMBOL {
			{
				p.SetState(1669)
				p.Opt_outer()
			}

		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_naturalContext is an interface to support dynamic dispatch.
type IOpt_naturalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NATURAL_SYMBOL() antlr.TerminalNode

	// IsOpt_naturalContext differentiates from other interfaces.
	IsOpt_naturalContext()
}

type Opt_naturalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_naturalContext() *Opt_naturalContext {
	var p = new(Opt_naturalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_natural
	return p
}

func InitEmptyOpt_naturalContext(p *Opt_naturalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_natural
}

func (*Opt_naturalContext) IsOpt_naturalContext() {}

func NewOpt_naturalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_naturalContext {
	var p = new(Opt_naturalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_natural

	return p
}

func (s *Opt_naturalContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_naturalContext) NATURAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserNATURAL_SYMBOL, 0)
}

func (s *Opt_naturalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_naturalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_naturalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_natural(s)
	}
}

func (s *Opt_naturalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_natural(s)
	}
}

func (s *Opt_naturalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_natural(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_natural() (localctx IOpt_naturalContext) {
	localctx = NewOpt_naturalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, GoogleSQLParserRULE_opt_natural)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1674)
		p.Match(GoogleSQLParserNATURAL_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITablesample_operatorContext is an interface to support dynamic dispatch.
type ITablesample_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPercent returns the percent rule contexts.
	GetPercent() IInteger_typeContext


	// SetPercent sets the percent rule contexts.
	SetPercent(IInteger_typeContext)


	// Getter signatures
	TABLESAMPLE_SYMBOL() antlr.TerminalNode
	SYSTEM_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	PERCENT_SYMBOL() antlr.TerminalNode
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	Integer_type() IInteger_typeContext

	// IsTablesample_operatorContext differentiates from other interfaces.
	IsTablesample_operatorContext()
}

type Tablesample_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	percent IInteger_typeContext 
}

func NewEmptyTablesample_operatorContext() *Tablesample_operatorContext {
	var p = new(Tablesample_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_tablesample_operator
	return p
}

func InitEmptyTablesample_operatorContext(p *Tablesample_operatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_tablesample_operator
}

func (*Tablesample_operatorContext) IsTablesample_operatorContext() {}

func NewTablesample_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tablesample_operatorContext {
	var p = new(Tablesample_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_tablesample_operator

	return p
}

func (s *Tablesample_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Tablesample_operatorContext) GetPercent() IInteger_typeContext { return s.percent }


func (s *Tablesample_operatorContext) SetPercent(v IInteger_typeContext) { s.percent = v }


func (s *Tablesample_operatorContext) TABLESAMPLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTABLESAMPLE_SYMBOL, 0)
}

func (s *Tablesample_operatorContext) SYSTEM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSYSTEM_SYMBOL, 0)
}

func (s *Tablesample_operatorContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Tablesample_operatorContext) PERCENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPERCENT_SYMBOL, 0)
}

func (s *Tablesample_operatorContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Tablesample_operatorContext) Integer_type() IInteger_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInteger_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInteger_typeContext)
}

func (s *Tablesample_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tablesample_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Tablesample_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterTablesample_operator(s)
	}
}

func (s *Tablesample_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitTablesample_operator(s)
	}
}

func (s *Tablesample_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitTablesample_operator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Tablesample_operator() (localctx ITablesample_operatorContext) {
	localctx = NewTablesample_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, GoogleSQLParserRULE_tablesample_operator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1676)
		p.Match(GoogleSQLParserTABLESAMPLE_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1677)
		p.Match(GoogleSQLParserSYSTEM_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1678)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1679)

		var _x = p.Integer_type()


		localctx.(*Tablesample_operatorContext).percent = _x
	}
	{
		p.SetState(1680)
		p.Match(GoogleSQLParserPERCENT_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1681)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnpivot_operatorContext is an interface to support dynamic dispatch.
type IUnpivot_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnpivot_alias returns the unpivot_alias rule contexts.
	GetUnpivot_alias() IAs_aliasContext


	// SetUnpivot_alias sets the unpivot_alias rule contexts.
	SetUnpivot_alias(IAs_aliasContext)


	// Getter signatures
	UNPIVOT_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Single_column_unpivot() ISingle_column_unpivotContext
	Multi_column_unpivot() IMulti_column_unpivotContext
	INCLUDE_SYMBOL() antlr.TerminalNode
	NULLS_SYMBOL() antlr.TerminalNode
	EXCLUDE_SYMBOL() antlr.TerminalNode
	As_alias() IAs_aliasContext

	// IsUnpivot_operatorContext differentiates from other interfaces.
	IsUnpivot_operatorContext()
}

type Unpivot_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	unpivot_alias IAs_aliasContext 
}

func NewEmptyUnpivot_operatorContext() *Unpivot_operatorContext {
	var p = new(Unpivot_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_unpivot_operator
	return p
}

func InitEmptyUnpivot_operatorContext(p *Unpivot_operatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_unpivot_operator
}

func (*Unpivot_operatorContext) IsUnpivot_operatorContext() {}

func NewUnpivot_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unpivot_operatorContext {
	var p = new(Unpivot_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_unpivot_operator

	return p
}

func (s *Unpivot_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Unpivot_operatorContext) GetUnpivot_alias() IAs_aliasContext { return s.unpivot_alias }


func (s *Unpivot_operatorContext) SetUnpivot_alias(v IAs_aliasContext) { s.unpivot_alias = v }


func (s *Unpivot_operatorContext) UNPIVOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserUNPIVOT_SYMBOL, 0)
}

func (s *Unpivot_operatorContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Unpivot_operatorContext) Single_column_unpivot() ISingle_column_unpivotContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingle_column_unpivotContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingle_column_unpivotContext)
}

func (s *Unpivot_operatorContext) Multi_column_unpivot() IMulti_column_unpivotContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMulti_column_unpivotContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMulti_column_unpivotContext)
}

func (s *Unpivot_operatorContext) INCLUDE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINCLUDE_SYMBOL, 0)
}

func (s *Unpivot_operatorContext) NULLS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserNULLS_SYMBOL, 0)
}

func (s *Unpivot_operatorContext) EXCLUDE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEXCLUDE_SYMBOL, 0)
}

func (s *Unpivot_operatorContext) As_alias() IAs_aliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAs_aliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAs_aliasContext)
}

func (s *Unpivot_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unpivot_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Unpivot_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterUnpivot_operator(s)
	}
}

func (s *Unpivot_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitUnpivot_operator(s)
	}
}

func (s *Unpivot_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitUnpivot_operator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Unpivot_operator() (localctx IUnpivot_operatorContext) {
	localctx = NewUnpivot_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, GoogleSQLParserRULE_unpivot_operator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1683)
		p.Match(GoogleSQLParserUNPIVOT_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1688)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserINCLUDE_SYMBOL:
		{
			p.SetState(1684)
			p.Match(GoogleSQLParserINCLUDE_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1685)
			p.Match(GoogleSQLParserNULLS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case GoogleSQLParserEXCLUDE_SYMBOL:
		{
			p.SetState(1686)
			p.Match(GoogleSQLParserEXCLUDE_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1687)
			p.Match(GoogleSQLParserNULLS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case GoogleSQLParserLR_BRACKET_SYMBOL:



	default:
	}
	{
		p.SetState(1690)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1693)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 160, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1691)
			p.Single_column_unpivot()
		}


	case 2:
		{
			p.SetState(1692)
			p.Multi_column_unpivot()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1696)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserAS_SYMBOL || _la == GoogleSQLParserQUOTED_ID || _la == GoogleSQLParserID {
		{
			p.SetState(1695)

			var _x = p.As_alias()


			localctx.(*Unpivot_operatorContext).unpivot_alias = _x
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISingle_column_unpivotContext is an interface to support dynamic dispatch.
type ISingle_column_unpivotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValues_column returns the values_column rule contexts.
	GetValues_column() IColumn_nameContext

	// GetName_column returns the name_column rule contexts.
	GetName_column() IColumn_nameContext


	// SetValues_column sets the values_column rule contexts.
	SetValues_column(IColumn_nameContext)

	// SetName_column sets the name_column rule contexts.
	SetName_column(IColumn_nameContext)


	// Getter signatures
	FOR_SYMBOL() antlr.TerminalNode
	IN_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Columns_to_unpivot_list() IColumns_to_unpivot_listContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	AllColumn_name() []IColumn_nameContext
	Column_name(i int) IColumn_nameContext

	// IsSingle_column_unpivotContext differentiates from other interfaces.
	IsSingle_column_unpivotContext()
}

type Single_column_unpivotContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	values_column IColumn_nameContext 
	name_column IColumn_nameContext 
}

func NewEmptySingle_column_unpivotContext() *Single_column_unpivotContext {
	var p = new(Single_column_unpivotContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_single_column_unpivot
	return p
}

func InitEmptySingle_column_unpivotContext(p *Single_column_unpivotContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_single_column_unpivot
}

func (*Single_column_unpivotContext) IsSingle_column_unpivotContext() {}

func NewSingle_column_unpivotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_column_unpivotContext {
	var p = new(Single_column_unpivotContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_single_column_unpivot

	return p
}

func (s *Single_column_unpivotContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_column_unpivotContext) GetValues_column() IColumn_nameContext { return s.values_column }

func (s *Single_column_unpivotContext) GetName_column() IColumn_nameContext { return s.name_column }


func (s *Single_column_unpivotContext) SetValues_column(v IColumn_nameContext) { s.values_column = v }

func (s *Single_column_unpivotContext) SetName_column(v IColumn_nameContext) { s.name_column = v }


func (s *Single_column_unpivotContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFOR_SYMBOL, 0)
}

func (s *Single_column_unpivotContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserIN_SYMBOL, 0)
}

func (s *Single_column_unpivotContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Single_column_unpivotContext) Columns_to_unpivot_list() IColumns_to_unpivot_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumns_to_unpivot_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumns_to_unpivot_listContext)
}

func (s *Single_column_unpivotContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Single_column_unpivotContext) AllColumn_name() []IColumn_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumn_nameContext); ok {
			len++
		}
	}

	tst := make([]IColumn_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumn_nameContext); ok {
			tst[i] = t.(IColumn_nameContext)
			i++
		}
	}

	return tst
}

func (s *Single_column_unpivotContext) Column_name(i int) IColumn_nameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Single_column_unpivotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_column_unpivotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Single_column_unpivotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSingle_column_unpivot(s)
	}
}

func (s *Single_column_unpivotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSingle_column_unpivot(s)
	}
}

func (s *Single_column_unpivotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSingle_column_unpivot(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Single_column_unpivot() (localctx ISingle_column_unpivotContext) {
	localctx = NewSingle_column_unpivotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, GoogleSQLParserRULE_single_column_unpivot)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1698)

		var _x = p.Column_name()


		localctx.(*Single_column_unpivotContext).values_column = _x
	}
	{
		p.SetState(1699)
		p.Match(GoogleSQLParserFOR_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1700)

		var _x = p.Column_name()


		localctx.(*Single_column_unpivotContext).name_column = _x
	}
	{
		p.SetState(1701)
		p.Match(GoogleSQLParserIN_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1702)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1703)
		p.Columns_to_unpivot_list()
	}
	{
		p.SetState(1704)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMulti_column_unpivotContext is an interface to support dynamic dispatch.
type IMulti_column_unpivotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName_column returns the name_column rule contexts.
	GetName_column() IColumn_nameContext


	// SetName_column sets the name_column rule contexts.
	SetName_column(IColumn_nameContext)


	// Getter signatures
	Values_column_set() IValues_column_setContext
	FOR_SYMBOL() antlr.TerminalNode
	IN_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Column_sets_to_unpivot() IColumn_sets_to_unpivotContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	Column_name() IColumn_nameContext

	// IsMulti_column_unpivotContext differentiates from other interfaces.
	IsMulti_column_unpivotContext()
}

type Multi_column_unpivotContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name_column IColumn_nameContext 
}

func NewEmptyMulti_column_unpivotContext() *Multi_column_unpivotContext {
	var p = new(Multi_column_unpivotContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_multi_column_unpivot
	return p
}

func InitEmptyMulti_column_unpivotContext(p *Multi_column_unpivotContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_multi_column_unpivot
}

func (*Multi_column_unpivotContext) IsMulti_column_unpivotContext() {}

func NewMulti_column_unpivotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multi_column_unpivotContext {
	var p = new(Multi_column_unpivotContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_multi_column_unpivot

	return p
}

func (s *Multi_column_unpivotContext) GetParser() antlr.Parser { return s.parser }

func (s *Multi_column_unpivotContext) GetName_column() IColumn_nameContext { return s.name_column }


func (s *Multi_column_unpivotContext) SetName_column(v IColumn_nameContext) { s.name_column = v }


func (s *Multi_column_unpivotContext) Values_column_set() IValues_column_setContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_column_setContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_column_setContext)
}

func (s *Multi_column_unpivotContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFOR_SYMBOL, 0)
}

func (s *Multi_column_unpivotContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserIN_SYMBOL, 0)
}

func (s *Multi_column_unpivotContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Multi_column_unpivotContext) Column_sets_to_unpivot() IColumn_sets_to_unpivotContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_sets_to_unpivotContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_sets_to_unpivotContext)
}

func (s *Multi_column_unpivotContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Multi_column_unpivotContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Multi_column_unpivotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multi_column_unpivotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Multi_column_unpivotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterMulti_column_unpivot(s)
	}
}

func (s *Multi_column_unpivotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitMulti_column_unpivot(s)
	}
}

func (s *Multi_column_unpivotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitMulti_column_unpivot(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Multi_column_unpivot() (localctx IMulti_column_unpivotContext) {
	localctx = NewMulti_column_unpivotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, GoogleSQLParserRULE_multi_column_unpivot)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1706)
		p.Values_column_set()
	}
	{
		p.SetState(1707)
		p.Match(GoogleSQLParserFOR_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1708)

		var _x = p.Column_name()


		localctx.(*Multi_column_unpivotContext).name_column = _x
	}
	{
		p.SetState(1709)
		p.Match(GoogleSQLParserIN_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1710)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1711)
		p.Column_sets_to_unpivot()
	}
	{
		p.SetState(1712)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IValues_column_setContext is an interface to support dynamic dispatch.
type IValues_column_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValues_column returns the values_column rule contexts.
	GetValues_column() IColumn_nameContext


	// SetValues_column sets the values_column rule contexts.
	SetValues_column(IColumn_nameContext)


	// Getter signatures
	AllColumn_name() []IColumn_nameContext
	Column_name(i int) IColumn_nameContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsValues_column_setContext differentiates from other interfaces.
	IsValues_column_setContext()
}

type Values_column_setContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	values_column IColumn_nameContext 
}

func NewEmptyValues_column_setContext() *Values_column_setContext {
	var p = new(Values_column_setContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_values_column_set
	return p
}

func InitEmptyValues_column_setContext(p *Values_column_setContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_values_column_set
}

func (*Values_column_setContext) IsValues_column_setContext() {}

func NewValues_column_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Values_column_setContext {
	var p = new(Values_column_setContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_values_column_set

	return p
}

func (s *Values_column_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Values_column_setContext) GetValues_column() IColumn_nameContext { return s.values_column }


func (s *Values_column_setContext) SetValues_column(v IColumn_nameContext) { s.values_column = v }


func (s *Values_column_setContext) AllColumn_name() []IColumn_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumn_nameContext); ok {
			len++
		}
	}

	tst := make([]IColumn_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumn_nameContext); ok {
			tst[i] = t.(IColumn_nameContext)
			i++
		}
	}

	return tst
}

func (s *Values_column_setContext) Column_name(i int) IColumn_nameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Values_column_setContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Values_column_setContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Values_column_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Values_column_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Values_column_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterValues_column_set(s)
	}
}

func (s *Values_column_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitValues_column_set(s)
	}
}

func (s *Values_column_setContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitValues_column_set(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Values_column_set() (localctx IValues_column_setContext) {
	localctx = NewValues_column_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, GoogleSQLParserRULE_values_column_set)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1714)

		var _x = p.Column_name()


		localctx.(*Values_column_setContext).values_column = _x
	}
	p.SetState(1719)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(1715)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1716)

			var _x = p.Column_name()


			localctx.(*Values_column_setContext).values_column = _x
		}


		p.SetState(1721)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumns_to_unpivot_listContext is an interface to support dynamic dispatch.
type IColumns_to_unpivot_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumns_to_unpivot_item() []IColumns_to_unpivot_itemContext
	Columns_to_unpivot_item(i int) IColumns_to_unpivot_itemContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsColumns_to_unpivot_listContext differentiates from other interfaces.
	IsColumns_to_unpivot_listContext()
}

type Columns_to_unpivot_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumns_to_unpivot_listContext() *Columns_to_unpivot_listContext {
	var p = new(Columns_to_unpivot_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_columns_to_unpivot_list
	return p
}

func InitEmptyColumns_to_unpivot_listContext(p *Columns_to_unpivot_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_columns_to_unpivot_list
}

func (*Columns_to_unpivot_listContext) IsColumns_to_unpivot_listContext() {}

func NewColumns_to_unpivot_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Columns_to_unpivot_listContext {
	var p = new(Columns_to_unpivot_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_columns_to_unpivot_list

	return p
}

func (s *Columns_to_unpivot_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Columns_to_unpivot_listContext) AllColumns_to_unpivot_item() []IColumns_to_unpivot_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumns_to_unpivot_itemContext); ok {
			len++
		}
	}

	tst := make([]IColumns_to_unpivot_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumns_to_unpivot_itemContext); ok {
			tst[i] = t.(IColumns_to_unpivot_itemContext)
			i++
		}
	}

	return tst
}

func (s *Columns_to_unpivot_listContext) Columns_to_unpivot_item(i int) IColumns_to_unpivot_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumns_to_unpivot_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumns_to_unpivot_itemContext)
}

func (s *Columns_to_unpivot_listContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Columns_to_unpivot_listContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Columns_to_unpivot_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Columns_to_unpivot_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Columns_to_unpivot_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterColumns_to_unpivot_list(s)
	}
}

func (s *Columns_to_unpivot_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitColumns_to_unpivot_list(s)
	}
}

func (s *Columns_to_unpivot_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitColumns_to_unpivot_list(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Columns_to_unpivot_list() (localctx IColumns_to_unpivot_listContext) {
	localctx = NewColumns_to_unpivot_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, GoogleSQLParserRULE_columns_to_unpivot_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1722)
		p.Columns_to_unpivot_item()
	}
	p.SetState(1727)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(1723)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1724)
			p.Columns_to_unpivot_item()
		}


		p.SetState(1729)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumns_to_unpivot_itemContext is an interface to support dynamic dispatch.
type IColumns_to_unpivot_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnpivot_column returns the unpivot_column rule contexts.
	GetUnpivot_column() IColumn_nameContext

	// GetRow_value_alias returns the row_value_alias rule contexts.
	GetRow_value_alias() IAs_aliasContext


	// SetUnpivot_column sets the unpivot_column rule contexts.
	SetUnpivot_column(IColumn_nameContext)

	// SetRow_value_alias sets the row_value_alias rule contexts.
	SetRow_value_alias(IAs_aliasContext)


	// Getter signatures
	Column_name() IColumn_nameContext
	As_alias() IAs_aliasContext

	// IsColumns_to_unpivot_itemContext differentiates from other interfaces.
	IsColumns_to_unpivot_itemContext()
}

type Columns_to_unpivot_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	unpivot_column IColumn_nameContext 
	row_value_alias IAs_aliasContext 
}

func NewEmptyColumns_to_unpivot_itemContext() *Columns_to_unpivot_itemContext {
	var p = new(Columns_to_unpivot_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_columns_to_unpivot_item
	return p
}

func InitEmptyColumns_to_unpivot_itemContext(p *Columns_to_unpivot_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_columns_to_unpivot_item
}

func (*Columns_to_unpivot_itemContext) IsColumns_to_unpivot_itemContext() {}

func NewColumns_to_unpivot_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Columns_to_unpivot_itemContext {
	var p = new(Columns_to_unpivot_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_columns_to_unpivot_item

	return p
}

func (s *Columns_to_unpivot_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Columns_to_unpivot_itemContext) GetUnpivot_column() IColumn_nameContext { return s.unpivot_column }

func (s *Columns_to_unpivot_itemContext) GetRow_value_alias() IAs_aliasContext { return s.row_value_alias }


func (s *Columns_to_unpivot_itemContext) SetUnpivot_column(v IColumn_nameContext) { s.unpivot_column = v }

func (s *Columns_to_unpivot_itemContext) SetRow_value_alias(v IAs_aliasContext) { s.row_value_alias = v }


func (s *Columns_to_unpivot_itemContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Columns_to_unpivot_itemContext) As_alias() IAs_aliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAs_aliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAs_aliasContext)
}

func (s *Columns_to_unpivot_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Columns_to_unpivot_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Columns_to_unpivot_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterColumns_to_unpivot_item(s)
	}
}

func (s *Columns_to_unpivot_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitColumns_to_unpivot_item(s)
	}
}

func (s *Columns_to_unpivot_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitColumns_to_unpivot_item(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Columns_to_unpivot_item() (localctx IColumns_to_unpivot_itemContext) {
	localctx = NewColumns_to_unpivot_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, GoogleSQLParserRULE_columns_to_unpivot_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1730)

		var _x = p.Column_name()


		localctx.(*Columns_to_unpivot_itemContext).unpivot_column = _x
	}
	p.SetState(1732)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserAS_SYMBOL || _la == GoogleSQLParserQUOTED_ID || _la == GoogleSQLParserID {
		{
			p.SetState(1731)

			var _x = p.As_alias()


			localctx.(*Columns_to_unpivot_itemContext).row_value_alias = _x
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumn_sets_to_unpivotContext is an interface to support dynamic dispatch.
type IColumn_sets_to_unpivotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Columns_to_unpivot_list() IColumns_to_unpivot_listContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsColumn_sets_to_unpivotContext differentiates from other interfaces.
	IsColumn_sets_to_unpivotContext()
}

type Column_sets_to_unpivotContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_sets_to_unpivotContext() *Column_sets_to_unpivotContext {
	var p = new(Column_sets_to_unpivotContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_column_sets_to_unpivot
	return p
}

func InitEmptyColumn_sets_to_unpivotContext(p *Column_sets_to_unpivotContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_column_sets_to_unpivot
}

func (*Column_sets_to_unpivotContext) IsColumn_sets_to_unpivotContext() {}

func NewColumn_sets_to_unpivotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_sets_to_unpivotContext {
	var p = new(Column_sets_to_unpivotContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_column_sets_to_unpivot

	return p
}

func (s *Column_sets_to_unpivotContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_sets_to_unpivotContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Column_sets_to_unpivotContext) Columns_to_unpivot_list() IColumns_to_unpivot_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumns_to_unpivot_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumns_to_unpivot_listContext)
}

func (s *Column_sets_to_unpivotContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Column_sets_to_unpivotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_sets_to_unpivotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Column_sets_to_unpivotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterColumn_sets_to_unpivot(s)
	}
}

func (s *Column_sets_to_unpivotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitColumn_sets_to_unpivot(s)
	}
}

func (s *Column_sets_to_unpivotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitColumn_sets_to_unpivot(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Column_sets_to_unpivot() (localctx IColumn_sets_to_unpivotContext) {
	localctx = NewColumn_sets_to_unpivotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, GoogleSQLParserRULE_column_sets_to_unpivot)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1734)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1735)
		p.Columns_to_unpivot_list()
	}
	{
		p.SetState(1736)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPivot_operatorContext is an interface to support dynamic dispatch.
type IPivot_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInput_column returns the input_column rule contexts.
	GetInput_column() IColumn_nameContext


	// SetInput_column sets the input_column rule contexts.
	SetInput_column(IColumn_nameContext)


	// Getter signatures
	PIVOT_SYMBOL() antlr.TerminalNode
	AllLR_BRACKET_SYMBOL() []antlr.TerminalNode
	LR_BRACKET_SYMBOL(i int) antlr.TerminalNode
	Aggregate_function_call_as_alias_list() IAggregate_function_call_as_alias_listContext
	FOR_SYMBOL() antlr.TerminalNode
	IN_SYMBOL() antlr.TerminalNode
	Pivot_column_as_alias_list() IPivot_column_as_alias_listContext
	AllRR_BRACKET_SYMBOL() []antlr.TerminalNode
	RR_BRACKET_SYMBOL(i int) antlr.TerminalNode
	Column_name() IColumn_nameContext
	As_alias() IAs_aliasContext

	// IsPivot_operatorContext differentiates from other interfaces.
	IsPivot_operatorContext()
}

type Pivot_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	input_column IColumn_nameContext 
}

func NewEmptyPivot_operatorContext() *Pivot_operatorContext {
	var p = new(Pivot_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_pivot_operator
	return p
}

func InitEmptyPivot_operatorContext(p *Pivot_operatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_pivot_operator
}

func (*Pivot_operatorContext) IsPivot_operatorContext() {}

func NewPivot_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pivot_operatorContext {
	var p = new(Pivot_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_pivot_operator

	return p
}

func (s *Pivot_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Pivot_operatorContext) GetInput_column() IColumn_nameContext { return s.input_column }


func (s *Pivot_operatorContext) SetInput_column(v IColumn_nameContext) { s.input_column = v }


func (s *Pivot_operatorContext) PIVOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPIVOT_SYMBOL, 0)
}

func (s *Pivot_operatorContext) AllLR_BRACKET_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserLR_BRACKET_SYMBOL)
}

func (s *Pivot_operatorContext) LR_BRACKET_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, i)
}

func (s *Pivot_operatorContext) Aggregate_function_call_as_alias_list() IAggregate_function_call_as_alias_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregate_function_call_as_alias_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregate_function_call_as_alias_listContext)
}

func (s *Pivot_operatorContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFOR_SYMBOL, 0)
}

func (s *Pivot_operatorContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserIN_SYMBOL, 0)
}

func (s *Pivot_operatorContext) Pivot_column_as_alias_list() IPivot_column_as_alias_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivot_column_as_alias_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivot_column_as_alias_listContext)
}

func (s *Pivot_operatorContext) AllRR_BRACKET_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserRR_BRACKET_SYMBOL)
}

func (s *Pivot_operatorContext) RR_BRACKET_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, i)
}

func (s *Pivot_operatorContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Pivot_operatorContext) As_alias() IAs_aliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAs_aliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAs_aliasContext)
}

func (s *Pivot_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pivot_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Pivot_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterPivot_operator(s)
	}
}

func (s *Pivot_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitPivot_operator(s)
	}
}

func (s *Pivot_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitPivot_operator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Pivot_operator() (localctx IPivot_operatorContext) {
	localctx = NewPivot_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, GoogleSQLParserRULE_pivot_operator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1738)
		p.Match(GoogleSQLParserPIVOT_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1739)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1740)
		p.Aggregate_function_call_as_alias_list()
	}
	{
		p.SetState(1741)
		p.Match(GoogleSQLParserFOR_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1742)

		var _x = p.Column_name()


		localctx.(*Pivot_operatorContext).input_column = _x
	}
	{
		p.SetState(1743)
		p.Match(GoogleSQLParserIN_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1744)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1745)
		p.Pivot_column_as_alias_list()
	}
	{
		p.SetState(1746)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1747)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1749)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserAS_SYMBOL || _la == GoogleSQLParserQUOTED_ID || _la == GoogleSQLParserID {
		{
			p.SetState(1748)
			p.As_alias()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPivot_column_as_alias_listContext is an interface to support dynamic dispatch.
type IPivot_column_as_alias_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPivot_column_as_alias_list_item() []IPivot_column_as_alias_list_itemContext
	Pivot_column_as_alias_list_item(i int) IPivot_column_as_alias_list_itemContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsPivot_column_as_alias_listContext differentiates from other interfaces.
	IsPivot_column_as_alias_listContext()
}

type Pivot_column_as_alias_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivot_column_as_alias_listContext() *Pivot_column_as_alias_listContext {
	var p = new(Pivot_column_as_alias_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_pivot_column_as_alias_list
	return p
}

func InitEmptyPivot_column_as_alias_listContext(p *Pivot_column_as_alias_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_pivot_column_as_alias_list
}

func (*Pivot_column_as_alias_listContext) IsPivot_column_as_alias_listContext() {}

func NewPivot_column_as_alias_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pivot_column_as_alias_listContext {
	var p = new(Pivot_column_as_alias_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_pivot_column_as_alias_list

	return p
}

func (s *Pivot_column_as_alias_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Pivot_column_as_alias_listContext) AllPivot_column_as_alias_list_item() []IPivot_column_as_alias_list_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPivot_column_as_alias_list_itemContext); ok {
			len++
		}
	}

	tst := make([]IPivot_column_as_alias_list_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPivot_column_as_alias_list_itemContext); ok {
			tst[i] = t.(IPivot_column_as_alias_list_itemContext)
			i++
		}
	}

	return tst
}

func (s *Pivot_column_as_alias_listContext) Pivot_column_as_alias_list_item(i int) IPivot_column_as_alias_list_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivot_column_as_alias_list_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivot_column_as_alias_list_itemContext)
}

func (s *Pivot_column_as_alias_listContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Pivot_column_as_alias_listContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Pivot_column_as_alias_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pivot_column_as_alias_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Pivot_column_as_alias_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterPivot_column_as_alias_list(s)
	}
}

func (s *Pivot_column_as_alias_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitPivot_column_as_alias_list(s)
	}
}

func (s *Pivot_column_as_alias_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitPivot_column_as_alias_list(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Pivot_column_as_alias_list() (localctx IPivot_column_as_alias_listContext) {
	localctx = NewPivot_column_as_alias_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, GoogleSQLParserRULE_pivot_column_as_alias_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1751)
		p.Pivot_column_as_alias_list_item()
	}
	p.SetState(1756)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(1752)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1753)
			p.Pivot_column_as_alias_list_item()
		}


		p.SetState(1758)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPivot_column_as_alias_list_itemContext is an interface to support dynamic dispatch.
type IPivot_column_as_alias_list_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPivot_column returns the pivot_column rule contexts.
	GetPivot_column() IColumn_nameContext


	// SetPivot_column sets the pivot_column rule contexts.
	SetPivot_column(IColumn_nameContext)


	// Getter signatures
	Column_name() IColumn_nameContext
	As_alias() IAs_aliasContext

	// IsPivot_column_as_alias_list_itemContext differentiates from other interfaces.
	IsPivot_column_as_alias_list_itemContext()
}

type Pivot_column_as_alias_list_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	pivot_column IColumn_nameContext 
}

func NewEmptyPivot_column_as_alias_list_itemContext() *Pivot_column_as_alias_list_itemContext {
	var p = new(Pivot_column_as_alias_list_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_pivot_column_as_alias_list_item
	return p
}

func InitEmptyPivot_column_as_alias_list_itemContext(p *Pivot_column_as_alias_list_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_pivot_column_as_alias_list_item
}

func (*Pivot_column_as_alias_list_itemContext) IsPivot_column_as_alias_list_itemContext() {}

func NewPivot_column_as_alias_list_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pivot_column_as_alias_list_itemContext {
	var p = new(Pivot_column_as_alias_list_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_pivot_column_as_alias_list_item

	return p
}

func (s *Pivot_column_as_alias_list_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Pivot_column_as_alias_list_itemContext) GetPivot_column() IColumn_nameContext { return s.pivot_column }


func (s *Pivot_column_as_alias_list_itemContext) SetPivot_column(v IColumn_nameContext) { s.pivot_column = v }


func (s *Pivot_column_as_alias_list_itemContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Pivot_column_as_alias_list_itemContext) As_alias() IAs_aliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAs_aliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAs_aliasContext)
}

func (s *Pivot_column_as_alias_list_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pivot_column_as_alias_list_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Pivot_column_as_alias_list_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterPivot_column_as_alias_list_item(s)
	}
}

func (s *Pivot_column_as_alias_list_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitPivot_column_as_alias_list_item(s)
	}
}

func (s *Pivot_column_as_alias_list_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitPivot_column_as_alias_list_item(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Pivot_column_as_alias_list_item() (localctx IPivot_column_as_alias_list_itemContext) {
	localctx = NewPivot_column_as_alias_list_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, GoogleSQLParserRULE_pivot_column_as_alias_list_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1759)

		var _x = p.Column_name()


		localctx.(*Pivot_column_as_alias_list_itemContext).pivot_column = _x
	}
	p.SetState(1761)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserAS_SYMBOL || _la == GoogleSQLParserQUOTED_ID || _la == GoogleSQLParserID {
		{
			p.SetState(1760)
			p.As_alias()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAggregate_function_call_as_alias_listContext is an interface to support dynamic dispatch.
type IAggregate_function_call_as_alias_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAggregate_function_call_as_alias_list_item() []IAggregate_function_call_as_alias_list_itemContext
	Aggregate_function_call_as_alias_list_item(i int) IAggregate_function_call_as_alias_list_itemContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsAggregate_function_call_as_alias_listContext differentiates from other interfaces.
	IsAggregate_function_call_as_alias_listContext()
}

type Aggregate_function_call_as_alias_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregate_function_call_as_alias_listContext() *Aggregate_function_call_as_alias_listContext {
	var p = new(Aggregate_function_call_as_alias_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_aggregate_function_call_as_alias_list
	return p
}

func InitEmptyAggregate_function_call_as_alias_listContext(p *Aggregate_function_call_as_alias_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_aggregate_function_call_as_alias_list
}

func (*Aggregate_function_call_as_alias_listContext) IsAggregate_function_call_as_alias_listContext() {}

func NewAggregate_function_call_as_alias_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Aggregate_function_call_as_alias_listContext {
	var p = new(Aggregate_function_call_as_alias_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_aggregate_function_call_as_alias_list

	return p
}

func (s *Aggregate_function_call_as_alias_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Aggregate_function_call_as_alias_listContext) AllAggregate_function_call_as_alias_list_item() []IAggregate_function_call_as_alias_list_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAggregate_function_call_as_alias_list_itemContext); ok {
			len++
		}
	}

	tst := make([]IAggregate_function_call_as_alias_list_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAggregate_function_call_as_alias_list_itemContext); ok {
			tst[i] = t.(IAggregate_function_call_as_alias_list_itemContext)
			i++
		}
	}

	return tst
}

func (s *Aggregate_function_call_as_alias_listContext) Aggregate_function_call_as_alias_list_item(i int) IAggregate_function_call_as_alias_list_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregate_function_call_as_alias_list_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregate_function_call_as_alias_list_itemContext)
}

func (s *Aggregate_function_call_as_alias_listContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Aggregate_function_call_as_alias_listContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Aggregate_function_call_as_alias_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Aggregate_function_call_as_alias_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Aggregate_function_call_as_alias_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterAggregate_function_call_as_alias_list(s)
	}
}

func (s *Aggregate_function_call_as_alias_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitAggregate_function_call_as_alias_list(s)
	}
}

func (s *Aggregate_function_call_as_alias_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitAggregate_function_call_as_alias_list(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Aggregate_function_call_as_alias_list() (localctx IAggregate_function_call_as_alias_listContext) {
	localctx = NewAggregate_function_call_as_alias_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, GoogleSQLParserRULE_aggregate_function_call_as_alias_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1763)
		p.Aggregate_function_call_as_alias_list_item()
	}
	p.SetState(1768)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(1764)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1765)
			p.Aggregate_function_call_as_alias_list_item()
		}


		p.SetState(1770)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAggregate_function_call_as_alias_list_itemContext is an interface to support dynamic dispatch.
type IAggregate_function_call_as_alias_list_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	As_alias() IAs_aliasContext

	// IsAggregate_function_call_as_alias_list_itemContext differentiates from other interfaces.
	IsAggregate_function_call_as_alias_list_itemContext()
}

type Aggregate_function_call_as_alias_list_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregate_function_call_as_alias_list_itemContext() *Aggregate_function_call_as_alias_list_itemContext {
	var p = new(Aggregate_function_call_as_alias_list_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_aggregate_function_call_as_alias_list_item
	return p
}

func InitEmptyAggregate_function_call_as_alias_list_itemContext(p *Aggregate_function_call_as_alias_list_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_aggregate_function_call_as_alias_list_item
}

func (*Aggregate_function_call_as_alias_list_itemContext) IsAggregate_function_call_as_alias_list_itemContext() {}

func NewAggregate_function_call_as_alias_list_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Aggregate_function_call_as_alias_list_itemContext {
	var p = new(Aggregate_function_call_as_alias_list_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_aggregate_function_call_as_alias_list_item

	return p
}

func (s *Aggregate_function_call_as_alias_list_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Aggregate_function_call_as_alias_list_itemContext) As_alias() IAs_aliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAs_aliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAs_aliasContext)
}

func (s *Aggregate_function_call_as_alias_list_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Aggregate_function_call_as_alias_list_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Aggregate_function_call_as_alias_list_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterAggregate_function_call_as_alias_list_item(s)
	}
}

func (s *Aggregate_function_call_as_alias_list_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitAggregate_function_call_as_alias_list_item(s)
	}
}

func (s *Aggregate_function_call_as_alias_list_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitAggregate_function_call_as_alias_list_item(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Aggregate_function_call_as_alias_list_item() (localctx IAggregate_function_call_as_alias_list_itemContext) {
	localctx = NewAggregate_function_call_as_alias_list_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, GoogleSQLParserRULE_aggregate_function_call_as_alias_list_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1772)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserAS_SYMBOL || _la == GoogleSQLParserQUOTED_ID || _la == GoogleSQLParserID {
		{
			p.SetState(1771)
			p.As_alias()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFrom_itemContext is an interface to support dynamic dispatch.
type IFrom_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_name() ITable_nameContext
	As_alias() IAs_aliasContext
	FOR_SYMBOL() antlr.TerminalNode
	SYSTEM_TIME_SYMBOL() antlr.TerminalNode
	AS_SYMBOL() antlr.TerminalNode
	OF_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	AllFrom_item() []IFrom_itemContext
	From_item(i int) IFrom_itemContext
	Cross_join_operator() ICross_join_operatorContext
	Conditional_join_operator() IConditional_join_operatorContext
	Join_condition() IJoin_conditionContext
	Query() IQueryContext
	Unnest_operator() IUnnest_operatorContext
	Cte_name() ICte_nameContext

	// IsFrom_itemContext differentiates from other interfaces.
	IsFrom_itemContext()
}

type From_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_itemContext() *From_itemContext {
	var p = new(From_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_from_item
	return p
}

func InitEmptyFrom_itemContext(p *From_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_from_item
}

func (*From_itemContext) IsFrom_itemContext() {}

func NewFrom_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_itemContext {
	var p = new(From_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_from_item

	return p
}

func (s *From_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *From_itemContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *From_itemContext) As_alias() IAs_aliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAs_aliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAs_aliasContext)
}

func (s *From_itemContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFOR_SYMBOL, 0)
}

func (s *From_itemContext) SYSTEM_TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSYSTEM_TIME_SYMBOL, 0)
}

func (s *From_itemContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAS_SYMBOL, 0)
}

func (s *From_itemContext) OF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserOF_SYMBOL, 0)
}

func (s *From_itemContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *From_itemContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *From_itemContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *From_itemContext) AllFrom_item() []IFrom_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrom_itemContext); ok {
			len++
		}
	}

	tst := make([]IFrom_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrom_itemContext); ok {
			tst[i] = t.(IFrom_itemContext)
			i++
		}
	}

	return tst
}

func (s *From_itemContext) From_item(i int) IFrom_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_itemContext)
}

func (s *From_itemContext) Cross_join_operator() ICross_join_operatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICross_join_operatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICross_join_operatorContext)
}

func (s *From_itemContext) Conditional_join_operator() IConditional_join_operatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditional_join_operatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditional_join_operatorContext)
}

func (s *From_itemContext) Join_condition() IJoin_conditionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoin_conditionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoin_conditionContext)
}

func (s *From_itemContext) Query() IQueryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *From_itemContext) Unnest_operator() IUnnest_operatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnnest_operatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnnest_operatorContext)
}

func (s *From_itemContext) Cte_name() ICte_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICte_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICte_nameContext)
}

func (s *From_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *From_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterFrom_item(s)
	}
}

func (s *From_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitFrom_item(s)
	}
}

func (s *From_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitFrom_item(s)

	default:
		return t.VisitChildren(s)
	}
}





func (p *GoogleSQLParser) From_item() (localctx IFrom_itemContext) {
	return p.from_item(0)
}

func (p *GoogleSQLParser) from_item(_p int) (localctx IFrom_itemContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewFrom_itemContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFrom_itemContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 260
	p.EnterRecursionRule(localctx, 260, GoogleSQLParserRULE_from_item, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1811)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 175, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1775)
			p.Table_name()
		}
		p.SetState(1777)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1776)
				p.As_alias()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(1784)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1779)
				p.Match(GoogleSQLParserFOR_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1780)
				p.Match(GoogleSQLParserSYSTEM_TIME_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1781)
				p.Match(GoogleSQLParserAS_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1782)
				p.Match(GoogleSQLParserOF_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1783)
				p.expression(0)
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		{
			p.SetState(1786)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1796)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 172, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1787)
				p.from_item(0)
			}
			{
				p.SetState(1788)
				p.Cross_join_operator()
			}
			{
				p.SetState(1789)
				p.from_item(0)
			}


		case 2:
			{
				p.SetState(1791)
				p.from_item(0)
			}
			{
				p.SetState(1792)
				p.Conditional_join_operator()
			}
			{
				p.SetState(1793)
				p.from_item(0)
			}
			{
				p.SetState(1794)
				p.Join_condition()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(1798)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		{
			p.SetState(1800)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1801)
			p.Query()
		}
		{
			p.SetState(1802)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1804)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 173, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1803)
				p.As_alias()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 4:
		{
			p.SetState(1806)
			p.Unnest_operator()
		}


	case 5:
		{
			p.SetState(1807)
			p.Cte_name()
		}
		p.SetState(1809)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 174, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1808)
				p.As_alias()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1824)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1822)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext()) {
			case 1:
				localctx = NewFrom_itemContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_from_item)
				p.SetState(1813)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(1814)
					p.Cross_join_operator()
				}
				{
					p.SetState(1815)
					p.from_item(7)
				}


			case 2:
				localctx = NewFrom_itemContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_from_item)
				p.SetState(1817)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(1818)
					p.Conditional_join_operator()
				}
				{
					p.SetState(1819)
					p.from_item(0)
				}
				{
					p.SetState(1820)
					p.Join_condition()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1826)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnnest_operatorContext is an interface to support dynamic dispatch.
type IUnnest_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNNEST_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	AllAs_alias() []IAs_aliasContext
	As_alias(i int) IAs_aliasContext
	WITH_SYMBOL() antlr.TerminalNode
	OFFSET_SYMBOL() antlr.TerminalNode

	// IsUnnest_operatorContext differentiates from other interfaces.
	IsUnnest_operatorContext()
}

type Unnest_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnnest_operatorContext() *Unnest_operatorContext {
	var p = new(Unnest_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_unnest_operator
	return p
}

func InitEmptyUnnest_operatorContext(p *Unnest_operatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_unnest_operator
}

func (*Unnest_operatorContext) IsUnnest_operatorContext() {}

func NewUnnest_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unnest_operatorContext {
	var p = new(Unnest_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_unnest_operator

	return p
}

func (s *Unnest_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Unnest_operatorContext) UNNEST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserUNNEST_SYMBOL, 0)
}

func (s *Unnest_operatorContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Unnest_operatorContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Unnest_operatorContext) AllAs_alias() []IAs_aliasContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAs_aliasContext); ok {
			len++
		}
	}

	tst := make([]IAs_aliasContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAs_aliasContext); ok {
			tst[i] = t.(IAs_aliasContext)
			i++
		}
	}

	return tst
}

func (s *Unnest_operatorContext) As_alias(i int) IAs_aliasContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAs_aliasContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAs_aliasContext)
}

func (s *Unnest_operatorContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWITH_SYMBOL, 0)
}

func (s *Unnest_operatorContext) OFFSET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserOFFSET_SYMBOL, 0)
}

func (s *Unnest_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unnest_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Unnest_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterUnnest_operator(s)
	}
}

func (s *Unnest_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitUnnest_operator(s)
	}
}

func (s *Unnest_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitUnnest_operator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Unnest_operator() (localctx IUnnest_operatorContext) {
	localctx = NewUnnest_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, GoogleSQLParserRULE_unnest_operator)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1834)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserUNNEST_SYMBOL:
		{
			p.SetState(1827)
			p.Match(GoogleSQLParserUNNEST_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1828)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1829)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1831)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1830)
				p.As_alias()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case GoogleSQLParserAS_SYMBOL, GoogleSQLParserQUOTED_ID, GoogleSQLParserID:
		{
			p.SetState(1833)
			p.As_alias()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1841)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1836)
			p.Match(GoogleSQLParserWITH_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1837)
			p.Match(GoogleSQLParserOFFSET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1839)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1838)
				p.As_alias()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICross_join_operatorContext is an interface to support dynamic dispatch.
type ICross_join_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CROSS_SYMBOL() antlr.TerminalNode
	JOIN_SYMBOL() antlr.TerminalNode
	COMMA_SYMBOL() antlr.TerminalNode

	// IsCross_join_operatorContext differentiates from other interfaces.
	IsCross_join_operatorContext()
}

type Cross_join_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCross_join_operatorContext() *Cross_join_operatorContext {
	var p = new(Cross_join_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_cross_join_operator
	return p
}

func InitEmptyCross_join_operatorContext(p *Cross_join_operatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_cross_join_operator
}

func (*Cross_join_operatorContext) IsCross_join_operatorContext() {}

func NewCross_join_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cross_join_operatorContext {
	var p = new(Cross_join_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_cross_join_operator

	return p
}

func (s *Cross_join_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Cross_join_operatorContext) CROSS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCROSS_SYMBOL, 0)
}

func (s *Cross_join_operatorContext) JOIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserJOIN_SYMBOL, 0)
}

func (s *Cross_join_operatorContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, 0)
}

func (s *Cross_join_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cross_join_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Cross_join_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterCross_join_operator(s)
	}
}

func (s *Cross_join_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitCross_join_operator(s)
	}
}

func (s *Cross_join_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitCross_join_operator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Cross_join_operator() (localctx ICross_join_operatorContext) {
	localctx = NewCross_join_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, GoogleSQLParserRULE_cross_join_operator)
	p.SetState(1846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserCROSS_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1843)
			p.Match(GoogleSQLParserCROSS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1844)
			p.Match(GoogleSQLParserJOIN_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	case GoogleSQLParserCOMMA_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1845)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IConditional_join_operatorContext is an interface to support dynamic dispatch.
type IConditional_join_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JOIN_SYMBOL() antlr.TerminalNode
	INNER_SYMBOL() antlr.TerminalNode
	FULL_SYMBOL() antlr.TerminalNode
	OUTER_SYMBOL() antlr.TerminalNode
	LEFT_SYMBOL() antlr.TerminalNode
	RIGHT_SYMBOL() antlr.TerminalNode

	// IsConditional_join_operatorContext differentiates from other interfaces.
	IsConditional_join_operatorContext()
}

type Conditional_join_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_join_operatorContext() *Conditional_join_operatorContext {
	var p = new(Conditional_join_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_conditional_join_operator
	return p
}

func InitEmptyConditional_join_operatorContext(p *Conditional_join_operatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_conditional_join_operator
}

func (*Conditional_join_operatorContext) IsConditional_join_operatorContext() {}

func NewConditional_join_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_join_operatorContext {
	var p = new(Conditional_join_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_conditional_join_operator

	return p
}

func (s *Conditional_join_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_join_operatorContext) JOIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserJOIN_SYMBOL, 0)
}

func (s *Conditional_join_operatorContext) INNER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINNER_SYMBOL, 0)
}

func (s *Conditional_join_operatorContext) FULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFULL_SYMBOL, 0)
}

func (s *Conditional_join_operatorContext) OUTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserOUTER_SYMBOL, 0)
}

func (s *Conditional_join_operatorContext) LEFT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLEFT_SYMBOL, 0)
}

func (s *Conditional_join_operatorContext) RIGHT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRIGHT_SYMBOL, 0)
}

func (s *Conditional_join_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_join_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Conditional_join_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterConditional_join_operator(s)
	}
}

func (s *Conditional_join_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitConditional_join_operator(s)
	}
}

func (s *Conditional_join_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitConditional_join_operator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Conditional_join_operator() (localctx IConditional_join_operatorContext) {
	localctx = NewConditional_join_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, GoogleSQLParserRULE_conditional_join_operator)
	var _la int

	p.SetState(1867)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserJOIN_SYMBOL, GoogleSQLParserINNER_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1849)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserINNER_SYMBOL {
			{
				p.SetState(1848)
				p.Match(GoogleSQLParserINNER_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1851)
			p.Match(GoogleSQLParserJOIN_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case GoogleSQLParserFULL_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1852)
			p.Match(GoogleSQLParserFULL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1854)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserOUTER_SYMBOL {
			{
				p.SetState(1853)
				p.Match(GoogleSQLParserOUTER_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1856)
			p.Match(GoogleSQLParserJOIN_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case GoogleSQLParserLEFT_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1857)
			p.Match(GoogleSQLParserLEFT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1859)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserOUTER_SYMBOL {
			{
				p.SetState(1858)
				p.Match(GoogleSQLParserOUTER_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1861)
			p.Match(GoogleSQLParserJOIN_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case GoogleSQLParserRIGHT_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1862)
			p.Match(GoogleSQLParserRIGHT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1864)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserOUTER_SYMBOL {
			{
				p.SetState(1863)
				p.Match(GoogleSQLParserOUTER_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1866)
			p.Match(GoogleSQLParserJOIN_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJoin_conditionContext is an interface to support dynamic dispatch.
type IJoin_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	On_clause() IOn_clauseContext
	Using_clause() IUsing_clauseContext

	// IsJoin_conditionContext differentiates from other interfaces.
	IsJoin_conditionContext()
}

type Join_conditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_conditionContext() *Join_conditionContext {
	var p = new(Join_conditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_join_condition
	return p
}

func InitEmptyJoin_conditionContext(p *Join_conditionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_join_condition
}

func (*Join_conditionContext) IsJoin_conditionContext() {}

func NewJoin_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_conditionContext {
	var p = new(Join_conditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_join_condition

	return p
}

func (s *Join_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_conditionContext) On_clause() IOn_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOn_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOn_clauseContext)
}

func (s *Join_conditionContext) Using_clause() IUsing_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsing_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsing_clauseContext)
}

func (s *Join_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Join_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterJoin_condition(s)
	}
}

func (s *Join_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitJoin_condition(s)
	}
}

func (s *Join_conditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitJoin_condition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Join_condition() (localctx IJoin_conditionContext) {
	localctx = NewJoin_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, GoogleSQLParserRULE_join_condition)
	p.SetState(1871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserON_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1869)
			p.On_clause()
		}


	case GoogleSQLParserUSING_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1870)
			p.Using_clause()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOn_clauseContext is an interface to support dynamic dispatch.
type IOn_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsOn_clauseContext differentiates from other interfaces.
	IsOn_clauseContext()
}

type On_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOn_clauseContext() *On_clauseContext {
	var p = new(On_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_on_clause
	return p
}

func InitEmptyOn_clauseContext(p *On_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_on_clause
}

func (*On_clauseContext) IsOn_clauseContext() {}

func NewOn_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *On_clauseContext {
	var p = new(On_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_on_clause

	return p
}

func (s *On_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *On_clauseContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserON_SYMBOL, 0)
}

func (s *On_clauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *On_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *On_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *On_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOn_clause(s)
	}
}

func (s *On_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOn_clause(s)
	}
}

func (s *On_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOn_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) On_clause() (localctx IOn_clauseContext) {
	localctx = NewOn_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, GoogleSQLParserRULE_on_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1873)
		p.Match(GoogleSQLParserON_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1874)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUsing_clauseContext is an interface to support dynamic dispatch.
type IUsing_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USING_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Column_name_list() IColumn_name_listContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsUsing_clauseContext differentiates from other interfaces.
	IsUsing_clauseContext()
}

type Using_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsing_clauseContext() *Using_clauseContext {
	var p = new(Using_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_using_clause
	return p
}

func InitEmptyUsing_clauseContext(p *Using_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_using_clause
}

func (*Using_clauseContext) IsUsing_clauseContext() {}

func NewUsing_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Using_clauseContext {
	var p = new(Using_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_using_clause

	return p
}

func (s *Using_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Using_clauseContext) USING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserUSING_SYMBOL, 0)
}

func (s *Using_clauseContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Using_clauseContext) Column_name_list() IColumn_name_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_name_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_name_listContext)
}

func (s *Using_clauseContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Using_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Using_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Using_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterUsing_clause(s)
	}
}

func (s *Using_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitUsing_clause(s)
	}
}

func (s *Using_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitUsing_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Using_clause() (localctx IUsing_clauseContext) {
	localctx = NewUsing_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, GoogleSQLParserRULE_using_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1876)
		p.Match(GoogleSQLParserUSING_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1877)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1878)
		p.Column_name_list()
	}
	{
		p.SetState(1879)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_listContext is an interface to support dynamic dispatch.
type ISelect_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelect_list_item() []ISelect_list_itemContext
	Select_list_item(i int) ISelect_list_itemContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsSelect_listContext differentiates from other interfaces.
	IsSelect_listContext()
}

type Select_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_listContext() *Select_listContext {
	var p = new(Select_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select_list
	return p
}

func InitEmptySelect_listContext(p *Select_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select_list
}

func (*Select_listContext) IsSelect_listContext() {}

func NewSelect_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_listContext {
	var p = new(Select_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_select_list

	return p
}

func (s *Select_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_listContext) AllSelect_list_item() []ISelect_list_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelect_list_itemContext); ok {
			len++
		}
	}

	tst := make([]ISelect_list_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelect_list_itemContext); ok {
			tst[i] = t.(ISelect_list_itemContext)
			i++
		}
	}

	return tst
}

func (s *Select_listContext) Select_list_item(i int) ISelect_list_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_list_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_list_itemContext)
}

func (s *Select_listContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Select_listContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Select_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSelect_list(s)
	}
}

func (s *Select_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSelect_list(s)
	}
}

func (s *Select_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSelect_list(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Select_list() (localctx ISelect_listContext) {
	localctx = NewSelect_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, GoogleSQLParserRULE_select_list)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1881)
		p.Select_list_item()
	}
	p.SetState(1886)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 189, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1882)
				p.Match(GoogleSQLParserCOMMA_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1883)
				p.Select_list_item()
			}


		}
		p.SetState(1888)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 189, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_list_itemContext is an interface to support dynamic dispatch.
type ISelect_list_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_all() ISelect_allContext
	Select_expression() ISelect_expressionContext

	// IsSelect_list_itemContext differentiates from other interfaces.
	IsSelect_list_itemContext()
}

type Select_list_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_list_itemContext() *Select_list_itemContext {
	var p = new(Select_list_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select_list_item
	return p
}

func InitEmptySelect_list_itemContext(p *Select_list_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select_list_item
}

func (*Select_list_itemContext) IsSelect_list_itemContext() {}

func NewSelect_list_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_list_itemContext {
	var p = new(Select_list_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_select_list_item

	return p
}

func (s *Select_list_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_list_itemContext) Select_all() ISelect_allContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_allContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_allContext)
}

func (s *Select_list_itemContext) Select_expression() ISelect_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_expressionContext)
}

func (s *Select_list_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_list_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_list_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSelect_list_item(s)
	}
}

func (s *Select_list_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSelect_list_item(s)
	}
}

func (s *Select_list_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSelect_list_item(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Select_list_item() (localctx ISelect_list_itemContext) {
	localctx = NewSelect_list_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, GoogleSQLParserRULE_select_list_item)
	p.SetState(1891)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 190, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1889)
			p.Select_all()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1890)
			p.Select_expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_expressionContext is an interface to support dynamic dispatch.
type ISelect_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	As_alias() IAs_aliasContext

	// IsSelect_expressionContext differentiates from other interfaces.
	IsSelect_expressionContext()
}

type Select_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_expressionContext() *Select_expressionContext {
	var p = new(Select_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select_expression
	return p
}

func InitEmptySelect_expressionContext(p *Select_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select_expression
}

func (*Select_expressionContext) IsSelect_expressionContext() {}

func NewSelect_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_expressionContext {
	var p = new(Select_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_select_expression

	return p
}

func (s *Select_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_expressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Select_expressionContext) As_alias() IAs_aliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAs_aliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAs_aliasContext)
}

func (s *Select_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSelect_expression(s)
	}
}

func (s *Select_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSelect_expression(s)
	}
}

func (s *Select_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSelect_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Select_expression() (localctx ISelect_expressionContext) {
	localctx = NewSelect_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, GoogleSQLParserRULE_select_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1893)
		p.expression(0)
	}
	p.SetState(1895)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1894)
			p.As_alias()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_allContext is an interface to support dynamic dispatch.
type ISelect_allContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASTERISK_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext
	DOT_SYMBOL() antlr.TerminalNode
	Select_all_except_clause() ISelect_all_except_clauseContext
	Select_all_replace_clause() ISelect_all_replace_clauseContext

	// IsSelect_allContext differentiates from other interfaces.
	IsSelect_allContext()
}

type Select_allContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_allContext() *Select_allContext {
	var p = new(Select_allContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select_all
	return p
}

func InitEmptySelect_allContext(p *Select_allContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select_all
}

func (*Select_allContext) IsSelect_allContext() {}

func NewSelect_allContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_allContext {
	var p = new(Select_allContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_select_all

	return p
}

func (s *Select_allContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_allContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserASTERISK_SYMBOL, 0)
}

func (s *Select_allContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Select_allContext) DOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDOT_SYMBOL, 0)
}

func (s *Select_allContext) Select_all_except_clause() ISelect_all_except_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_all_except_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_all_except_clauseContext)
}

func (s *Select_allContext) Select_all_replace_clause() ISelect_all_replace_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_all_replace_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_all_replace_clauseContext)
}

func (s *Select_allContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_allContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_allContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSelect_all(s)
	}
}

func (s *Select_allContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSelect_all(s)
	}
}

func (s *Select_allContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSelect_all(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Select_all() (localctx ISelect_allContext) {
	localctx = NewSelect_allContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, GoogleSQLParserRULE_select_all)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1900)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 192, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1897)
			p.expression(0)
		}
		{
			p.SetState(1898)
			p.Match(GoogleSQLParserDOT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(1902)
		p.Match(GoogleSQLParserASTERISK_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1904)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1903)
			p.Select_all_except_clause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(1907)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 194, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1906)
			p.Select_all_replace_clause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_all_except_clauseContext is an interface to support dynamic dispatch.
type ISelect_all_except_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCEPT_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Column_name_list() IColumn_name_listContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsSelect_all_except_clauseContext differentiates from other interfaces.
	IsSelect_all_except_clauseContext()
}

type Select_all_except_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_all_except_clauseContext() *Select_all_except_clauseContext {
	var p = new(Select_all_except_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select_all_except_clause
	return p
}

func InitEmptySelect_all_except_clauseContext(p *Select_all_except_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select_all_except_clause
}

func (*Select_all_except_clauseContext) IsSelect_all_except_clauseContext() {}

func NewSelect_all_except_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_all_except_clauseContext {
	var p = new(Select_all_except_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_select_all_except_clause

	return p
}

func (s *Select_all_except_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_all_except_clauseContext) EXCEPT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEXCEPT_SYMBOL, 0)
}

func (s *Select_all_except_clauseContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Select_all_except_clauseContext) Column_name_list() IColumn_name_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_name_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_name_listContext)
}

func (s *Select_all_except_clauseContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Select_all_except_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_all_except_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_all_except_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSelect_all_except_clause(s)
	}
}

func (s *Select_all_except_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSelect_all_except_clause(s)
	}
}

func (s *Select_all_except_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSelect_all_except_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Select_all_except_clause() (localctx ISelect_all_except_clauseContext) {
	localctx = NewSelect_all_except_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, GoogleSQLParserRULE_select_all_except_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1909)
		p.Match(GoogleSQLParserEXCEPT_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1910)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1911)
		p.Column_name_list()
	}
	{
		p.SetState(1912)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_all_replace_clauseContext is an interface to support dynamic dispatch.
type ISelect_all_replace_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Expr_as_alias_list() IExpr_as_alias_listContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsSelect_all_replace_clauseContext differentiates from other interfaces.
	IsSelect_all_replace_clauseContext()
}

type Select_all_replace_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_all_replace_clauseContext() *Select_all_replace_clauseContext {
	var p = new(Select_all_replace_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select_all_replace_clause
	return p
}

func InitEmptySelect_all_replace_clauseContext(p *Select_all_replace_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_select_all_replace_clause
}

func (*Select_all_replace_clauseContext) IsSelect_all_replace_clauseContext() {}

func NewSelect_all_replace_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_all_replace_clauseContext {
	var p = new(Select_all_replace_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_select_all_replace_clause

	return p
}

func (s *Select_all_replace_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_all_replace_clauseContext) REPLACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserREPLACE_SYMBOL, 0)
}

func (s *Select_all_replace_clauseContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Select_all_replace_clauseContext) Expr_as_alias_list() IExpr_as_alias_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_as_alias_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_as_alias_listContext)
}

func (s *Select_all_replace_clauseContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Select_all_replace_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_all_replace_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_all_replace_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSelect_all_replace_clause(s)
	}
}

func (s *Select_all_replace_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSelect_all_replace_clause(s)
	}
}

func (s *Select_all_replace_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSelect_all_replace_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Select_all_replace_clause() (localctx ISelect_all_replace_clauseContext) {
	localctx = NewSelect_all_replace_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, GoogleSQLParserRULE_select_all_replace_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1914)
		p.Match(GoogleSQLParserREPLACE_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1915)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1916)
		p.Expr_as_alias_list()
	}
	{
		p.SetState(1917)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumn_name_listContext is an interface to support dynamic dispatch.
type IColumn_name_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumn_name() []IColumn_nameContext
	Column_name(i int) IColumn_nameContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsColumn_name_listContext differentiates from other interfaces.
	IsColumn_name_listContext()
}

type Column_name_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_name_listContext() *Column_name_listContext {
	var p = new(Column_name_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_column_name_list
	return p
}

func InitEmptyColumn_name_listContext(p *Column_name_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_column_name_list
}

func (*Column_name_listContext) IsColumn_name_listContext() {}

func NewColumn_name_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_name_listContext {
	var p = new(Column_name_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_column_name_list

	return p
}

func (s *Column_name_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_name_listContext) AllColumn_name() []IColumn_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumn_nameContext); ok {
			len++
		}
	}

	tst := make([]IColumn_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumn_nameContext); ok {
			tst[i] = t.(IColumn_nameContext)
			i++
		}
	}

	return tst
}

func (s *Column_name_listContext) Column_name(i int) IColumn_nameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Column_name_listContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Column_name_listContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Column_name_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_name_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Column_name_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterColumn_name_list(s)
	}
}

func (s *Column_name_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitColumn_name_list(s)
	}
}

func (s *Column_name_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitColumn_name_list(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Column_name_list() (localctx IColumn_name_listContext) {
	localctx = NewColumn_name_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, GoogleSQLParserRULE_column_name_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1919)
		p.Column_name()
	}
	p.SetState(1924)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(1920)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1921)
			p.Column_name()
		}


		p.SetState(1926)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_as_alias_listContext is an interface to support dynamic dispatch.
type IExpr_as_alias_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr_as_alias_item() []IExpr_as_alias_itemContext
	Expr_as_alias_item(i int) IExpr_as_alias_itemContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsExpr_as_alias_listContext differentiates from other interfaces.
	IsExpr_as_alias_listContext()
}

type Expr_as_alias_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_as_alias_listContext() *Expr_as_alias_listContext {
	var p = new(Expr_as_alias_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_expr_as_alias_list
	return p
}

func InitEmptyExpr_as_alias_listContext(p *Expr_as_alias_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_expr_as_alias_list
}

func (*Expr_as_alias_listContext) IsExpr_as_alias_listContext() {}

func NewExpr_as_alias_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_as_alias_listContext {
	var p = new(Expr_as_alias_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_expr_as_alias_list

	return p
}

func (s *Expr_as_alias_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_as_alias_listContext) AllExpr_as_alias_item() []IExpr_as_alias_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpr_as_alias_itemContext); ok {
			len++
		}
	}

	tst := make([]IExpr_as_alias_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpr_as_alias_itemContext); ok {
			tst[i] = t.(IExpr_as_alias_itemContext)
			i++
		}
	}

	return tst
}

func (s *Expr_as_alias_listContext) Expr_as_alias_item(i int) IExpr_as_alias_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_as_alias_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_as_alias_itemContext)
}

func (s *Expr_as_alias_listContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Expr_as_alias_listContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Expr_as_alias_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_as_alias_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_as_alias_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterExpr_as_alias_list(s)
	}
}

func (s *Expr_as_alias_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitExpr_as_alias_list(s)
	}
}

func (s *Expr_as_alias_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitExpr_as_alias_list(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Expr_as_alias_list() (localctx IExpr_as_alias_listContext) {
	localctx = NewExpr_as_alias_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, GoogleSQLParserRULE_expr_as_alias_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1927)
		p.Expr_as_alias_item()
	}
	p.SetState(1932)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(1928)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1929)
			p.Expr_as_alias_item()
		}


		p.SetState(1934)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_as_alias_itemContext is an interface to support dynamic dispatch.
type IExpr_as_alias_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Column_name() IColumn_nameContext
	AS_SYMBOL() antlr.TerminalNode

	// IsExpr_as_alias_itemContext differentiates from other interfaces.
	IsExpr_as_alias_itemContext()
}

type Expr_as_alias_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_as_alias_itemContext() *Expr_as_alias_itemContext {
	var p = new(Expr_as_alias_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_expr_as_alias_item
	return p
}

func InitEmptyExpr_as_alias_itemContext(p *Expr_as_alias_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_expr_as_alias_item
}

func (*Expr_as_alias_itemContext) IsExpr_as_alias_itemContext() {}

func NewExpr_as_alias_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_as_alias_itemContext {
	var p = new(Expr_as_alias_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_expr_as_alias_item

	return p
}

func (s *Expr_as_alias_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_as_alias_itemContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expr_as_alias_itemContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Expr_as_alias_itemContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAS_SYMBOL, 0)
}

func (s *Expr_as_alias_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_as_alias_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_as_alias_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterExpr_as_alias_item(s)
	}
}

func (s *Expr_as_alias_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitExpr_as_alias_item(s)
	}
}

func (s *Expr_as_alias_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitExpr_as_alias_item(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Expr_as_alias_item() (localctx IExpr_as_alias_itemContext) {
	localctx = NewExpr_as_alias_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, GoogleSQLParserRULE_expr_as_alias_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1935)
		p.expression(0)
	}
	p.SetState(1937)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserAS_SYMBOL {
		{
			p.SetState(1936)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1939)
		p.Column_name()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAs_aliasContext is an interface to support dynamic dispatch.
type IAs_aliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alias_name() IAlias_nameContext
	AS_SYMBOL() antlr.TerminalNode

	// IsAs_aliasContext differentiates from other interfaces.
	IsAs_aliasContext()
}

type As_aliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAs_aliasContext() *As_aliasContext {
	var p = new(As_aliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_as_alias
	return p
}

func InitEmptyAs_aliasContext(p *As_aliasContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_as_alias
}

func (*As_aliasContext) IsAs_aliasContext() {}

func NewAs_aliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *As_aliasContext {
	var p = new(As_aliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_as_alias

	return p
}

func (s *As_aliasContext) GetParser() antlr.Parser { return s.parser }

func (s *As_aliasContext) Alias_name() IAlias_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlias_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlias_nameContext)
}

func (s *As_aliasContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAS_SYMBOL, 0)
}

func (s *As_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *As_aliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *As_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterAs_alias(s)
	}
}

func (s *As_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitAs_alias(s)
	}
}

func (s *As_aliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitAs_alias(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) As_alias() (localctx IAs_aliasContext) {
	localctx = NewAs_aliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, GoogleSQLParserRULE_as_alias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1942)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserAS_SYMBOL {
		{
			p.SetState(1941)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1944)
		p.Alias_name()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDifferential_privacy_clauseContext is an interface to support dynamic dispatch.
type IDifferential_privacy_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	DIFFERENTIAL_PRIVACY_SYMBOL() antlr.TerminalNode
	OPTIONS_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Privacy_parameters() IPrivacy_parametersContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsDifferential_privacy_clauseContext differentiates from other interfaces.
	IsDifferential_privacy_clauseContext()
}

type Differential_privacy_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDifferential_privacy_clauseContext() *Differential_privacy_clauseContext {
	var p = new(Differential_privacy_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_differential_privacy_clause
	return p
}

func InitEmptyDifferential_privacy_clauseContext(p *Differential_privacy_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_differential_privacy_clause
}

func (*Differential_privacy_clauseContext) IsDifferential_privacy_clauseContext() {}

func NewDifferential_privacy_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Differential_privacy_clauseContext {
	var p = new(Differential_privacy_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_differential_privacy_clause

	return p
}

func (s *Differential_privacy_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Differential_privacy_clauseContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWITH_SYMBOL, 0)
}

func (s *Differential_privacy_clauseContext) DIFFERENTIAL_PRIVACY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDIFFERENTIAL_PRIVACY_SYMBOL, 0)
}

func (s *Differential_privacy_clauseContext) OPTIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserOPTIONS_SYMBOL, 0)
}

func (s *Differential_privacy_clauseContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Differential_privacy_clauseContext) Privacy_parameters() IPrivacy_parametersContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivacy_parametersContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivacy_parametersContext)
}

func (s *Differential_privacy_clauseContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Differential_privacy_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Differential_privacy_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Differential_privacy_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterDifferential_privacy_clause(s)
	}
}

func (s *Differential_privacy_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitDifferential_privacy_clause(s)
	}
}

func (s *Differential_privacy_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitDifferential_privacy_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Differential_privacy_clause() (localctx IDifferential_privacy_clauseContext) {
	localctx = NewDifferential_privacy_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, GoogleSQLParserRULE_differential_privacy_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1946)
		p.Match(GoogleSQLParserWITH_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1947)
		p.Match(GoogleSQLParserDIFFERENTIAL_PRIVACY_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1948)
		p.Match(GoogleSQLParserOPTIONS_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1949)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1950)
		p.Privacy_parameters()
	}
	{
		p.SetState(1951)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrivacy_parametersContext is an interface to support dynamic dispatch.
type IPrivacy_parametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EPSILON_SYMBOL() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	DELTA_SYMBOL() antlr.TerminalNode
	PRIVACY_UNIT_COLUMN_SYMBOL() antlr.TerminalNode
	MAX_GROUPS_CONTRIBUTED_SYMBOL() antlr.TerminalNode

	// IsPrivacy_parametersContext differentiates from other interfaces.
	IsPrivacy_parametersContext()
}

type Privacy_parametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivacy_parametersContext() *Privacy_parametersContext {
	var p = new(Privacy_parametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_privacy_parameters
	return p
}

func InitEmptyPrivacy_parametersContext(p *Privacy_parametersContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_privacy_parameters
}

func (*Privacy_parametersContext) IsPrivacy_parametersContext() {}

func NewPrivacy_parametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Privacy_parametersContext {
	var p = new(Privacy_parametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_privacy_parameters

	return p
}

func (s *Privacy_parametersContext) GetParser() antlr.Parser { return s.parser }

func (s *Privacy_parametersContext) EPSILON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEPSILON_SYMBOL, 0)
}

func (s *Privacy_parametersContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserEQUAL_SYMBOL)
}

func (s *Privacy_parametersContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEQUAL_SYMBOL, i)
}

func (s *Privacy_parametersContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Privacy_parametersContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Privacy_parametersContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Privacy_parametersContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Privacy_parametersContext) DELTA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDELTA_SYMBOL, 0)
}

func (s *Privacy_parametersContext) PRIVACY_UNIT_COLUMN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPRIVACY_UNIT_COLUMN_SYMBOL, 0)
}

func (s *Privacy_parametersContext) MAX_GROUPS_CONTRIBUTED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMAX_GROUPS_CONTRIBUTED_SYMBOL, 0)
}

func (s *Privacy_parametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Privacy_parametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Privacy_parametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterPrivacy_parameters(s)
	}
}

func (s *Privacy_parametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitPrivacy_parameters(s)
	}
}

func (s *Privacy_parametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitPrivacy_parameters(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Privacy_parameters() (localctx IPrivacy_parametersContext) {
	localctx = NewPrivacy_parametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, GoogleSQLParserRULE_privacy_parameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1953)
		p.Match(GoogleSQLParserEPSILON_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1954)
		p.Match(GoogleSQLParserEQUAL_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1955)
		p.expression(0)
	}
	{
		p.SetState(1956)
		p.Match(GoogleSQLParserCOMMA_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1957)
		p.Match(GoogleSQLParserDELTA_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1958)
		p.Match(GoogleSQLParserEQUAL_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1959)
		p.expression(0)
	}
	{
		p.SetState(1960)
		p.Match(GoogleSQLParserCOMMA_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1966)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserMAX_GROUPS_CONTRIBUTED_SYMBOL {
		{
			p.SetState(1961)
			p.Match(GoogleSQLParserMAX_GROUPS_CONTRIBUTED_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1962)
			p.Match(GoogleSQLParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1963)
			p.expression(0)
		}
		{
			p.SetState(1964)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1968)
		p.Match(GoogleSQLParserPRIVACY_UNIT_COLUMN_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1969)
		p.Match(GoogleSQLParserEQUAL_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1970)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWith_statementContext is an interface to support dynamic dispatch.
type IWith_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	AllCte() []ICteContext
	Cte(i int) ICteContext
	RECURSIVE_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsWith_statementContext differentiates from other interfaces.
	IsWith_statementContext()
}

type With_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_statementContext() *With_statementContext {
	var p = new(With_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_with_statement
	return p
}

func InitEmptyWith_statementContext(p *With_statementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_with_statement
}

func (*With_statementContext) IsWith_statementContext() {}

func NewWith_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_statementContext {
	var p = new(With_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_with_statement

	return p
}

func (s *With_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *With_statementContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWITH_SYMBOL, 0)
}

func (s *With_statementContext) AllCte() []ICteContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICteContext); ok {
			len++
		}
	}

	tst := make([]ICteContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICteContext); ok {
			tst[i] = t.(ICteContext)
			i++
		}
	}

	return tst
}

func (s *With_statementContext) Cte(i int) ICteContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteContext)
}

func (s *With_statementContext) RECURSIVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRECURSIVE_SYMBOL, 0)
}

func (s *With_statementContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *With_statementContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *With_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *With_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterWith_statement(s)
	}
}

func (s *With_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitWith_statement(s)
	}
}

func (s *With_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitWith_statement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) With_statement() (localctx IWith_statementContext) {
	localctx = NewWith_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, GoogleSQLParserRULE_with_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1972)
		p.Match(GoogleSQLParserWITH_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserRECURSIVE_SYMBOL {
		{
			p.SetState(1973)
			p.Match(GoogleSQLParserRECURSIVE_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1976)
		p.Cte()
	}
	p.SetState(1981)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(1977)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1978)
			p.Cte()
		}


		p.SetState(1983)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICteContext is an interface to support dynamic dispatch.
type ICteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Non_recursive_cte() INon_recursive_cteContext
	Recursive_cte() IRecursive_cteContext

	// IsCteContext differentiates from other interfaces.
	IsCteContext()
}

type CteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCteContext() *CteContext {
	var p = new(CteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_cte
	return p
}

func InitEmptyCteContext(p *CteContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_cte
}

func (*CteContext) IsCteContext() {}

func NewCteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CteContext {
	var p = new(CteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_cte

	return p
}

func (s *CteContext) GetParser() antlr.Parser { return s.parser }

func (s *CteContext) Non_recursive_cte() INon_recursive_cteContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INon_recursive_cteContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INon_recursive_cteContext)
}

func (s *CteContext) Recursive_cte() IRecursive_cteContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecursive_cteContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecursive_cteContext)
}

func (s *CteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterCte(s)
	}
}

func (s *CteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitCte(s)
	}
}

func (s *CteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitCte(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Cte() (localctx ICteContext) {
	localctx = NewCteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, GoogleSQLParserRULE_cte)
	p.SetState(1986)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 202, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1984)
			p.Non_recursive_cte()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1985)
			p.Recursive_cte()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INon_recursive_cteContext is an interface to support dynamic dispatch.
type INon_recursive_cteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Cte_name() ICte_nameContext
	AS_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Query() IQueryContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsNon_recursive_cteContext differentiates from other interfaces.
	IsNon_recursive_cteContext()
}

type Non_recursive_cteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNon_recursive_cteContext() *Non_recursive_cteContext {
	var p = new(Non_recursive_cteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_non_recursive_cte
	return p
}

func InitEmptyNon_recursive_cteContext(p *Non_recursive_cteContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_non_recursive_cte
}

func (*Non_recursive_cteContext) IsNon_recursive_cteContext() {}

func NewNon_recursive_cteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Non_recursive_cteContext {
	var p = new(Non_recursive_cteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_non_recursive_cte

	return p
}

func (s *Non_recursive_cteContext) GetParser() antlr.Parser { return s.parser }

func (s *Non_recursive_cteContext) Cte_name() ICte_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICte_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICte_nameContext)
}

func (s *Non_recursive_cteContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAS_SYMBOL, 0)
}

func (s *Non_recursive_cteContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Non_recursive_cteContext) Query() IQueryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *Non_recursive_cteContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Non_recursive_cteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Non_recursive_cteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Non_recursive_cteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterNon_recursive_cte(s)
	}
}

func (s *Non_recursive_cteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitNon_recursive_cte(s)
	}
}

func (s *Non_recursive_cteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitNon_recursive_cte(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Non_recursive_cte() (localctx INon_recursive_cteContext) {
	localctx = NewNon_recursive_cteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, GoogleSQLParserRULE_non_recursive_cte)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1988)
		p.Cte_name()
	}
	{
		p.SetState(1989)
		p.Match(GoogleSQLParserAS_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1990)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1991)
		p.Query()
	}
	{
		p.SetState(1992)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRecursive_cteContext is an interface to support dynamic dispatch.
type IRecursive_cteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Cte_name() ICte_nameContext
	AS_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Recursive_union_operation() IRecursive_union_operationContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsRecursive_cteContext differentiates from other interfaces.
	IsRecursive_cteContext()
}

type Recursive_cteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecursive_cteContext() *Recursive_cteContext {
	var p = new(Recursive_cteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_recursive_cte
	return p
}

func InitEmptyRecursive_cteContext(p *Recursive_cteContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_recursive_cte
}

func (*Recursive_cteContext) IsRecursive_cteContext() {}

func NewRecursive_cteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Recursive_cteContext {
	var p = new(Recursive_cteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_recursive_cte

	return p
}

func (s *Recursive_cteContext) GetParser() antlr.Parser { return s.parser }

func (s *Recursive_cteContext) Cte_name() ICte_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICte_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICte_nameContext)
}

func (s *Recursive_cteContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAS_SYMBOL, 0)
}

func (s *Recursive_cteContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Recursive_cteContext) Recursive_union_operation() IRecursive_union_operationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecursive_union_operationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecursive_union_operationContext)
}

func (s *Recursive_cteContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Recursive_cteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Recursive_cteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Recursive_cteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterRecursive_cte(s)
	}
}

func (s *Recursive_cteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitRecursive_cte(s)
	}
}

func (s *Recursive_cteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitRecursive_cte(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Recursive_cte() (localctx IRecursive_cteContext) {
	localctx = NewRecursive_cteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, GoogleSQLParserRULE_recursive_cte)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1994)
		p.Cte_name()
	}
	{
		p.SetState(1995)
		p.Match(GoogleSQLParserAS_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1996)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1997)
		p.Recursive_union_operation()
	}
	{
		p.SetState(1998)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRecursive_union_operationContext is an interface to support dynamic dispatch.
type IRecursive_union_operationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Base_term() IBase_termContext
	Union_operator() IUnion_operatorContext
	Recursive_term() IRecursive_termContext

	// IsRecursive_union_operationContext differentiates from other interfaces.
	IsRecursive_union_operationContext()
}

type Recursive_union_operationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecursive_union_operationContext() *Recursive_union_operationContext {
	var p = new(Recursive_union_operationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_recursive_union_operation
	return p
}

func InitEmptyRecursive_union_operationContext(p *Recursive_union_operationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_recursive_union_operation
}

func (*Recursive_union_operationContext) IsRecursive_union_operationContext() {}

func NewRecursive_union_operationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Recursive_union_operationContext {
	var p = new(Recursive_union_operationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_recursive_union_operation

	return p
}

func (s *Recursive_union_operationContext) GetParser() antlr.Parser { return s.parser }

func (s *Recursive_union_operationContext) Base_term() IBase_termContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBase_termContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBase_termContext)
}

func (s *Recursive_union_operationContext) Union_operator() IUnion_operatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnion_operatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnion_operatorContext)
}

func (s *Recursive_union_operationContext) Recursive_term() IRecursive_termContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecursive_termContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecursive_termContext)
}

func (s *Recursive_union_operationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Recursive_union_operationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Recursive_union_operationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterRecursive_union_operation(s)
	}
}

func (s *Recursive_union_operationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitRecursive_union_operation(s)
	}
}

func (s *Recursive_union_operationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitRecursive_union_operation(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Recursive_union_operation() (localctx IRecursive_union_operationContext) {
	localctx = NewRecursive_union_operationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, GoogleSQLParserRULE_recursive_union_operation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2000)
		p.Base_term()
	}
	{
		p.SetState(2001)
		p.Union_operator()
	}
	{
		p.SetState(2002)
		p.Recursive_term()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBase_termContext is an interface to support dynamic dispatch.
type IBase_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Query() IQueryContext

	// IsBase_termContext differentiates from other interfaces.
	IsBase_termContext()
}

type Base_termContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBase_termContext() *Base_termContext {
	var p = new(Base_termContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_base_term
	return p
}

func InitEmptyBase_termContext(p *Base_termContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_base_term
}

func (*Base_termContext) IsBase_termContext() {}

func NewBase_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Base_termContext {
	var p = new(Base_termContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_base_term

	return p
}

func (s *Base_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Base_termContext) Query() IQueryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *Base_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Base_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Base_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterBase_term(s)
	}
}

func (s *Base_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitBase_term(s)
	}
}

func (s *Base_termContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitBase_term(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Base_term() (localctx IBase_termContext) {
	localctx = NewBase_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, GoogleSQLParserRULE_base_term)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2004)
		p.Query()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnion_operatorContext is an interface to support dynamic dispatch.
type IUnion_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNION_SYMBOL() antlr.TerminalNode
	ALL_SYMBOL() antlr.TerminalNode

	// IsUnion_operatorContext differentiates from other interfaces.
	IsUnion_operatorContext()
}

type Union_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnion_operatorContext() *Union_operatorContext {
	var p = new(Union_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_union_operator
	return p
}

func InitEmptyUnion_operatorContext(p *Union_operatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_union_operator
}

func (*Union_operatorContext) IsUnion_operatorContext() {}

func NewUnion_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Union_operatorContext {
	var p = new(Union_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_union_operator

	return p
}

func (s *Union_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Union_operatorContext) UNION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserUNION_SYMBOL, 0)
}

func (s *Union_operatorContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserALL_SYMBOL, 0)
}

func (s *Union_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Union_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Union_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterUnion_operator(s)
	}
}

func (s *Union_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitUnion_operator(s)
	}
}

func (s *Union_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitUnion_operator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Union_operator() (localctx IUnion_operatorContext) {
	localctx = NewUnion_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, GoogleSQLParserRULE_union_operator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2006)
		p.Match(GoogleSQLParserUNION_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2007)
		p.Match(GoogleSQLParserALL_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRecursive_termContext is an interface to support dynamic dispatch.
type IRecursive_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Query() IQueryContext

	// IsRecursive_termContext differentiates from other interfaces.
	IsRecursive_termContext()
}

type Recursive_termContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecursive_termContext() *Recursive_termContext {
	var p = new(Recursive_termContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_recursive_term
	return p
}

func InitEmptyRecursive_termContext(p *Recursive_termContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_recursive_term
}

func (*Recursive_termContext) IsRecursive_termContext() {}

func NewRecursive_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Recursive_termContext {
	var p = new(Recursive_termContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_recursive_term

	return p
}

func (s *Recursive_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Recursive_termContext) Query() IQueryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *Recursive_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Recursive_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Recursive_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterRecursive_term(s)
	}
}

func (s *Recursive_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitRecursive_term(s)
	}
}

func (s *Recursive_termContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitRecursive_term(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Recursive_term() (localctx IRecursive_termContext) {
	localctx = NewRecursive_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, GoogleSQLParserRULE_recursive_term)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2009)
		p.Query()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression_higher_prec_than_and() IExpression_higher_prec_than_andContext
	And_expression() IAnd_expressionContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	OR_SYMBOL() antlr.TerminalNode

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Expression_higher_prec_than_and() IExpression_higher_prec_than_andContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpression_higher_prec_than_andContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpression_higher_prec_than_andContext)
}

func (s *ExpressionContext) And_expression() IAnd_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnd_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnd_expressionContext)
}

func (s *ExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) OR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserOR_SYMBOL, 0)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}





func (p *GoogleSQLParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *GoogleSQLParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 314
	p.EnterRecursionRule(localctx, 314, GoogleSQLParserRULE_expression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2014)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2012)
			p.Expression_higher_prec_than_and()
		}


	case 2:
		{
			p.SetState(2013)
			p.And_expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2021)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 204, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewExpressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_expression)
			p.SetState(2016)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(2017)
				p.Match(GoogleSQLParserOR_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2018)
				p.expression(2)
			}


		}
		p.SetState(2023)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 204, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpression_higher_prec_than_andContext is an interface to support dynamic dispatch.
type IExpression_higher_prec_than_andContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Parenthesized_expression_not_a_query() IParenthesized_expression_not_a_queryContext
	Parenthesized_query() IParenthesized_queryContext

	// IsExpression_higher_prec_than_andContext differentiates from other interfaces.
	IsExpression_higher_prec_than_andContext()
}

type Expression_higher_prec_than_andContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_higher_prec_than_andContext() *Expression_higher_prec_than_andContext {
	var p = new(Expression_higher_prec_than_andContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_expression_higher_prec_than_and
	return p
}

func InitEmptyExpression_higher_prec_than_andContext(p *Expression_higher_prec_than_andContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_expression_higher_prec_than_and
}

func (*Expression_higher_prec_than_andContext) IsExpression_higher_prec_than_andContext() {}

func NewExpression_higher_prec_than_andContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_higher_prec_than_andContext {
	var p = new(Expression_higher_prec_than_andContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_expression_higher_prec_than_and

	return p
}

func (s *Expression_higher_prec_than_andContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_higher_prec_than_andContext) Parenthesized_expression_not_a_query() IParenthesized_expression_not_a_queryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesized_expression_not_a_queryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesized_expression_not_a_queryContext)
}

func (s *Expression_higher_prec_than_andContext) Parenthesized_query() IParenthesized_queryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesized_queryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesized_queryContext)
}

func (s *Expression_higher_prec_than_andContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_higher_prec_than_andContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expression_higher_prec_than_andContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterExpression_higher_prec_than_and(s)
	}
}

func (s *Expression_higher_prec_than_andContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitExpression_higher_prec_than_and(s)
	}
}

func (s *Expression_higher_prec_than_andContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitExpression_higher_prec_than_and(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Expression_higher_prec_than_and() (localctx IExpression_higher_prec_than_andContext) {
	localctx = NewExpression_higher_prec_than_andContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, GoogleSQLParserRULE_expression_higher_prec_than_and)
	p.SetState(2027)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2025)
			p.Parenthesized_expression_not_a_query()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2026)
			p.Parenthesized_query()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IParenthesized_queryContext is an interface to support dynamic dispatch.
type IParenthesized_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Query() IQueryContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsParenthesized_queryContext differentiates from other interfaces.
	IsParenthesized_queryContext()
}

type Parenthesized_queryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesized_queryContext() *Parenthesized_queryContext {
	var p = new(Parenthesized_queryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_parenthesized_query
	return p
}

func InitEmptyParenthesized_queryContext(p *Parenthesized_queryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_parenthesized_query
}

func (*Parenthesized_queryContext) IsParenthesized_queryContext() {}

func NewParenthesized_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parenthesized_queryContext {
	var p = new(Parenthesized_queryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_parenthesized_query

	return p
}

func (s *Parenthesized_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Parenthesized_queryContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Parenthesized_queryContext) Query() IQueryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *Parenthesized_queryContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Parenthesized_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthesized_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Parenthesized_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterParenthesized_query(s)
	}
}

func (s *Parenthesized_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitParenthesized_query(s)
	}
}

func (s *Parenthesized_queryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitParenthesized_query(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Parenthesized_query() (localctx IParenthesized_queryContext) {
	localctx = NewParenthesized_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, GoogleSQLParserRULE_parenthesized_query)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2029)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2030)
		p.Query()
	}
	{
		p.SetState(2031)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IParenthesized_expression_not_a_queryContext is an interface to support dynamic dispatch.
type IParenthesized_expression_not_a_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Expression_maybe_parenthesized_not_a_query() IExpression_maybe_parenthesized_not_a_queryContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsParenthesized_expression_not_a_queryContext differentiates from other interfaces.
	IsParenthesized_expression_not_a_queryContext()
}

type Parenthesized_expression_not_a_queryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesized_expression_not_a_queryContext() *Parenthesized_expression_not_a_queryContext {
	var p = new(Parenthesized_expression_not_a_queryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_parenthesized_expression_not_a_query
	return p
}

func InitEmptyParenthesized_expression_not_a_queryContext(p *Parenthesized_expression_not_a_queryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_parenthesized_expression_not_a_query
}

func (*Parenthesized_expression_not_a_queryContext) IsParenthesized_expression_not_a_queryContext() {}

func NewParenthesized_expression_not_a_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parenthesized_expression_not_a_queryContext {
	var p = new(Parenthesized_expression_not_a_queryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_parenthesized_expression_not_a_query

	return p
}

func (s *Parenthesized_expression_not_a_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Parenthesized_expression_not_a_queryContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Parenthesized_expression_not_a_queryContext) Expression_maybe_parenthesized_not_a_query() IExpression_maybe_parenthesized_not_a_queryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpression_maybe_parenthesized_not_a_queryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpression_maybe_parenthesized_not_a_queryContext)
}

func (s *Parenthesized_expression_not_a_queryContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Parenthesized_expression_not_a_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthesized_expression_not_a_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Parenthesized_expression_not_a_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterParenthesized_expression_not_a_query(s)
	}
}

func (s *Parenthesized_expression_not_a_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitParenthesized_expression_not_a_query(s)
	}
}

func (s *Parenthesized_expression_not_a_queryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitParenthesized_expression_not_a_query(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Parenthesized_expression_not_a_query() (localctx IParenthesized_expression_not_a_queryContext) {
	localctx = NewParenthesized_expression_not_a_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, GoogleSQLParserRULE_parenthesized_expression_not_a_query)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2033)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2034)
		p.Expression_maybe_parenthesized_not_a_query()
	}
	{
		p.SetState(2035)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpression_maybe_parenthesized_not_a_queryContext is an interface to support dynamic dispatch.
type IExpression_maybe_parenthesized_not_a_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Parenthesized_expression_not_a_query() IParenthesized_expression_not_a_queryContext
	Unparenthesized_expression_higher_prec_than_and() IUnparenthesized_expression_higher_prec_than_andContext
	And_expression() IAnd_expressionContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	OR_SYMBOL() antlr.TerminalNode

	// IsExpression_maybe_parenthesized_not_a_queryContext differentiates from other interfaces.
	IsExpression_maybe_parenthesized_not_a_queryContext()
}

type Expression_maybe_parenthesized_not_a_queryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_maybe_parenthesized_not_a_queryContext() *Expression_maybe_parenthesized_not_a_queryContext {
	var p = new(Expression_maybe_parenthesized_not_a_queryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_expression_maybe_parenthesized_not_a_query
	return p
}

func InitEmptyExpression_maybe_parenthesized_not_a_queryContext(p *Expression_maybe_parenthesized_not_a_queryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_expression_maybe_parenthesized_not_a_query
}

func (*Expression_maybe_parenthesized_not_a_queryContext) IsExpression_maybe_parenthesized_not_a_queryContext() {}

func NewExpression_maybe_parenthesized_not_a_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_maybe_parenthesized_not_a_queryContext {
	var p = new(Expression_maybe_parenthesized_not_a_queryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_expression_maybe_parenthesized_not_a_query

	return p
}

func (s *Expression_maybe_parenthesized_not_a_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_maybe_parenthesized_not_a_queryContext) Parenthesized_expression_not_a_query() IParenthesized_expression_not_a_queryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesized_expression_not_a_queryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesized_expression_not_a_queryContext)
}

func (s *Expression_maybe_parenthesized_not_a_queryContext) Unparenthesized_expression_higher_prec_than_and() IUnparenthesized_expression_higher_prec_than_andContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnparenthesized_expression_higher_prec_than_andContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnparenthesized_expression_higher_prec_than_andContext)
}

func (s *Expression_maybe_parenthesized_not_a_queryContext) And_expression() IAnd_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnd_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnd_expressionContext)
}

func (s *Expression_maybe_parenthesized_not_a_queryContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Expression_maybe_parenthesized_not_a_queryContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expression_maybe_parenthesized_not_a_queryContext) OR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserOR_SYMBOL, 0)
}

func (s *Expression_maybe_parenthesized_not_a_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_maybe_parenthesized_not_a_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expression_maybe_parenthesized_not_a_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterExpression_maybe_parenthesized_not_a_query(s)
	}
}

func (s *Expression_maybe_parenthesized_not_a_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitExpression_maybe_parenthesized_not_a_query(s)
	}
}

func (s *Expression_maybe_parenthesized_not_a_queryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitExpression_maybe_parenthesized_not_a_query(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Expression_maybe_parenthesized_not_a_query() (localctx IExpression_maybe_parenthesized_not_a_queryContext) {
	localctx = NewExpression_maybe_parenthesized_not_a_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, GoogleSQLParserRULE_expression_maybe_parenthesized_not_a_query)
	p.SetState(2044)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2037)
			p.Parenthesized_expression_not_a_query()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2038)
			p.Unparenthesized_expression_higher_prec_than_and()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2039)
			p.And_expression()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2040)
			p.expression(0)
		}
		{
			p.SetState(2041)
			p.Match(GoogleSQLParserOR_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2042)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAnd_expressionContext is an interface to support dynamic dispatch.
type IAnd_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression_higher_prec_than_and() []IExpression_higher_prec_than_andContext
	Expression_higher_prec_than_and(i int) IExpression_higher_prec_than_andContext
	AllAND_SYMBOL() []antlr.TerminalNode
	AND_SYMBOL(i int) antlr.TerminalNode

	// IsAnd_expressionContext differentiates from other interfaces.
	IsAnd_expressionContext()
}

type And_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_expressionContext() *And_expressionContext {
	var p = new(And_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_and_expression
	return p
}

func InitEmptyAnd_expressionContext(p *And_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_and_expression
}

func (*And_expressionContext) IsAnd_expressionContext() {}

func NewAnd_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_expressionContext {
	var p = new(And_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_and_expression

	return p
}

func (s *And_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *And_expressionContext) AllExpression_higher_prec_than_and() []IExpression_higher_prec_than_andContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpression_higher_prec_than_andContext); ok {
			len++
		}
	}

	tst := make([]IExpression_higher_prec_than_andContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpression_higher_prec_than_andContext); ok {
			tst[i] = t.(IExpression_higher_prec_than_andContext)
			i++
		}
	}

	return tst
}

func (s *And_expressionContext) Expression_higher_prec_than_and(i int) IExpression_higher_prec_than_andContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpression_higher_prec_than_andContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpression_higher_prec_than_andContext)
}

func (s *And_expressionContext) AllAND_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserAND_SYMBOL)
}

func (s *And_expressionContext) AND_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAND_SYMBOL, i)
}

func (s *And_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *And_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterAnd_expression(s)
	}
}

func (s *And_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitAnd_expression(s)
	}
}

func (s *And_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitAnd_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) And_expression() (localctx IAnd_expressionContext) {
	localctx = NewAnd_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, GoogleSQLParserRULE_and_expression)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2046)
		p.Expression_higher_prec_than_and()
	}
	{
		p.SetState(2047)
		p.Match(GoogleSQLParserAND_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2048)
		p.Expression_higher_prec_than_and()
	}
	p.SetState(2053)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2049)
				p.Match(GoogleSQLParserAND_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2050)
				p.Expression_higher_prec_than_and()
			}


		}
		p.SetState(2055)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnparenthesized_expression_higher_prec_than_andContext is an interface to support dynamic dispatch.
type IUnparenthesized_expression_higher_prec_than_andContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Null_literal() INull_literalContext
	Boolean_literal() IBoolean_literalContext
	String_literal() IString_literalContext
	Bytes_literal() IBytes_literalContext
	Integer_literal() IInteger_literalContext
	Numeric_literal() INumeric_literalContext
	Bignumeric_literal() IBignumeric_literalContext
	Json_literal() IJson_literalContext
	Floating_point_literal() IFloating_point_literalContext
	Date_or_time_literal() IDate_or_time_literalContext
	Range_literal() IRange_literalContext
	Parameter_expression() IParameter_expressionContext
	System_variable_expression() ISystem_variable_expressionContext
	Array_constructor() IArray_constructorContext
	New_constructor() INew_constructorContext
	Braced_constructor() IBraced_constructorContext
	Braced_new_constructor() IBraced_new_constructorContext
	Struct_braced_constructor() IStruct_braced_constructorContext
	Case_expression() ICase_expressionContext
	Cast_expression() ICast_expressionContext
	Extract_expression() IExtract_expressionContext
	With_expression() IWith_expressionContext
	Replace_fields_expression() IReplace_fields_expressionContext
	Function_call_expression_with_clauses() IFunction_call_expression_with_clausesContext
	Interval_expression() IInterval_expressionContext
	Identifier() IIdentifierContext
	Struct_constructor() IStruct_constructorContext
	Expression_subquery_with_keyword() IExpression_subquery_with_keywordContext
	AllExpression_higher_prec_than_and() []IExpression_higher_prec_than_andContext
	Expression_higher_prec_than_and(i int) IExpression_higher_prec_than_andContext
	LS_BRACKET_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext
	RS_BRACKET_SYMBOL() antlr.TerminalNode
	DOT_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Path_expression() IPath_expressionContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	NOT_SYMBOL() antlr.TerminalNode
	Like_operator() ILike_operatorContext
	Any_some_all() IAny_some_allContext
	Unnest_expression() IUnnest_expressionContext
	Hint() IHintContext
	Parenthesized_anysomeall_list_in_rhs() IParenthesized_anysomeall_list_in_rhsContext

	// IsUnparenthesized_expression_higher_prec_than_andContext differentiates from other interfaces.
	IsUnparenthesized_expression_higher_prec_than_andContext()
}

type Unparenthesized_expression_higher_prec_than_andContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnparenthesized_expression_higher_prec_than_andContext() *Unparenthesized_expression_higher_prec_than_andContext {
	var p = new(Unparenthesized_expression_higher_prec_than_andContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_unparenthesized_expression_higher_prec_than_and
	return p
}

func InitEmptyUnparenthesized_expression_higher_prec_than_andContext(p *Unparenthesized_expression_higher_prec_than_andContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_unparenthesized_expression_higher_prec_than_and
}

func (*Unparenthesized_expression_higher_prec_than_andContext) IsUnparenthesized_expression_higher_prec_than_andContext() {}

func NewUnparenthesized_expression_higher_prec_than_andContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unparenthesized_expression_higher_prec_than_andContext {
	var p = new(Unparenthesized_expression_higher_prec_than_andContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_unparenthesized_expression_higher_prec_than_and

	return p
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) GetParser() antlr.Parser { return s.parser }

func (s *Unparenthesized_expression_higher_prec_than_andContext) Null_literal() INull_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INull_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INull_literalContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Boolean_literal() IBoolean_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoolean_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoolean_literalContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) String_literal() IString_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_literalContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Bytes_literal() IBytes_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBytes_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBytes_literalContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Integer_literal() IInteger_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInteger_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInteger_literalContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Numeric_literal() INumeric_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumeric_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumeric_literalContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Bignumeric_literal() IBignumeric_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBignumeric_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBignumeric_literalContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Json_literal() IJson_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_literalContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Floating_point_literal() IFloating_point_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloating_point_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloating_point_literalContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Date_or_time_literal() IDate_or_time_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDate_or_time_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDate_or_time_literalContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Range_literal() IRange_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRange_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRange_literalContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Parameter_expression() IParameter_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameter_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameter_expressionContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) System_variable_expression() ISystem_variable_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystem_variable_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystem_variable_expressionContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Array_constructor() IArray_constructorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_constructorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_constructorContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) New_constructor() INew_constructorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INew_constructorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INew_constructorContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Braced_constructor() IBraced_constructorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBraced_constructorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBraced_constructorContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Braced_new_constructor() IBraced_new_constructorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBraced_new_constructorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBraced_new_constructorContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Struct_braced_constructor() IStruct_braced_constructorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_braced_constructorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_braced_constructorContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Case_expression() ICase_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICase_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICase_expressionContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Cast_expression() ICast_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICast_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICast_expressionContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Extract_expression() IExtract_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtract_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtract_expressionContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) With_expression() IWith_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_expressionContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Replace_fields_expression() IReplace_fields_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplace_fields_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplace_fields_expressionContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Function_call_expression_with_clauses() IFunction_call_expression_with_clausesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_call_expression_with_clausesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_call_expression_with_clausesContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Interval_expression() IInterval_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterval_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterval_expressionContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Struct_constructor() IStruct_constructorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_constructorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_constructorContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Expression_subquery_with_keyword() IExpression_subquery_with_keywordContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpression_subquery_with_keywordContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpression_subquery_with_keywordContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) AllExpression_higher_prec_than_and() []IExpression_higher_prec_than_andContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpression_higher_prec_than_andContext); ok {
			len++
		}
	}

	tst := make([]IExpression_higher_prec_than_andContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpression_higher_prec_than_andContext); ok {
			tst[i] = t.(IExpression_higher_prec_than_andContext)
			i++
		}
	}

	return tst
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Expression_higher_prec_than_and(i int) IExpression_higher_prec_than_andContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpression_higher_prec_than_andContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpression_higher_prec_than_andContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) LS_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLS_BRACKET_SYMBOL, 0)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) RS_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRS_BRACKET_SYMBOL, 0)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) DOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDOT_SYMBOL, 0)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Path_expression() IPath_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPath_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPath_expressionContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) NOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserNOT_SYMBOL, 0)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Like_operator() ILike_operatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILike_operatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILike_operatorContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Any_some_all() IAny_some_allContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAny_some_allContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAny_some_allContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Unnest_expression() IUnnest_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnnest_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnnest_expressionContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Hint() IHintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Parenthesized_anysomeall_list_in_rhs() IParenthesized_anysomeall_list_in_rhsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesized_anysomeall_list_in_rhsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesized_anysomeall_list_in_rhsContext)
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Unparenthesized_expression_higher_prec_than_andContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterUnparenthesized_expression_higher_prec_than_and(s)
	}
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitUnparenthesized_expression_higher_prec_than_and(s)
	}
}

func (s *Unparenthesized_expression_higher_prec_than_andContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitUnparenthesized_expression_higher_prec_than_and(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Unparenthesized_expression_higher_prec_than_and() (localctx IUnparenthesized_expression_higher_prec_than_andContext) {
	localctx = NewUnparenthesized_expression_higher_prec_than_andContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, GoogleSQLParserRULE_unparenthesized_expression_higher_prec_than_and)
	var _la int

	p.SetState(2121)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 210, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2056)
			p.Null_literal()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2057)
			p.Boolean_literal()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2058)
			p.string_literal(0)
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2059)
			p.bytes_literal(0)
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2060)
			p.Integer_literal()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2061)
			p.Numeric_literal()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2062)
			p.Bignumeric_literal()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2063)
			p.Json_literal()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2064)
			p.Floating_point_literal()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2065)
			p.Date_or_time_literal()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2066)
			p.Range_literal()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2067)
			p.Parameter_expression()
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2068)
			p.System_variable_expression()
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2069)
			p.Array_constructor()
		}


	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2070)
			p.New_constructor()
		}


	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(2071)
			p.Braced_constructor()
		}


	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(2072)
			p.Braced_new_constructor()
		}


	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(2073)
			p.Struct_braced_constructor()
		}


	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(2074)
			p.Case_expression()
		}


	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(2075)
			p.Cast_expression()
		}


	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(2076)
			p.Extract_expression()
		}


	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(2077)
			p.With_expression()
		}


	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(2078)
			p.Replace_fields_expression()
		}


	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(2079)
			p.Function_call_expression_with_clauses()
		}


	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(2080)
			p.Interval_expression()
		}


	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(2081)
			p.Identifier()
		}


	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(2082)
			p.Struct_constructor()
		}


	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(2083)
			p.Expression_subquery_with_keyword()
		}


	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(2084)
			p.Expression_higher_prec_than_and()
		}
		{
			p.SetState(2085)
			p.Match(GoogleSQLParserLS_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2086)
			p.expression(0)
		}
		{
			p.SetState(2087)
			p.Match(GoogleSQLParserRS_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(2089)
			p.Expression_higher_prec_than_and()
		}
		{
			p.SetState(2090)
			p.Match(GoogleSQLParserDOT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2091)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2092)
			p.path_expression(0)
		}
		{
			p.SetState(2093)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(2095)
			p.Expression_higher_prec_than_and()
		}
		{
			p.SetState(2096)
			p.Match(GoogleSQLParserDOT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2097)
			p.Identifier()
		}


	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(2099)
			p.Match(GoogleSQLParserNOT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2100)
			p.Expression_higher_prec_than_and()
		}


	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(2101)
			p.Expression_higher_prec_than_and()
		}
		{
			p.SetState(2102)
			p.Like_operator()
		}
		{
			p.SetState(2103)
			p.Any_some_all()
		}
		p.SetState(2105)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserAT_SYMBOL {
			{
				p.SetState(2104)
				p.Hint()
			}

		}
		{
			p.SetState(2107)
			p.Unnest_expression()
		}


	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(2109)
			p.Expression_higher_prec_than_and()
		}
		{
			p.SetState(2110)
			p.Like_operator()
		}
		{
			p.SetState(2111)
			p.Any_some_all()
		}
		p.SetState(2113)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserAT_SYMBOL {
			{
				p.SetState(2112)
				p.Hint()
			}

		}
		{
			p.SetState(2115)
			p.Parenthesized_anysomeall_list_in_rhs()
		}


	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(2117)
			p.Expression_higher_prec_than_and()
		}
		{
			p.SetState(2118)
			p.Like_operator()
		}
		{
			p.SetState(2119)
			p.Expression_higher_prec_than_and()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IParenthesized_anysomeall_list_in_rhsContext is an interface to support dynamic dispatch.
type IParenthesized_anysomeall_list_in_rhsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Parenthesized_query() IParenthesized_queryContext
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Expression_maybe_parenthesized_not_a_query() IExpression_maybe_parenthesized_not_a_queryContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	In_list_two_or_more_prefix() IIn_list_two_or_more_prefixContext

	// IsParenthesized_anysomeall_list_in_rhsContext differentiates from other interfaces.
	IsParenthesized_anysomeall_list_in_rhsContext()
}

type Parenthesized_anysomeall_list_in_rhsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesized_anysomeall_list_in_rhsContext() *Parenthesized_anysomeall_list_in_rhsContext {
	var p = new(Parenthesized_anysomeall_list_in_rhsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_parenthesized_anysomeall_list_in_rhs
	return p
}

func InitEmptyParenthesized_anysomeall_list_in_rhsContext(p *Parenthesized_anysomeall_list_in_rhsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_parenthesized_anysomeall_list_in_rhs
}

func (*Parenthesized_anysomeall_list_in_rhsContext) IsParenthesized_anysomeall_list_in_rhsContext() {}

func NewParenthesized_anysomeall_list_in_rhsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parenthesized_anysomeall_list_in_rhsContext {
	var p = new(Parenthesized_anysomeall_list_in_rhsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_parenthesized_anysomeall_list_in_rhs

	return p
}

func (s *Parenthesized_anysomeall_list_in_rhsContext) GetParser() antlr.Parser { return s.parser }

func (s *Parenthesized_anysomeall_list_in_rhsContext) Parenthesized_query() IParenthesized_queryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesized_queryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesized_queryContext)
}

func (s *Parenthesized_anysomeall_list_in_rhsContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Parenthesized_anysomeall_list_in_rhsContext) Expression_maybe_parenthesized_not_a_query() IExpression_maybe_parenthesized_not_a_queryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpression_maybe_parenthesized_not_a_queryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpression_maybe_parenthesized_not_a_queryContext)
}

func (s *Parenthesized_anysomeall_list_in_rhsContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Parenthesized_anysomeall_list_in_rhsContext) In_list_two_or_more_prefix() IIn_list_two_or_more_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIn_list_two_or_more_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIn_list_two_or_more_prefixContext)
}

func (s *Parenthesized_anysomeall_list_in_rhsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthesized_anysomeall_list_in_rhsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Parenthesized_anysomeall_list_in_rhsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterParenthesized_anysomeall_list_in_rhs(s)
	}
}

func (s *Parenthesized_anysomeall_list_in_rhsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitParenthesized_anysomeall_list_in_rhs(s)
	}
}

func (s *Parenthesized_anysomeall_list_in_rhsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitParenthesized_anysomeall_list_in_rhs(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Parenthesized_anysomeall_list_in_rhs() (localctx IParenthesized_anysomeall_list_in_rhsContext) {
	localctx = NewParenthesized_anysomeall_list_in_rhsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, GoogleSQLParserRULE_parenthesized_anysomeall_list_in_rhs)
	p.SetState(2131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 211, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2123)
			p.Parenthesized_query()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2124)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2125)
			p.Expression_maybe_parenthesized_not_a_query()
		}
		{
			p.SetState(2126)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2128)
			p.In_list_two_or_more_prefix()
		}
		{
			p.SetState(2129)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIn_list_two_or_more_prefixContext is an interface to support dynamic dispatch.
type IIn_list_two_or_more_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsIn_list_two_or_more_prefixContext differentiates from other interfaces.
	IsIn_list_two_or_more_prefixContext()
}

type In_list_two_or_more_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIn_list_two_or_more_prefixContext() *In_list_two_or_more_prefixContext {
	var p = new(In_list_two_or_more_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_in_list_two_or_more_prefix
	return p
}

func InitEmptyIn_list_two_or_more_prefixContext(p *In_list_two_or_more_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_in_list_two_or_more_prefix
}

func (*In_list_two_or_more_prefixContext) IsIn_list_two_or_more_prefixContext() {}

func NewIn_list_two_or_more_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *In_list_two_or_more_prefixContext {
	var p = new(In_list_two_or_more_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_in_list_two_or_more_prefix

	return p
}

func (s *In_list_two_or_more_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *In_list_two_or_more_prefixContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *In_list_two_or_more_prefixContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *In_list_two_or_more_prefixContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *In_list_two_or_more_prefixContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *In_list_two_or_more_prefixContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *In_list_two_or_more_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *In_list_two_or_more_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *In_list_two_or_more_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterIn_list_two_or_more_prefix(s)
	}
}

func (s *In_list_two_or_more_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitIn_list_two_or_more_prefix(s)
	}
}

func (s *In_list_two_or_more_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitIn_list_two_or_more_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) In_list_two_or_more_prefix() (localctx IIn_list_two_or_more_prefixContext) {
	localctx = NewIn_list_two_or_more_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, GoogleSQLParserRULE_in_list_two_or_more_prefix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2133)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2134)
		p.expression(0)
	}
	{
		p.SetState(2135)
		p.Match(GoogleSQLParserCOMMA_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2136)
		p.expression(0)
	}
	p.SetState(2141)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(2137)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2138)
			p.expression(0)
		}


		p.SetState(2143)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAny_some_allContext is an interface to support dynamic dispatch.
type IAny_some_allContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANY_SYMBOL() antlr.TerminalNode
	SOME_SYMBOL() antlr.TerminalNode
	ALL_SYMBOL() antlr.TerminalNode

	// IsAny_some_allContext differentiates from other interfaces.
	IsAny_some_allContext()
}

type Any_some_allContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAny_some_allContext() *Any_some_allContext {
	var p = new(Any_some_allContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_any_some_all
	return p
}

func InitEmptyAny_some_allContext(p *Any_some_allContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_any_some_all
}

func (*Any_some_allContext) IsAny_some_allContext() {}

func NewAny_some_allContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Any_some_allContext {
	var p = new(Any_some_allContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_any_some_all

	return p
}

func (s *Any_some_allContext) GetParser() antlr.Parser { return s.parser }

func (s *Any_some_allContext) ANY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserANY_SYMBOL, 0)
}

func (s *Any_some_allContext) SOME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSOME_SYMBOL, 0)
}

func (s *Any_some_allContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserALL_SYMBOL, 0)
}

func (s *Any_some_allContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Any_some_allContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Any_some_allContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterAny_some_all(s)
	}
}

func (s *Any_some_allContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitAny_some_all(s)
	}
}

func (s *Any_some_allContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitAny_some_all(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Any_some_all() (localctx IAny_some_allContext) {
	localctx = NewAny_some_allContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, GoogleSQLParserRULE_any_some_all)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2144)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GoogleSQLParserALL_SYMBOL || _la == GoogleSQLParserANY_SYMBOL || _la == GoogleSQLParserSOME_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILike_operatorContext is an interface to support dynamic dispatch.
type ILike_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIKE_SYMBOL() antlr.TerminalNode
	NOT_SPECIAL_SYMBOL() antlr.TerminalNode

	// IsLike_operatorContext differentiates from other interfaces.
	IsLike_operatorContext()
}

type Like_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLike_operatorContext() *Like_operatorContext {
	var p = new(Like_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_like_operator
	return p
}

func InitEmptyLike_operatorContext(p *Like_operatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_like_operator
}

func (*Like_operatorContext) IsLike_operatorContext() {}

func NewLike_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Like_operatorContext {
	var p = new(Like_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_like_operator

	return p
}

func (s *Like_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Like_operatorContext) LIKE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLIKE_SYMBOL, 0)
}

func (s *Like_operatorContext) NOT_SPECIAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserNOT_SPECIAL_SYMBOL, 0)
}

func (s *Like_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Like_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Like_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterLike_operator(s)
	}
}

func (s *Like_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitLike_operator(s)
	}
}

func (s *Like_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitLike_operator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Like_operator() (localctx ILike_operatorContext) {
	localctx = NewLike_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, GoogleSQLParserRULE_like_operator)
	p.SetState(2149)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserLIKE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2146)
			p.Match(GoogleSQLParserLIKE_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case GoogleSQLParserNOT_SPECIAL_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2147)
			p.Match(GoogleSQLParserNOT_SPECIAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2148)
			p.Match(GoogleSQLParserLIKE_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpression_subquery_with_keywordContext is an interface to support dynamic dispatch.
type IExpression_subquery_with_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_SYMBOL() antlr.TerminalNode
	Parenthesized_query() IParenthesized_queryContext
	EXISTS_SYMBOL() antlr.TerminalNode
	Hint() IHintContext

	// IsExpression_subquery_with_keywordContext differentiates from other interfaces.
	IsExpression_subquery_with_keywordContext()
}

type Expression_subquery_with_keywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_subquery_with_keywordContext() *Expression_subquery_with_keywordContext {
	var p = new(Expression_subquery_with_keywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_expression_subquery_with_keyword
	return p
}

func InitEmptyExpression_subquery_with_keywordContext(p *Expression_subquery_with_keywordContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_expression_subquery_with_keyword
}

func (*Expression_subquery_with_keywordContext) IsExpression_subquery_with_keywordContext() {}

func NewExpression_subquery_with_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_subquery_with_keywordContext {
	var p = new(Expression_subquery_with_keywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_expression_subquery_with_keyword

	return p
}

func (s *Expression_subquery_with_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_subquery_with_keywordContext) ARRAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserARRAY_SYMBOL, 0)
}

func (s *Expression_subquery_with_keywordContext) Parenthesized_query() IParenthesized_queryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesized_queryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesized_queryContext)
}

func (s *Expression_subquery_with_keywordContext) EXISTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEXISTS_SYMBOL, 0)
}

func (s *Expression_subquery_with_keywordContext) Hint() IHintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintContext)
}

func (s *Expression_subquery_with_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_subquery_with_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expression_subquery_with_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterExpression_subquery_with_keyword(s)
	}
}

func (s *Expression_subquery_with_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitExpression_subquery_with_keyword(s)
	}
}

func (s *Expression_subquery_with_keywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitExpression_subquery_with_keyword(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Expression_subquery_with_keyword() (localctx IExpression_subquery_with_keywordContext) {
	localctx = NewExpression_subquery_with_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, GoogleSQLParserRULE_expression_subquery_with_keyword)
	var _la int

	p.SetState(2158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserARRAY_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2151)
			p.Match(GoogleSQLParserARRAY_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2152)
			p.Parenthesized_query()
		}


	case GoogleSQLParserEXISTS_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2153)
			p.Match(GoogleSQLParserEXISTS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2155)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserAT_SYMBOL {
			{
				p.SetState(2154)
				p.Hint()
			}

		}
		{
			p.SetState(2157)
			p.Parenthesized_query()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStruct_constructorContext is an interface to support dynamic dispatch.
type IStruct_constructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Struct_constructor_prefix_with_keyword() IStruct_constructor_prefix_with_keywordContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	Struct_constructor_prefix_with_keyword_no_arg() IStruct_constructor_prefix_with_keyword_no_argContext
	Struct_constructor_prefix_without_keyword() IStruct_constructor_prefix_without_keywordContext

	// IsStruct_constructorContext differentiates from other interfaces.
	IsStruct_constructorContext()
}

type Struct_constructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_constructorContext() *Struct_constructorContext {
	var p = new(Struct_constructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_struct_constructor
	return p
}

func InitEmptyStruct_constructorContext(p *Struct_constructorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_struct_constructor
}

func (*Struct_constructorContext) IsStruct_constructorContext() {}

func NewStruct_constructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_constructorContext {
	var p = new(Struct_constructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_struct_constructor

	return p
}

func (s *Struct_constructorContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_constructorContext) Struct_constructor_prefix_with_keyword() IStruct_constructor_prefix_with_keywordContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_constructor_prefix_with_keywordContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_constructor_prefix_with_keywordContext)
}

func (s *Struct_constructorContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Struct_constructorContext) Struct_constructor_prefix_with_keyword_no_arg() IStruct_constructor_prefix_with_keyword_no_argContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_constructor_prefix_with_keyword_no_argContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_constructor_prefix_with_keyword_no_argContext)
}

func (s *Struct_constructorContext) Struct_constructor_prefix_without_keyword() IStruct_constructor_prefix_without_keywordContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_constructor_prefix_without_keywordContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_constructor_prefix_without_keywordContext)
}

func (s *Struct_constructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_constructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Struct_constructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterStruct_constructor(s)
	}
}

func (s *Struct_constructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitStruct_constructor(s)
	}
}

func (s *Struct_constructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitStruct_constructor(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Struct_constructor() (localctx IStruct_constructorContext) {
	localctx = NewStruct_constructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, GoogleSQLParserRULE_struct_constructor)
	p.SetState(2169)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 216, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2160)
			p.Struct_constructor_prefix_with_keyword()
		}
		{
			p.SetState(2161)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2163)
			p.Struct_constructor_prefix_with_keyword_no_arg()
		}
		{
			p.SetState(2164)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2166)
			p.Struct_constructor_prefix_without_keyword()
		}
		{
			p.SetState(2167)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStruct_constructor_prefix_with_keywordContext is an interface to support dynamic dispatch.
type IStruct_constructor_prefix_with_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Struct_constructor_prefix_with_keyword_no_arg() IStruct_constructor_prefix_with_keyword_no_argContext
	AllStruct_constructor_arg() []IStruct_constructor_argContext
	Struct_constructor_arg(i int) IStruct_constructor_argContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsStruct_constructor_prefix_with_keywordContext differentiates from other interfaces.
	IsStruct_constructor_prefix_with_keywordContext()
}

type Struct_constructor_prefix_with_keywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_constructor_prefix_with_keywordContext() *Struct_constructor_prefix_with_keywordContext {
	var p = new(Struct_constructor_prefix_with_keywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_struct_constructor_prefix_with_keyword
	return p
}

func InitEmptyStruct_constructor_prefix_with_keywordContext(p *Struct_constructor_prefix_with_keywordContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_struct_constructor_prefix_with_keyword
}

func (*Struct_constructor_prefix_with_keywordContext) IsStruct_constructor_prefix_with_keywordContext() {}

func NewStruct_constructor_prefix_with_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_constructor_prefix_with_keywordContext {
	var p = new(Struct_constructor_prefix_with_keywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_struct_constructor_prefix_with_keyword

	return p
}

func (s *Struct_constructor_prefix_with_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_constructor_prefix_with_keywordContext) Struct_constructor_prefix_with_keyword_no_arg() IStruct_constructor_prefix_with_keyword_no_argContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_constructor_prefix_with_keyword_no_argContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_constructor_prefix_with_keyword_no_argContext)
}

func (s *Struct_constructor_prefix_with_keywordContext) AllStruct_constructor_arg() []IStruct_constructor_argContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStruct_constructor_argContext); ok {
			len++
		}
	}

	tst := make([]IStruct_constructor_argContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStruct_constructor_argContext); ok {
			tst[i] = t.(IStruct_constructor_argContext)
			i++
		}
	}

	return tst
}

func (s *Struct_constructor_prefix_with_keywordContext) Struct_constructor_arg(i int) IStruct_constructor_argContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_constructor_argContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_constructor_argContext)
}

func (s *Struct_constructor_prefix_with_keywordContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Struct_constructor_prefix_with_keywordContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Struct_constructor_prefix_with_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_constructor_prefix_with_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Struct_constructor_prefix_with_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterStruct_constructor_prefix_with_keyword(s)
	}
}

func (s *Struct_constructor_prefix_with_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitStruct_constructor_prefix_with_keyword(s)
	}
}

func (s *Struct_constructor_prefix_with_keywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitStruct_constructor_prefix_with_keyword(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Struct_constructor_prefix_with_keyword() (localctx IStruct_constructor_prefix_with_keywordContext) {
	localctx = NewStruct_constructor_prefix_with_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, GoogleSQLParserRULE_struct_constructor_prefix_with_keyword)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2171)
		p.Struct_constructor_prefix_with_keyword_no_arg()
	}
	{
		p.SetState(2172)
		p.Struct_constructor_arg()
	}
	p.SetState(2177)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(2173)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2174)
			p.Struct_constructor_arg()
		}


		p.SetState(2179)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStruct_constructor_argContext is an interface to support dynamic dispatch.
type IStruct_constructor_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Opt_as_alias_with_required_as() IOpt_as_alias_with_required_asContext

	// IsStruct_constructor_argContext differentiates from other interfaces.
	IsStruct_constructor_argContext()
}

type Struct_constructor_argContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_constructor_argContext() *Struct_constructor_argContext {
	var p = new(Struct_constructor_argContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_struct_constructor_arg
	return p
}

func InitEmptyStruct_constructor_argContext(p *Struct_constructor_argContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_struct_constructor_arg
}

func (*Struct_constructor_argContext) IsStruct_constructor_argContext() {}

func NewStruct_constructor_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_constructor_argContext {
	var p = new(Struct_constructor_argContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_struct_constructor_arg

	return p
}

func (s *Struct_constructor_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_constructor_argContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Struct_constructor_argContext) Opt_as_alias_with_required_as() IOpt_as_alias_with_required_asContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_as_alias_with_required_asContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_as_alias_with_required_asContext)
}

func (s *Struct_constructor_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_constructor_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Struct_constructor_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterStruct_constructor_arg(s)
	}
}

func (s *Struct_constructor_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitStruct_constructor_arg(s)
	}
}

func (s *Struct_constructor_argContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitStruct_constructor_arg(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Struct_constructor_arg() (localctx IStruct_constructor_argContext) {
	localctx = NewStruct_constructor_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, GoogleSQLParserRULE_struct_constructor_arg)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2180)
		p.expression(0)
	}
	p.SetState(2182)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserAS_SYMBOL {
		{
			p.SetState(2181)
			p.Opt_as_alias_with_required_as()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStruct_constructor_prefix_without_keywordContext is an interface to support dynamic dispatch.
type IStruct_constructor_prefix_without_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsStruct_constructor_prefix_without_keywordContext differentiates from other interfaces.
	IsStruct_constructor_prefix_without_keywordContext()
}

type Struct_constructor_prefix_without_keywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_constructor_prefix_without_keywordContext() *Struct_constructor_prefix_without_keywordContext {
	var p = new(Struct_constructor_prefix_without_keywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_struct_constructor_prefix_without_keyword
	return p
}

func InitEmptyStruct_constructor_prefix_without_keywordContext(p *Struct_constructor_prefix_without_keywordContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_struct_constructor_prefix_without_keyword
}

func (*Struct_constructor_prefix_without_keywordContext) IsStruct_constructor_prefix_without_keywordContext() {}

func NewStruct_constructor_prefix_without_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_constructor_prefix_without_keywordContext {
	var p = new(Struct_constructor_prefix_without_keywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_struct_constructor_prefix_without_keyword

	return p
}

func (s *Struct_constructor_prefix_without_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_constructor_prefix_without_keywordContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Struct_constructor_prefix_without_keywordContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Struct_constructor_prefix_without_keywordContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Struct_constructor_prefix_without_keywordContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Struct_constructor_prefix_without_keywordContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Struct_constructor_prefix_without_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_constructor_prefix_without_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Struct_constructor_prefix_without_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterStruct_constructor_prefix_without_keyword(s)
	}
}

func (s *Struct_constructor_prefix_without_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitStruct_constructor_prefix_without_keyword(s)
	}
}

func (s *Struct_constructor_prefix_without_keywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitStruct_constructor_prefix_without_keyword(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Struct_constructor_prefix_without_keyword() (localctx IStruct_constructor_prefix_without_keywordContext) {
	localctx = NewStruct_constructor_prefix_without_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, GoogleSQLParserRULE_struct_constructor_prefix_without_keyword)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2184)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2185)
		p.expression(0)
	}
	{
		p.SetState(2186)
		p.Match(GoogleSQLParserCOMMA_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2187)
		p.expression(0)
	}
	p.SetState(2192)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(2188)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2189)
			p.expression(0)
		}


		p.SetState(2194)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStruct_constructor_prefix_with_keyword_no_argContext is an interface to support dynamic dispatch.
type IStruct_constructor_prefix_with_keyword_no_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Struct_type() IStruct_typeContext
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	STRUCT_SYMBOL() antlr.TerminalNode

	// IsStruct_constructor_prefix_with_keyword_no_argContext differentiates from other interfaces.
	IsStruct_constructor_prefix_with_keyword_no_argContext()
}

type Struct_constructor_prefix_with_keyword_no_argContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_constructor_prefix_with_keyword_no_argContext() *Struct_constructor_prefix_with_keyword_no_argContext {
	var p = new(Struct_constructor_prefix_with_keyword_no_argContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_struct_constructor_prefix_with_keyword_no_arg
	return p
}

func InitEmptyStruct_constructor_prefix_with_keyword_no_argContext(p *Struct_constructor_prefix_with_keyword_no_argContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_struct_constructor_prefix_with_keyword_no_arg
}

func (*Struct_constructor_prefix_with_keyword_no_argContext) IsStruct_constructor_prefix_with_keyword_no_argContext() {}

func NewStruct_constructor_prefix_with_keyword_no_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_constructor_prefix_with_keyword_no_argContext {
	var p = new(Struct_constructor_prefix_with_keyword_no_argContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_struct_constructor_prefix_with_keyword_no_arg

	return p
}

func (s *Struct_constructor_prefix_with_keyword_no_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_constructor_prefix_with_keyword_no_argContext) Struct_type() IStruct_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_typeContext)
}

func (s *Struct_constructor_prefix_with_keyword_no_argContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Struct_constructor_prefix_with_keyword_no_argContext) STRUCT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSTRUCT_SYMBOL, 0)
}

func (s *Struct_constructor_prefix_with_keyword_no_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_constructor_prefix_with_keyword_no_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Struct_constructor_prefix_with_keyword_no_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterStruct_constructor_prefix_with_keyword_no_arg(s)
	}
}

func (s *Struct_constructor_prefix_with_keyword_no_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitStruct_constructor_prefix_with_keyword_no_arg(s)
	}
}

func (s *Struct_constructor_prefix_with_keyword_no_argContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitStruct_constructor_prefix_with_keyword_no_arg(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Struct_constructor_prefix_with_keyword_no_arg() (localctx IStruct_constructor_prefix_with_keyword_no_argContext) {
	localctx = NewStruct_constructor_prefix_with_keyword_no_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, GoogleSQLParserRULE_struct_constructor_prefix_with_keyword_no_arg)
	p.SetState(2200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 220, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2195)
			p.Struct_type()
		}
		{
			p.SetState(2196)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2198)
			p.Match(GoogleSQLParserSTRUCT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2199)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInterval_expressionContext is an interface to support dynamic dispatch.
type IInterval_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERVAL_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	TO_SYMBOL() antlr.TerminalNode

	// IsInterval_expressionContext differentiates from other interfaces.
	IsInterval_expressionContext()
}

type Interval_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterval_expressionContext() *Interval_expressionContext {
	var p = new(Interval_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_interval_expression
	return p
}

func InitEmptyInterval_expressionContext(p *Interval_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_interval_expression
}

func (*Interval_expressionContext) IsInterval_expressionContext() {}

func NewInterval_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interval_expressionContext {
	var p = new(Interval_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_interval_expression

	return p
}

func (s *Interval_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Interval_expressionContext) INTERVAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINTERVAL_SYMBOL, 0)
}

func (s *Interval_expressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Interval_expressionContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Interval_expressionContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Interval_expressionContext) TO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTO_SYMBOL, 0)
}

func (s *Interval_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interval_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Interval_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterInterval_expression(s)
	}
}

func (s *Interval_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitInterval_expression(s)
	}
}

func (s *Interval_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitInterval_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Interval_expression() (localctx IInterval_expressionContext) {
	localctx = NewInterval_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, GoogleSQLParserRULE_interval_expression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2202)
		p.Match(GoogleSQLParserINTERVAL_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2203)
		p.expression(0)
	}
	{
		p.SetState(2204)
		p.Identifier()
	}
	p.SetState(2207)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserTO_SYMBOL {
		{
			p.SetState(2205)
			p.Match(GoogleSQLParserTO_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2206)
			p.Identifier()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunction_call_expression_with_clausesContext is an interface to support dynamic dispatch.
type IFunction_call_expression_with_clausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Function_call_expression() IFunction_call_expressionContext
	Hint() IHintContext
	With_group_rows() IWith_group_rowsContext
	Over_clause() IOver_clauseContext

	// IsFunction_call_expression_with_clausesContext differentiates from other interfaces.
	IsFunction_call_expression_with_clausesContext()
}

type Function_call_expression_with_clausesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_call_expression_with_clausesContext() *Function_call_expression_with_clausesContext {
	var p = new(Function_call_expression_with_clausesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_function_call_expression_with_clauses
	return p
}

func InitEmptyFunction_call_expression_with_clausesContext(p *Function_call_expression_with_clausesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_function_call_expression_with_clauses
}

func (*Function_call_expression_with_clausesContext) IsFunction_call_expression_with_clausesContext() {}

func NewFunction_call_expression_with_clausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_call_expression_with_clausesContext {
	var p = new(Function_call_expression_with_clausesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_function_call_expression_with_clauses

	return p
}

func (s *Function_call_expression_with_clausesContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_call_expression_with_clausesContext) Function_call_expression() IFunction_call_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_call_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_call_expressionContext)
}

func (s *Function_call_expression_with_clausesContext) Hint() IHintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintContext)
}

func (s *Function_call_expression_with_clausesContext) With_group_rows() IWith_group_rowsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_group_rowsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_group_rowsContext)
}

func (s *Function_call_expression_with_clausesContext) Over_clause() IOver_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOver_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOver_clauseContext)
}

func (s *Function_call_expression_with_clausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_call_expression_with_clausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Function_call_expression_with_clausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterFunction_call_expression_with_clauses(s)
	}
}

func (s *Function_call_expression_with_clausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitFunction_call_expression_with_clauses(s)
	}
}

func (s *Function_call_expression_with_clausesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitFunction_call_expression_with_clauses(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Function_call_expression_with_clauses() (localctx IFunction_call_expression_with_clausesContext) {
	localctx = NewFunction_call_expression_with_clausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, GoogleSQLParserRULE_function_call_expression_with_clauses)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2209)
		p.Function_call_expression()
	}
	p.SetState(2211)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserAT_SYMBOL {
		{
			p.SetState(2210)
			p.Hint()
		}

	}
	p.SetState(2214)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserWITH_SYMBOL {
		{
			p.SetState(2213)
			p.With_group_rows()
		}

	}
	p.SetState(2217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserOVER_SYMBOL {
		{
			p.SetState(2216)
			p.Over_clause()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunction_call_expressionContext is an interface to support dynamic dispatch.
type IFunction_call_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Function_call_expression_base() IFunction_call_expression_baseContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	Opt_having_or_group_by_modifier() IOpt_having_or_group_by_modifierContext
	Order_by_clause() IOrder_by_clauseContext
	Limit_offset_clause() ILimit_offset_clauseContext
	Function_call_expression_with_args_prefix() IFunction_call_expression_with_args_prefixContext
	Opt_null_handling_modifier() IOpt_null_handling_modifierContext
	Clamped_between_modifier() IClamped_between_modifierContext
	With_report_modifier() IWith_report_modifierContext

	// IsFunction_call_expressionContext differentiates from other interfaces.
	IsFunction_call_expressionContext()
}

type Function_call_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_call_expressionContext() *Function_call_expressionContext {
	var p = new(Function_call_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_function_call_expression
	return p
}

func InitEmptyFunction_call_expressionContext(p *Function_call_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_function_call_expression
}

func (*Function_call_expressionContext) IsFunction_call_expressionContext() {}

func NewFunction_call_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_call_expressionContext {
	var p = new(Function_call_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_function_call_expression

	return p
}

func (s *Function_call_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_call_expressionContext) Function_call_expression_base() IFunction_call_expression_baseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_call_expression_baseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_call_expression_baseContext)
}

func (s *Function_call_expressionContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Function_call_expressionContext) Opt_having_or_group_by_modifier() IOpt_having_or_group_by_modifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_having_or_group_by_modifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_having_or_group_by_modifierContext)
}

func (s *Function_call_expressionContext) Order_by_clause() IOrder_by_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Function_call_expressionContext) Limit_offset_clause() ILimit_offset_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimit_offset_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimit_offset_clauseContext)
}

func (s *Function_call_expressionContext) Function_call_expression_with_args_prefix() IFunction_call_expression_with_args_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_call_expression_with_args_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_call_expression_with_args_prefixContext)
}

func (s *Function_call_expressionContext) Opt_null_handling_modifier() IOpt_null_handling_modifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_null_handling_modifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_null_handling_modifierContext)
}

func (s *Function_call_expressionContext) Clamped_between_modifier() IClamped_between_modifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClamped_between_modifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClamped_between_modifierContext)
}

func (s *Function_call_expressionContext) With_report_modifier() IWith_report_modifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_report_modifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_report_modifierContext)
}

func (s *Function_call_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_call_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Function_call_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterFunction_call_expression(s)
	}
}

func (s *Function_call_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitFunction_call_expression(s)
	}
}

func (s *Function_call_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitFunction_call_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Function_call_expression() (localctx IFunction_call_expressionContext) {
	localctx = NewFunction_call_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, GoogleSQLParserRULE_function_call_expression)
	var _la int

	p.SetState(2252)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserLEFT_SYMBOL, GoogleSQLParserRIGHT_SYMBOL, GoogleSQLParserRANGE_SYMBOL, GoogleSQLParserCOLLATE_SYMBOL, GoogleSQLParserIF_SYMBOL, GoogleSQLParserGROUPING_SYMBOL, GoogleSQLParserLR_BRACKET_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2219)
			p.Function_call_expression_base()
		}
		p.SetState(2221)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserHAVING_SYMBOL {
			{
				p.SetState(2220)
				p.Opt_having_or_group_by_modifier()
			}

		}
		p.SetState(2224)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserORDER_SYMBOL {
			{
				p.SetState(2223)
				p.Order_by_clause()
			}

		}
		p.SetState(2227)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserLIMIT_SYMBOL {
			{
				p.SetState(2226)
				p.Limit_offset_clause()
			}

		}
		{
			p.SetState(2229)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case GoogleSQLParserCOMMA_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2231)
			p.Function_call_expression_with_args_prefix()
		}
		p.SetState(2233)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserIGNORE_SYMBOL || _la == GoogleSQLParserRESPECT_SYMBOL {
			{
				p.SetState(2232)
				p.Opt_null_handling_modifier()
			}

		}
		p.SetState(2236)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserHAVING_SYMBOL {
			{
				p.SetState(2235)
				p.Opt_having_or_group_by_modifier()
			}

		}
		p.SetState(2239)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserCLAMPED_SYMBOL {
			{
				p.SetState(2238)
				p.Clamped_between_modifier()
			}

		}
		p.SetState(2242)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserWITH_SYMBOL {
			{
				p.SetState(2241)
				p.With_report_modifier()
			}

		}
		p.SetState(2245)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserORDER_SYMBOL {
			{
				p.SetState(2244)
				p.Order_by_clause()
			}

		}
		p.SetState(2248)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserLIMIT_SYMBOL {
			{
				p.SetState(2247)
				p.Limit_offset_clause()
			}

		}
		{
			p.SetState(2250)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOver_clauseContext is an interface to support dynamic dispatch.
type IOver_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OVER_SYMBOL() antlr.TerminalNode
	Window_specification() IWindow_specificationContext

	// IsOver_clauseContext differentiates from other interfaces.
	IsOver_clauseContext()
}

type Over_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOver_clauseContext() *Over_clauseContext {
	var p = new(Over_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_over_clause
	return p
}

func InitEmptyOver_clauseContext(p *Over_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_over_clause
}

func (*Over_clauseContext) IsOver_clauseContext() {}

func NewOver_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Over_clauseContext {
	var p = new(Over_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_over_clause

	return p
}

func (s *Over_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Over_clauseContext) OVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserOVER_SYMBOL, 0)
}

func (s *Over_clauseContext) Window_specification() IWindow_specificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_specificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_specificationContext)
}

func (s *Over_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Over_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Over_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOver_clause(s)
	}
}

func (s *Over_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOver_clause(s)
	}
}

func (s *Over_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOver_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Over_clause() (localctx IOver_clauseContext) {
	localctx = NewOver_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, GoogleSQLParserRULE_over_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2254)
		p.Match(GoogleSQLParserOVER_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2255)
		p.Window_specification()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_specificationContext is an interface to support dynamic dispatch.
type IWindow_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	Partition_by_clause() IPartition_by_clauseContext
	Order_by_clause() IOrder_by_clauseContext
	Opt_window_frame_clause() IOpt_window_frame_clauseContext

	// IsWindow_specificationContext differentiates from other interfaces.
	IsWindow_specificationContext()
}

type Window_specificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_specificationContext() *Window_specificationContext {
	var p = new(Window_specificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_window_specification
	return p
}

func InitEmptyWindow_specificationContext(p *Window_specificationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_window_specification
}

func (*Window_specificationContext) IsWindow_specificationContext() {}

func NewWindow_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_specificationContext {
	var p = new(Window_specificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_window_specification

	return p
}

func (s *Window_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_specificationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Window_specificationContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Window_specificationContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Window_specificationContext) Partition_by_clause() IPartition_by_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartition_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartition_by_clauseContext)
}

func (s *Window_specificationContext) Order_by_clause() IOrder_by_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Window_specificationContext) Opt_window_frame_clause() IOpt_window_frame_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_window_frame_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_window_frame_clauseContext)
}

func (s *Window_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterWindow_specification(s)
	}
}

func (s *Window_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitWindow_specification(s)
	}
}

func (s *Window_specificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitWindow_specification(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Window_specification() (localctx IWindow_specificationContext) {
	localctx = NewWindow_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, GoogleSQLParserRULE_window_specification)
	var _la int

	p.SetState(2272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserINCLUDE_SYMBOL, GoogleSQLParserOFFSET_SYMBOL, GoogleSQLParserOPTIONS_SYMBOL, GoogleSQLParserPERCENT_SYMBOL, GoogleSQLParserPIVOT_SYMBOL, GoogleSQLParserREPLACE_SYMBOL, GoogleSQLParserUNPIVOT_SYMBOL, GoogleSQLParserSYSTEM_SYMBOL, GoogleSQLParserSYSTEM_TIME_SYMBOL, GoogleSQLParserVALUE_SYMBOL, GoogleSQLParserNUMERIC_SYMBOL, GoogleSQLParserDECIMAL_SYMBOL, GoogleSQLParserBIGNUMERIC_SYMBOL, GoogleSQLParserBIGDECIMAL_SYMBOL, GoogleSQLParserJSON_SYMBOL, GoogleSQLParserDATE_SYMBOL, GoogleSQLParserTIME_SYMBOL, GoogleSQLParserDATETIME_SYMBOL, GoogleSQLParserTIMESTAMP_SYMBOL, GoogleSQLParserSIMPLE_SYMBOL, GoogleSQLParserABORT_SYMBOL, GoogleSQLParserACCESS_SYMBOL, GoogleSQLParserACTION_SYMBOL, GoogleSQLParserAGGREGATE_SYMBOL, GoogleSQLParserADD_SYMBOL, GoogleSQLParserALTER_SYMBOL, GoogleSQLParserALWAYS_SYMBOL, GoogleSQLParserANALYZE_SYMBOL, GoogleSQLParserAPPROX_SYMBOL, GoogleSQLParserARE_SYMBOL, GoogleSQLParserASSERT_SYMBOL, GoogleSQLParserBATCH_SYMBOL, GoogleSQLParserBEGIN_SYMBOL, GoogleSQLParserBREAK_SYMBOL, GoogleSQLParserCALL_SYMBOL, GoogleSQLParserCASCADE_SYMBOL, GoogleSQLParserCHECK_SYMBOL, GoogleSQLParserCLAMPED_SYMBOL, GoogleSQLParserCLONE_SYMBOL, GoogleSQLParserCOPY_SYMBOL, GoogleSQLParserCLUSTER_SYMBOL, GoogleSQLParserCOLUMN_SYMBOL, GoogleSQLParserCOLUMNS_SYMBOL, GoogleSQLParserCOMMIT_SYMBOL, GoogleSQLParserCONNECTION_SYMBOL, GoogleSQLParserCONSTANT_SYMBOL, GoogleSQLParserCONSTRAINT_SYMBOL, GoogleSQLParserCONTINUE_SYMBOL, GoogleSQLParserCORRESPONDING_SYMBOL, GoogleSQLParserCYCLE_SYMBOL, GoogleSQLParserDATA_SYMBOL, GoogleSQLParserDATABASE_SYMBOL, GoogleSQLParserDECLARE_SYMBOL, GoogleSQLParserDEFINER_SYMBOL, GoogleSQLParserDELETE_SYMBOL, GoogleSQLParserDELETION_SYMBOL, GoogleSQLParserDEPTH_SYMBOL, GoogleSQLParserDESCRIBE_SYMBOL, GoogleSQLParserDETERMINISTIC_SYMBOL, GoogleSQLParserDO_SYMBOL, GoogleSQLParserDROP_SYMBOL, GoogleSQLParserELSEIF_SYMBOL, GoogleSQLParserENFORCED_SYMBOL, GoogleSQLParserERROR_SYMBOL, GoogleSQLParserEXCEPTION_SYMBOL, GoogleSQLParserEXECUTE_SYMBOL, GoogleSQLParserEXPLAIN_SYMBOL, GoogleSQLParserEXPORT_SYMBOL, GoogleSQLParserEXTEND_SYMBOL, GoogleSQLParserEXTERNAL_SYMBOL, GoogleSQLParserFILES_SYMBOL, GoogleSQLParserFILTER_SYMBOL, GoogleSQLParserFILL_SYMBOL, GoogleSQLParserFIRST_SYMBOL, GoogleSQLParserFOREIGN_SYMBOL, GoogleSQLParserFORMAT_SYMBOL, GoogleSQLParserFUNCTION_SYMBOL, GoogleSQLParserGENERATED_SYMBOL, GoogleSQLParserGRANT_SYMBOL, GoogleSQLParserGROUP_ROWS_SYMBOL, GoogleSQLParserHIDDEN_SYMBOL, GoogleSQLParserIDENTITY_SYMBOL, GoogleSQLParserIMMEDIATE_SYMBOL, GoogleSQLParserIMMUTABLE_SYMBOL, GoogleSQLParserIMPORT_SYMBOL, GoogleSQLParserINCREMENT_SYMBOL, GoogleSQLParserINDEX_SYMBOL, GoogleSQLParserINOUT_SYMBOL, GoogleSQLParserINPUT_SYMBOL, GoogleSQLParserINSERT_SYMBOL, GoogleSQLParserINVOKER_SYMBOL, GoogleSQLParserISOLATION_SYMBOL, GoogleSQLParserITERATE_SYMBOL, GoogleSQLParserKEY_SYMBOL, GoogleSQLParserLANGUAGE_SYMBOL, GoogleSQLParserLAST_SYMBOL, GoogleSQLParserLEAVE_SYMBOL, GoogleSQLParserLEVEL_SYMBOL, GoogleSQLParserLOAD_SYMBOL, GoogleSQLParserLOOP_SYMBOL, GoogleSQLParserMACRO_SYMBOL, GoogleSQLParserMAP_SYMBOL, GoogleSQLParserMATCH_SYMBOL, GoogleSQLParserKW_MATCH_RECOGNIZE_NONRESERVED_SYMBOL, GoogleSQLParserMATCHED_SYMBOL, GoogleSQLParserMATERIALIZED_SYMBOL, GoogleSQLParserMAX_SYMBOL, GoogleSQLParserMAXVALUE_SYMBOL, GoogleSQLParserMEASURES_SYMBOL, GoogleSQLParserMESSAGE_SYMBOL, GoogleSQLParserMETADATA_SYMBOL, GoogleSQLParserMIN_SYMBOL, GoogleSQLParserMINVALUE_SYMBOL, GoogleSQLParserMODEL_SYMBOL, GoogleSQLParserMODULE_SYMBOL, GoogleSQLParserONLY_SYMBOL, GoogleSQLParserOUT_SYMBOL, GoogleSQLParserOUTPUT_SYMBOL, GoogleSQLParserOVERWRITE_SYMBOL, GoogleSQLParserPARTITIONS_SYMBOL, GoogleSQLParserPATTERN_SYMBOL, GoogleSQLParserPOLICIES_SYMBOL, GoogleSQLParserPOLICY_SYMBOL, GoogleSQLParserPRIMARY_SYMBOL, GoogleSQLParserPRIVATE_SYMBOL, GoogleSQLParserPRIVILEGE_SYMBOL, GoogleSQLParserPRIVILEGES_SYMBOL, GoogleSQLParserPROCEDURE_SYMBOL, GoogleSQLParserPROJECT_SYMBOL, GoogleSQLParserPUBLIC_SYMBOL, GoogleSQLParserRAISE_SYMBOL, GoogleSQLParserREAD_SYMBOL, GoogleSQLParserREFERENCES_SYMBOL, GoogleSQLParserREMOTE_SYMBOL, GoogleSQLParserREMOVE_SYMBOL, GoogleSQLParserRENAME_SYMBOL, GoogleSQLParserREPEAT_SYMBOL, GoogleSQLParserREPEATABLE_SYMBOL, GoogleSQLParserREPLACE_FIELDS_SYMBOL, GoogleSQLParserREPLICA_SYMBOL, GoogleSQLParserREPORT_SYMBOL, GoogleSQLParserRESTRICT_SYMBOL, GoogleSQLParserRESTRICTION_SYMBOL, GoogleSQLParserRETURNS_SYMBOL, GoogleSQLParserRETURN_SYMBOL, GoogleSQLParserREVOKE_SYMBOL, GoogleSQLParserROLLBACK_SYMBOL, GoogleSQLParserROW_SYMBOL, GoogleSQLParserRUN_SYMBOL, GoogleSQLParserSAFE_CAST_SYMBOL, GoogleSQLParserSCHEMA_SYMBOL, GoogleSQLParserSEARCH_SYMBOL, GoogleSQLParserSECURITY_SYMBOL, GoogleSQLParserSEQUENCE_SYMBOL, GoogleSQLParserSETS_SYMBOL, GoogleSQLParserSHOW_SYMBOL, GoogleSQLParserSNAPSHOT_SYMBOL, GoogleSQLParserSOURCE_SYMBOL, GoogleSQLParserSQL_SYMBOL, GoogleSQLParserSTABLE_SYMBOL, GoogleSQLParserSTART_SYMBOL, GoogleSQLParserSTATIC_DESCRIBE_SYMBOL, GoogleSQLParserSTORED_SYMBOL, GoogleSQLParserSTORING_SYMBOL, GoogleSQLParserSTRICT_SYMBOL, GoogleSQLParserTABLE_SYMBOL, GoogleSQLParserTABLES_SYMBOL, GoogleSQLParserTARGET_SYMBOL, GoogleSQLParserTEMP_SYMBOL, GoogleSQLParserTEMPORARY_SYMBOL, GoogleSQLParserTRANSACTION_SYMBOL, GoogleSQLParserTRANSFORM_SYMBOL, GoogleSQLParserTRUNCATE_SYMBOL, GoogleSQLParserTYPE_SYMBOL, GoogleSQLParserUNDROP_SYMBOL, GoogleSQLParserUNIQUE_SYMBOL, GoogleSQLParserUNKNOWN_SYMBOL, GoogleSQLParserUNTIL_SYMBOL, GoogleSQLParserUPDATE_SYMBOL, GoogleSQLParserVALUES_SYMBOL, GoogleSQLParserVECTOR_SYMBOL, GoogleSQLParserVIEW_SYMBOL, GoogleSQLParserVIEWS_SYMBOL, GoogleSQLParserVOLATILE_SYMBOL, GoogleSQLParserWEIGHT_SYMBOL, GoogleSQLParserWHILE_SYMBOL, GoogleSQLParserWRITE_SYMBOL, GoogleSQLParserZONE_SYMBOL, GoogleSQLParserDESCRIPTOR_SYMBOL, GoogleSQLParserINTERLEAVE_SYMBOL, GoogleSQLParserNULL_FILTERED_SYMBOL, GoogleSQLParserPARENT_SYMBOL, GoogleSQLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2257)
			p.Identifier()
		}


	case GoogleSQLParserLR_BRACKET_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2258)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2260)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -508611237030395904) != 0) || ((int64((_la - 66)) & ^0x3f) == 0 && ((int64(1) << (_la - 66)) & -1) != 0) || ((int64((_la - 130)) & ^0x3f) == 0 && ((int64(1) << (_la - 130)) & -1) != 0) || ((int64((_la - 194)) & ^0x3f) == 0 && ((int64(1) << (_la - 194)) & 35184372088831) != 0) || _la == GoogleSQLParserIDENTIFIER {
			{
				p.SetState(2259)
				p.Identifier()
			}

		}
		p.SetState(2263)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserPARTITION_SYMBOL {
			{
				p.SetState(2262)
				p.Partition_by_clause()
			}

		}
		p.SetState(2266)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserORDER_SYMBOL {
			{
				p.SetState(2265)
				p.Order_by_clause()
			}

		}
		p.SetState(2269)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserRANGE_SYMBOL || _la == GoogleSQLParserROWS_SYMBOL {
			{
				p.SetState(2268)
				p.Opt_window_frame_clause()
			}

		}
		{
			p.SetState(2271)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_window_frame_clauseContext is an interface to support dynamic dispatch.
type IOpt_window_frame_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Frame_unit() IFrame_unitContext
	BETWEEN_SYMBOL() antlr.TerminalNode
	AllWindow_frame_bound() []IWindow_frame_boundContext
	Window_frame_bound(i int) IWindow_frame_boundContext
	AND_SYMBOL() antlr.TerminalNode

	// IsOpt_window_frame_clauseContext differentiates from other interfaces.
	IsOpt_window_frame_clauseContext()
}

type Opt_window_frame_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_window_frame_clauseContext() *Opt_window_frame_clauseContext {
	var p = new(Opt_window_frame_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_window_frame_clause
	return p
}

func InitEmptyOpt_window_frame_clauseContext(p *Opt_window_frame_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_window_frame_clause
}

func (*Opt_window_frame_clauseContext) IsOpt_window_frame_clauseContext() {}

func NewOpt_window_frame_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_window_frame_clauseContext {
	var p = new(Opt_window_frame_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_window_frame_clause

	return p
}

func (s *Opt_window_frame_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_window_frame_clauseContext) Frame_unit() IFrame_unitContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrame_unitContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrame_unitContext)
}

func (s *Opt_window_frame_clauseContext) BETWEEN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserBETWEEN_SYMBOL, 0)
}

func (s *Opt_window_frame_clauseContext) AllWindow_frame_bound() []IWindow_frame_boundContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindow_frame_boundContext); ok {
			len++
		}
	}

	tst := make([]IWindow_frame_boundContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindow_frame_boundContext); ok {
			tst[i] = t.(IWindow_frame_boundContext)
			i++
		}
	}

	return tst
}

func (s *Opt_window_frame_clauseContext) Window_frame_bound(i int) IWindow_frame_boundContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_frame_boundContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_frame_boundContext)
}

func (s *Opt_window_frame_clauseContext) AND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAND_SYMBOL, 0)
}

func (s *Opt_window_frame_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_window_frame_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_window_frame_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_window_frame_clause(s)
	}
}

func (s *Opt_window_frame_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_window_frame_clause(s)
	}
}

func (s *Opt_window_frame_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_window_frame_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_window_frame_clause() (localctx IOpt_window_frame_clauseContext) {
	localctx = NewOpt_window_frame_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, GoogleSQLParserRULE_opt_window_frame_clause)
	p.SetState(2283)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 240, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2274)
			p.Frame_unit()
		}
		{
			p.SetState(2275)
			p.Match(GoogleSQLParserBETWEEN_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2276)
			p.Window_frame_bound()
		}
		{
			p.SetState(2277)
			p.Match(GoogleSQLParserAND_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2278)
			p.Window_frame_bound()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2280)
			p.Frame_unit()
		}
		{
			p.SetState(2281)
			p.Window_frame_bound()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindow_frame_boundContext is an interface to support dynamic dispatch.
type IWindow_frame_boundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNBOUNDED_SYMBOL() antlr.TerminalNode
	Preceding_or_following() IPreceding_or_followingContext
	CURRENT_SYMBOL() antlr.TerminalNode
	ROW_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsWindow_frame_boundContext differentiates from other interfaces.
	IsWindow_frame_boundContext()
}

type Window_frame_boundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_frame_boundContext() *Window_frame_boundContext {
	var p = new(Window_frame_boundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_window_frame_bound
	return p
}

func InitEmptyWindow_frame_boundContext(p *Window_frame_boundContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_window_frame_bound
}

func (*Window_frame_boundContext) IsWindow_frame_boundContext() {}

func NewWindow_frame_boundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_frame_boundContext {
	var p = new(Window_frame_boundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_window_frame_bound

	return p
}

func (s *Window_frame_boundContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_frame_boundContext) UNBOUNDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserUNBOUNDED_SYMBOL, 0)
}

func (s *Window_frame_boundContext) Preceding_or_following() IPreceding_or_followingContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreceding_or_followingContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreceding_or_followingContext)
}

func (s *Window_frame_boundContext) CURRENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCURRENT_SYMBOL, 0)
}

func (s *Window_frame_boundContext) ROW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserROW_SYMBOL, 0)
}

func (s *Window_frame_boundContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Window_frame_boundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_frame_boundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Window_frame_boundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterWindow_frame_bound(s)
	}
}

func (s *Window_frame_boundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitWindow_frame_bound(s)
	}
}

func (s *Window_frame_boundContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitWindow_frame_bound(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Window_frame_bound() (localctx IWindow_frame_boundContext) {
	localctx = NewWindow_frame_boundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, GoogleSQLParserRULE_window_frame_bound)
	p.SetState(2292)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 241, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2285)
			p.Match(GoogleSQLParserUNBOUNDED_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2286)
			p.Preceding_or_following()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2287)
			p.Match(GoogleSQLParserCURRENT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2288)
			p.Match(GoogleSQLParserROW_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2289)
			p.expression(0)
		}
		{
			p.SetState(2290)
			p.Preceding_or_following()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPreceding_or_followingContext is an interface to support dynamic dispatch.
type IPreceding_or_followingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRECEDING_SYMBOL() antlr.TerminalNode
	FOLLOWING_SYMBOL() antlr.TerminalNode

	// IsPreceding_or_followingContext differentiates from other interfaces.
	IsPreceding_or_followingContext()
}

type Preceding_or_followingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreceding_or_followingContext() *Preceding_or_followingContext {
	var p = new(Preceding_or_followingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_preceding_or_following
	return p
}

func InitEmptyPreceding_or_followingContext(p *Preceding_or_followingContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_preceding_or_following
}

func (*Preceding_or_followingContext) IsPreceding_or_followingContext() {}

func NewPreceding_or_followingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Preceding_or_followingContext {
	var p = new(Preceding_or_followingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_preceding_or_following

	return p
}

func (s *Preceding_or_followingContext) GetParser() antlr.Parser { return s.parser }

func (s *Preceding_or_followingContext) PRECEDING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPRECEDING_SYMBOL, 0)
}

func (s *Preceding_or_followingContext) FOLLOWING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFOLLOWING_SYMBOL, 0)
}

func (s *Preceding_or_followingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Preceding_or_followingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Preceding_or_followingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterPreceding_or_following(s)
	}
}

func (s *Preceding_or_followingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitPreceding_or_following(s)
	}
}

func (s *Preceding_or_followingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitPreceding_or_following(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Preceding_or_following() (localctx IPreceding_or_followingContext) {
	localctx = NewPreceding_or_followingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, GoogleSQLParserRULE_preceding_or_following)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2294)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GoogleSQLParserPRECEDING_SYMBOL || _la == GoogleSQLParserFOLLOWING_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFrame_unitContext is an interface to support dynamic dispatch.
type IFrame_unitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROWS_SYMBOL() antlr.TerminalNode
	RANGE_SYMBOL() antlr.TerminalNode

	// IsFrame_unitContext differentiates from other interfaces.
	IsFrame_unitContext()
}

type Frame_unitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrame_unitContext() *Frame_unitContext {
	var p = new(Frame_unitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_frame_unit
	return p
}

func InitEmptyFrame_unitContext(p *Frame_unitContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_frame_unit
}

func (*Frame_unitContext) IsFrame_unitContext() {}

func NewFrame_unitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Frame_unitContext {
	var p = new(Frame_unitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_frame_unit

	return p
}

func (s *Frame_unitContext) GetParser() antlr.Parser { return s.parser }

func (s *Frame_unitContext) ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserROWS_SYMBOL, 0)
}

func (s *Frame_unitContext) RANGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRANGE_SYMBOL, 0)
}

func (s *Frame_unitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Frame_unitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Frame_unitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterFrame_unit(s)
	}
}

func (s *Frame_unitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitFrame_unit(s)
	}
}

func (s *Frame_unitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitFrame_unit(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Frame_unit() (localctx IFrame_unitContext) {
	localctx = NewFrame_unitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, GoogleSQLParserRULE_frame_unit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2296)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GoogleSQLParserRANGE_SYMBOL || _la == GoogleSQLParserROWS_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartition_by_clauseContext is an interface to support dynamic dispatch.
type IPartition_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Partition_by_clause_prefix() IPartition_by_clause_prefixContext

	// IsPartition_by_clauseContext differentiates from other interfaces.
	IsPartition_by_clauseContext()
}

type Partition_by_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartition_by_clauseContext() *Partition_by_clauseContext {
	var p = new(Partition_by_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_partition_by_clause
	return p
}

func InitEmptyPartition_by_clauseContext(p *Partition_by_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_partition_by_clause
}

func (*Partition_by_clauseContext) IsPartition_by_clauseContext() {}

func NewPartition_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Partition_by_clauseContext {
	var p = new(Partition_by_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_partition_by_clause

	return p
}

func (s *Partition_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Partition_by_clauseContext) Partition_by_clause_prefix() IPartition_by_clause_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartition_by_clause_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartition_by_clause_prefixContext)
}

func (s *Partition_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Partition_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Partition_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterPartition_by_clause(s)
	}
}

func (s *Partition_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitPartition_by_clause(s)
	}
}

func (s *Partition_by_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitPartition_by_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Partition_by_clause() (localctx IPartition_by_clauseContext) {
	localctx = NewPartition_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, GoogleSQLParserRULE_partition_by_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2298)
		p.Partition_by_clause_prefix()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartition_by_clause_prefixContext is an interface to support dynamic dispatch.
type IPartition_by_clause_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	Hint() IHintContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsPartition_by_clause_prefixContext differentiates from other interfaces.
	IsPartition_by_clause_prefixContext()
}

type Partition_by_clause_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartition_by_clause_prefixContext() *Partition_by_clause_prefixContext {
	var p = new(Partition_by_clause_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_partition_by_clause_prefix
	return p
}

func InitEmptyPartition_by_clause_prefixContext(p *Partition_by_clause_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_partition_by_clause_prefix
}

func (*Partition_by_clause_prefixContext) IsPartition_by_clause_prefixContext() {}

func NewPartition_by_clause_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Partition_by_clause_prefixContext {
	var p = new(Partition_by_clause_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_partition_by_clause_prefix

	return p
}

func (s *Partition_by_clause_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Partition_by_clause_prefixContext) PARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPARTITION_SYMBOL, 0)
}

func (s *Partition_by_clause_prefixContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserBY_SYMBOL, 0)
}

func (s *Partition_by_clause_prefixContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Partition_by_clause_prefixContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Partition_by_clause_prefixContext) Hint() IHintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintContext)
}

func (s *Partition_by_clause_prefixContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Partition_by_clause_prefixContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Partition_by_clause_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Partition_by_clause_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Partition_by_clause_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterPartition_by_clause_prefix(s)
	}
}

func (s *Partition_by_clause_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitPartition_by_clause_prefix(s)
	}
}

func (s *Partition_by_clause_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitPartition_by_clause_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Partition_by_clause_prefix() (localctx IPartition_by_clause_prefixContext) {
	localctx = NewPartition_by_clause_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, GoogleSQLParserRULE_partition_by_clause_prefix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2300)
		p.Match(GoogleSQLParserPARTITION_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2302)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserAT_SYMBOL {
		{
			p.SetState(2301)
			p.Hint()
		}

	}
	{
		p.SetState(2304)
		p.Match(GoogleSQLParserBY_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2305)
		p.expression(0)
	}
	p.SetState(2310)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(2306)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2307)
			p.expression(0)
		}


		p.SetState(2312)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWith_group_rowsContext is an interface to support dynamic dispatch.
type IWith_group_rowsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	GROUP_SYMBOL() antlr.TerminalNode
	ROWS_SYMBOL() antlr.TerminalNode

	// IsWith_group_rowsContext differentiates from other interfaces.
	IsWith_group_rowsContext()
}

type With_group_rowsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_group_rowsContext() *With_group_rowsContext {
	var p = new(With_group_rowsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_with_group_rows
	return p
}

func InitEmptyWith_group_rowsContext(p *With_group_rowsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_with_group_rows
}

func (*With_group_rowsContext) IsWith_group_rowsContext() {}

func NewWith_group_rowsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_group_rowsContext {
	var p = new(With_group_rowsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_with_group_rows

	return p
}

func (s *With_group_rowsContext) GetParser() antlr.Parser { return s.parser }

func (s *With_group_rowsContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWITH_SYMBOL, 0)
}

func (s *With_group_rowsContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserGROUP_SYMBOL, 0)
}

func (s *With_group_rowsContext) ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserROWS_SYMBOL, 0)
}

func (s *With_group_rowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_group_rowsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *With_group_rowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterWith_group_rows(s)
	}
}

func (s *With_group_rowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitWith_group_rows(s)
	}
}

func (s *With_group_rowsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitWith_group_rows(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) With_group_rows() (localctx IWith_group_rowsContext) {
	localctx = NewWith_group_rowsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, GoogleSQLParserRULE_with_group_rows)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2313)
		p.Match(GoogleSQLParserWITH_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2314)
		p.Match(GoogleSQLParserGROUP_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2315)
		p.Match(GoogleSQLParserROWS_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWith_report_modifierContext is an interface to support dynamic dispatch.
type IWith_report_modifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	REPORT_SYMBOL() antlr.TerminalNode
	With_report_format() IWith_report_formatContext

	// IsWith_report_modifierContext differentiates from other interfaces.
	IsWith_report_modifierContext()
}

type With_report_modifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_report_modifierContext() *With_report_modifierContext {
	var p = new(With_report_modifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_with_report_modifier
	return p
}

func InitEmptyWith_report_modifierContext(p *With_report_modifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_with_report_modifier
}

func (*With_report_modifierContext) IsWith_report_modifierContext() {}

func NewWith_report_modifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_report_modifierContext {
	var p = new(With_report_modifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_with_report_modifier

	return p
}

func (s *With_report_modifierContext) GetParser() antlr.Parser { return s.parser }

func (s *With_report_modifierContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWITH_SYMBOL, 0)
}

func (s *With_report_modifierContext) REPORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserREPORT_SYMBOL, 0)
}

func (s *With_report_modifierContext) With_report_format() IWith_report_formatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_report_formatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_report_formatContext)
}

func (s *With_report_modifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_report_modifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *With_report_modifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterWith_report_modifier(s)
	}
}

func (s *With_report_modifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitWith_report_modifier(s)
	}
}

func (s *With_report_modifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitWith_report_modifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) With_report_modifier() (localctx IWith_report_modifierContext) {
	localctx = NewWith_report_modifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, GoogleSQLParserRULE_with_report_modifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2317)
		p.Match(GoogleSQLParserWITH_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2318)
		p.Match(GoogleSQLParserREPORT_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2319)
		p.With_report_format()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IClamped_between_modifierContext is an interface to support dynamic dispatch.
type IClamped_between_modifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLAMPED_SYMBOL() antlr.TerminalNode
	Expression_higher_prec_than_and() IExpression_higher_prec_than_andContext
	AND_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsClamped_between_modifierContext differentiates from other interfaces.
	IsClamped_between_modifierContext()
}

type Clamped_between_modifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClamped_between_modifierContext() *Clamped_between_modifierContext {
	var p = new(Clamped_between_modifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_clamped_between_modifier
	return p
}

func InitEmptyClamped_between_modifierContext(p *Clamped_between_modifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_clamped_between_modifier
}

func (*Clamped_between_modifierContext) IsClamped_between_modifierContext() {}

func NewClamped_between_modifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Clamped_between_modifierContext {
	var p = new(Clamped_between_modifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_clamped_between_modifier

	return p
}

func (s *Clamped_between_modifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Clamped_between_modifierContext) CLAMPED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCLAMPED_SYMBOL, 0)
}

func (s *Clamped_between_modifierContext) Expression_higher_prec_than_and() IExpression_higher_prec_than_andContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpression_higher_prec_than_andContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpression_higher_prec_than_andContext)
}

func (s *Clamped_between_modifierContext) AND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAND_SYMBOL, 0)
}

func (s *Clamped_between_modifierContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Clamped_between_modifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Clamped_between_modifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Clamped_between_modifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterClamped_between_modifier(s)
	}
}

func (s *Clamped_between_modifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitClamped_between_modifier(s)
	}
}

func (s *Clamped_between_modifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitClamped_between_modifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Clamped_between_modifier() (localctx IClamped_between_modifierContext) {
	localctx = NewClamped_between_modifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, GoogleSQLParserRULE_clamped_between_modifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2321)
		p.Match(GoogleSQLParserCLAMPED_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2322)
		p.Expression_higher_prec_than_and()
	}
	{
		p.SetState(2323)
		p.Match(GoogleSQLParserAND_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2324)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWith_report_formatContext is an interface to support dynamic dispatch.
type IWith_report_formatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Options_list() IOptions_listContext

	// IsWith_report_formatContext differentiates from other interfaces.
	IsWith_report_formatContext()
}

type With_report_formatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_report_formatContext() *With_report_formatContext {
	var p = new(With_report_formatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_with_report_format
	return p
}

func InitEmptyWith_report_formatContext(p *With_report_formatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_with_report_format
}

func (*With_report_formatContext) IsWith_report_formatContext() {}

func NewWith_report_formatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_report_formatContext {
	var p = new(With_report_formatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_with_report_format

	return p
}

func (s *With_report_formatContext) GetParser() antlr.Parser { return s.parser }

func (s *With_report_formatContext) Options_list() IOptions_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptions_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptions_listContext)
}

func (s *With_report_formatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_report_formatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *With_report_formatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterWith_report_format(s)
	}
}

func (s *With_report_formatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitWith_report_format(s)
	}
}

func (s *With_report_formatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitWith_report_format(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) With_report_format() (localctx IWith_report_formatContext) {
	localctx = NewWith_report_formatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, GoogleSQLParserRULE_with_report_format)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2326)
		p.Options_list()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOptions_listContext is an interface to support dynamic dispatch.
type IOptions_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Options_list_prefix() IOptions_list_prefixContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsOptions_listContext differentiates from other interfaces.
	IsOptions_listContext()
}

type Options_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptions_listContext() *Options_listContext {
	var p = new(Options_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_options_list
	return p
}

func InitEmptyOptions_listContext(p *Options_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_options_list
}

func (*Options_listContext) IsOptions_listContext() {}

func NewOptions_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Options_listContext {
	var p = new(Options_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_options_list

	return p
}

func (s *Options_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Options_listContext) Options_list_prefix() IOptions_list_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptions_list_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptions_list_prefixContext)
}

func (s *Options_listContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Options_listContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Options_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Options_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Options_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOptions_list(s)
	}
}

func (s *Options_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOptions_list(s)
	}
}

func (s *Options_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOptions_list(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Options_list() (localctx IOptions_listContext) {
	localctx = NewOptions_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, GoogleSQLParserRULE_options_list)
	p.SetState(2333)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 244, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2328)
			p.Options_list_prefix()
		}
		{
			p.SetState(2329)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2331)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2332)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOptions_list_prefixContext is an interface to support dynamic dispatch.
type IOptions_list_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	AllOptions_entry() []IOptions_entryContext
	Options_entry(i int) IOptions_entryContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsOptions_list_prefixContext differentiates from other interfaces.
	IsOptions_list_prefixContext()
}

type Options_list_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptions_list_prefixContext() *Options_list_prefixContext {
	var p = new(Options_list_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_options_list_prefix
	return p
}

func InitEmptyOptions_list_prefixContext(p *Options_list_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_options_list_prefix
}

func (*Options_list_prefixContext) IsOptions_list_prefixContext() {}

func NewOptions_list_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Options_list_prefixContext {
	var p = new(Options_list_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_options_list_prefix

	return p
}

func (s *Options_list_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Options_list_prefixContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Options_list_prefixContext) AllOptions_entry() []IOptions_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOptions_entryContext); ok {
			len++
		}
	}

	tst := make([]IOptions_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOptions_entryContext); ok {
			tst[i] = t.(IOptions_entryContext)
			i++
		}
	}

	return tst
}

func (s *Options_list_prefixContext) Options_entry(i int) IOptions_entryContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptions_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptions_entryContext)
}

func (s *Options_list_prefixContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Options_list_prefixContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Options_list_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Options_list_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Options_list_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOptions_list_prefix(s)
	}
}

func (s *Options_list_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOptions_list_prefix(s)
	}
}

func (s *Options_list_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOptions_list_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Options_list_prefix() (localctx IOptions_list_prefixContext) {
	localctx = NewOptions_list_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, GoogleSQLParserRULE_options_list_prefix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2335)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2336)
		p.Options_entry()
	}
	p.SetState(2341)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(2337)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2338)
			p.Options_entry()
		}


		p.SetState(2343)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOptions_entryContext is an interface to support dynamic dispatch.
type IOptions_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier_in_hints() IIdentifier_in_hintsContext
	Options_assignment_operator() IOptions_assignment_operatorContext
	Expression_or_proto() IExpression_or_protoContext

	// IsOptions_entryContext differentiates from other interfaces.
	IsOptions_entryContext()
}

type Options_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptions_entryContext() *Options_entryContext {
	var p = new(Options_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_options_entry
	return p
}

func InitEmptyOptions_entryContext(p *Options_entryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_options_entry
}

func (*Options_entryContext) IsOptions_entryContext() {}

func NewOptions_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Options_entryContext {
	var p = new(Options_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_options_entry

	return p
}

func (s *Options_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Options_entryContext) Identifier_in_hints() IIdentifier_in_hintsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifier_in_hintsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifier_in_hintsContext)
}

func (s *Options_entryContext) Options_assignment_operator() IOptions_assignment_operatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptions_assignment_operatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptions_assignment_operatorContext)
}

func (s *Options_entryContext) Expression_or_proto() IExpression_or_protoContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpression_or_protoContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpression_or_protoContext)
}

func (s *Options_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Options_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Options_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOptions_entry(s)
	}
}

func (s *Options_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOptions_entry(s)
	}
}

func (s *Options_entryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOptions_entry(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Options_entry() (localctx IOptions_entryContext) {
	localctx = NewOptions_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, GoogleSQLParserRULE_options_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2344)
		p.Identifier_in_hints()
	}
	{
		p.SetState(2345)
		p.Options_assignment_operator()
	}
	{
		p.SetState(2346)
		p.Expression_or_proto()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpression_or_protoContext is an interface to support dynamic dispatch.
type IExpression_or_protoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROTO_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsExpression_or_protoContext differentiates from other interfaces.
	IsExpression_or_protoContext()
}

type Expression_or_protoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_or_protoContext() *Expression_or_protoContext {
	var p = new(Expression_or_protoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_expression_or_proto
	return p
}

func InitEmptyExpression_or_protoContext(p *Expression_or_protoContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_expression_or_proto
}

func (*Expression_or_protoContext) IsExpression_or_protoContext() {}

func NewExpression_or_protoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_or_protoContext {
	var p = new(Expression_or_protoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_expression_or_proto

	return p
}

func (s *Expression_or_protoContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_or_protoContext) PROTO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPROTO_SYMBOL, 0)
}

func (s *Expression_or_protoContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expression_or_protoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_or_protoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expression_or_protoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterExpression_or_proto(s)
	}
}

func (s *Expression_or_protoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitExpression_or_proto(s)
	}
}

func (s *Expression_or_protoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitExpression_or_proto(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Expression_or_proto() (localctx IExpression_or_protoContext) {
	localctx = NewExpression_or_protoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, GoogleSQLParserRULE_expression_or_proto)
	p.SetState(2350)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 246, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2348)
			p.Match(GoogleSQLParserPROTO_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2349)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOptions_assignment_operatorContext is an interface to support dynamic dispatch.
type IOptions_assignment_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL_SYMBOL() antlr.TerminalNode
	PLUS_EQUAL_SYMBOL() antlr.TerminalNode
	SUB_EQUAL_SYMBOL() antlr.TerminalNode

	// IsOptions_assignment_operatorContext differentiates from other interfaces.
	IsOptions_assignment_operatorContext()
}

type Options_assignment_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptions_assignment_operatorContext() *Options_assignment_operatorContext {
	var p = new(Options_assignment_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_options_assignment_operator
	return p
}

func InitEmptyOptions_assignment_operatorContext(p *Options_assignment_operatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_options_assignment_operator
}

func (*Options_assignment_operatorContext) IsOptions_assignment_operatorContext() {}

func NewOptions_assignment_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Options_assignment_operatorContext {
	var p = new(Options_assignment_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_options_assignment_operator

	return p
}

func (s *Options_assignment_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Options_assignment_operatorContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEQUAL_SYMBOL, 0)
}

func (s *Options_assignment_operatorContext) PLUS_EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPLUS_EQUAL_SYMBOL, 0)
}

func (s *Options_assignment_operatorContext) SUB_EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSUB_EQUAL_SYMBOL, 0)
}

func (s *Options_assignment_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Options_assignment_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Options_assignment_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOptions_assignment_operator(s)
	}
}

func (s *Options_assignment_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOptions_assignment_operator(s)
	}
}

func (s *Options_assignment_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOptions_assignment_operator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Options_assignment_operator() (localctx IOptions_assignment_operatorContext) {
	localctx = NewOptions_assignment_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, GoogleSQLParserRULE_options_assignment_operator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2352)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 284)) & ^0x3f) == 0 && ((int64(1) << (_la - 284)) & 25165825) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_null_handling_modifierContext is an interface to support dynamic dispatch.
type IOpt_null_handling_modifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IGNORE_SYMBOL() antlr.TerminalNode
	NULLS_SYMBOL() antlr.TerminalNode
	RESPECT_SYMBOL() antlr.TerminalNode

	// IsOpt_null_handling_modifierContext differentiates from other interfaces.
	IsOpt_null_handling_modifierContext()
}

type Opt_null_handling_modifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_null_handling_modifierContext() *Opt_null_handling_modifierContext {
	var p = new(Opt_null_handling_modifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_null_handling_modifier
	return p
}

func InitEmptyOpt_null_handling_modifierContext(p *Opt_null_handling_modifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_null_handling_modifier
}

func (*Opt_null_handling_modifierContext) IsOpt_null_handling_modifierContext() {}

func NewOpt_null_handling_modifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_null_handling_modifierContext {
	var p = new(Opt_null_handling_modifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_null_handling_modifier

	return p
}

func (s *Opt_null_handling_modifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_null_handling_modifierContext) IGNORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserIGNORE_SYMBOL, 0)
}

func (s *Opt_null_handling_modifierContext) NULLS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserNULLS_SYMBOL, 0)
}

func (s *Opt_null_handling_modifierContext) RESPECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRESPECT_SYMBOL, 0)
}

func (s *Opt_null_handling_modifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_null_handling_modifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_null_handling_modifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_null_handling_modifier(s)
	}
}

func (s *Opt_null_handling_modifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_null_handling_modifier(s)
	}
}

func (s *Opt_null_handling_modifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_null_handling_modifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_null_handling_modifier() (localctx IOpt_null_handling_modifierContext) {
	localctx = NewOpt_null_handling_modifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, GoogleSQLParserRULE_opt_null_handling_modifier)
	p.SetState(2358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserIGNORE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2354)
			p.Match(GoogleSQLParserIGNORE_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2355)
			p.Match(GoogleSQLParserNULLS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case GoogleSQLParserRESPECT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2356)
			p.Match(GoogleSQLParserRESPECT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2357)
			p.Match(GoogleSQLParserNULLS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunction_call_expression_with_args_prefixContext is an interface to support dynamic dispatch.
type IFunction_call_expression_with_args_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMA_SYMBOL() antlr.TerminalNode
	Function_call_argument() IFunction_call_argumentContext

	// IsFunction_call_expression_with_args_prefixContext differentiates from other interfaces.
	IsFunction_call_expression_with_args_prefixContext()
}

type Function_call_expression_with_args_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_call_expression_with_args_prefixContext() *Function_call_expression_with_args_prefixContext {
	var p = new(Function_call_expression_with_args_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_function_call_expression_with_args_prefix
	return p
}

func InitEmptyFunction_call_expression_with_args_prefixContext(p *Function_call_expression_with_args_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_function_call_expression_with_args_prefix
}

func (*Function_call_expression_with_args_prefixContext) IsFunction_call_expression_with_args_prefixContext() {}

func NewFunction_call_expression_with_args_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_call_expression_with_args_prefixContext {
	var p = new(Function_call_expression_with_args_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_function_call_expression_with_args_prefix

	return p
}

func (s *Function_call_expression_with_args_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_call_expression_with_args_prefixContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, 0)
}

func (s *Function_call_expression_with_args_prefixContext) Function_call_argument() IFunction_call_argumentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_call_argumentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_call_argumentContext)
}

func (s *Function_call_expression_with_args_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_call_expression_with_args_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Function_call_expression_with_args_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterFunction_call_expression_with_args_prefix(s)
	}
}

func (s *Function_call_expression_with_args_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitFunction_call_expression_with_args_prefix(s)
	}
}

func (s *Function_call_expression_with_args_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitFunction_call_expression_with_args_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Function_call_expression_with_args_prefix() (localctx IFunction_call_expression_with_args_prefixContext) {
	localctx = NewFunction_call_expression_with_args_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, GoogleSQLParserRULE_function_call_expression_with_args_prefix)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2360)
		p.Match(GoogleSQLParserCOMMA_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2361)
		p.Function_call_argument()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunction_call_argumentContext is an interface to support dynamic dispatch.
type IFunction_call_argumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Named_argument() INamed_argumentContext
	Opt_as_alias_with_required_as() IOpt_as_alias_with_required_asContext
	Lambda_argument() ILambda_argumentContext
	Sequence_arg() ISequence_argContext
	SELECT_SYMBOL() antlr.TerminalNode

	// IsFunction_call_argumentContext differentiates from other interfaces.
	IsFunction_call_argumentContext()
}

type Function_call_argumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_call_argumentContext() *Function_call_argumentContext {
	var p = new(Function_call_argumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_function_call_argument
	return p
}

func InitEmptyFunction_call_argumentContext(p *Function_call_argumentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_function_call_argument
}

func (*Function_call_argumentContext) IsFunction_call_argumentContext() {}

func NewFunction_call_argumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_call_argumentContext {
	var p = new(Function_call_argumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_function_call_argument

	return p
}

func (s *Function_call_argumentContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_call_argumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Function_call_argumentContext) Named_argument() INamed_argumentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_argumentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_argumentContext)
}

func (s *Function_call_argumentContext) Opt_as_alias_with_required_as() IOpt_as_alias_with_required_asContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_as_alias_with_required_asContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_as_alias_with_required_asContext)
}

func (s *Function_call_argumentContext) Lambda_argument() ILambda_argumentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambda_argumentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambda_argumentContext)
}

func (s *Function_call_argumentContext) Sequence_arg() ISequence_argContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequence_argContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequence_argContext)
}

func (s *Function_call_argumentContext) SELECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSELECT_SYMBOL, 0)
}

func (s *Function_call_argumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_call_argumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Function_call_argumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterFunction_call_argument(s)
	}
}

func (s *Function_call_argumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitFunction_call_argument(s)
	}
}

func (s *Function_call_argumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitFunction_call_argument(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Function_call_argument() (localctx IFunction_call_argumentContext) {
	localctx = NewFunction_call_argumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, GoogleSQLParserRULE_function_call_argument)
	var _la int

	p.SetState(2373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 249, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2363)
			p.expression(0)
		}
		p.SetState(2365)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserAS_SYMBOL {
			{
				p.SetState(2364)
				p.Opt_as_alias_with_required_as()
			}

		}
		{
			p.SetState(2367)
			p.Named_argument()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2369)
			p.Lambda_argument()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2370)
			p.Sequence_arg()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2371)
			p.Match(GoogleSQLParserSELECT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		 p.NotifyErrorListeners("Each function argument
			 is an expression, not a query; to use a " "query as an expression, the query must be wrapped
			 with additional " "parentheses to make it a scalar subquery expression", nil, nil); 

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISequence_argContext is an interface to support dynamic dispatch.
type ISequence_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEQUENCE_SYMBOL() antlr.TerminalNode
	Path_expression() IPath_expressionContext

	// IsSequence_argContext differentiates from other interfaces.
	IsSequence_argContext()
}

type Sequence_argContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_argContext() *Sequence_argContext {
	var p = new(Sequence_argContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_sequence_arg
	return p
}

func InitEmptySequence_argContext(p *Sequence_argContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_sequence_arg
}

func (*Sequence_argContext) IsSequence_argContext() {}

func NewSequence_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_argContext {
	var p = new(Sequence_argContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_sequence_arg

	return p
}

func (s *Sequence_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_argContext) SEQUENCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSEQUENCE_SYMBOL, 0)
}

func (s *Sequence_argContext) Path_expression() IPath_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPath_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPath_expressionContext)
}

func (s *Sequence_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Sequence_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSequence_arg(s)
	}
}

func (s *Sequence_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSequence_arg(s)
	}
}

func (s *Sequence_argContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSequence_arg(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Sequence_arg() (localctx ISequence_argContext) {
	localctx = NewSequence_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, GoogleSQLParserRULE_sequence_arg)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2375)
		p.Match(GoogleSQLParserSEQUENCE_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2376)
		p.path_expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INamed_argumentContext is an interface to support dynamic dispatch.
type INamed_argumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQUAL_GT_BRACKET_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext
	Lambda_argument() ILambda_argumentContext

	// IsNamed_argumentContext differentiates from other interfaces.
	IsNamed_argumentContext()
}

type Named_argumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_argumentContext() *Named_argumentContext {
	var p = new(Named_argumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_named_argument
	return p
}

func InitEmptyNamed_argumentContext(p *Named_argumentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_named_argument
}

func (*Named_argumentContext) IsNamed_argumentContext() {}

func NewNamed_argumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_argumentContext {
	var p = new(Named_argumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_named_argument

	return p
}

func (s *Named_argumentContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_argumentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Named_argumentContext) EQUAL_GT_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEQUAL_GT_BRACKET_SYMBOL, 0)
}

func (s *Named_argumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Named_argumentContext) Lambda_argument() ILambda_argumentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambda_argumentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambda_argumentContext)
}

func (s *Named_argumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_argumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Named_argumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterNamed_argument(s)
	}
}

func (s *Named_argumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitNamed_argument(s)
	}
}

func (s *Named_argumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitNamed_argument(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Named_argument() (localctx INamed_argumentContext) {
	localctx = NewNamed_argumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, GoogleSQLParserRULE_named_argument)
	p.SetState(2386)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 250, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2378)
			p.Identifier()
		}
		{
			p.SetState(2379)
			p.Match(GoogleSQLParserEQUAL_GT_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2380)
			p.expression(0)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2382)
			p.Identifier()
		}
		{
			p.SetState(2383)
			p.Match(GoogleSQLParserEQUAL_GT_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2384)
			p.Lambda_argument()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILambda_argumentContext is an interface to support dynamic dispatch.
type ILambda_argumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Lambda_argument_list() ILambda_argument_listContext
	SUB_GT_BRACKET_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsLambda_argumentContext differentiates from other interfaces.
	IsLambda_argumentContext()
}

type Lambda_argumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambda_argumentContext() *Lambda_argumentContext {
	var p = new(Lambda_argumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_lambda_argument
	return p
}

func InitEmptyLambda_argumentContext(p *Lambda_argumentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_lambda_argument
}

func (*Lambda_argumentContext) IsLambda_argumentContext() {}

func NewLambda_argumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lambda_argumentContext {
	var p = new(Lambda_argumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_lambda_argument

	return p
}

func (s *Lambda_argumentContext) GetParser() antlr.Parser { return s.parser }

func (s *Lambda_argumentContext) Lambda_argument_list() ILambda_argument_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambda_argument_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambda_argument_listContext)
}

func (s *Lambda_argumentContext) SUB_GT_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSUB_GT_BRACKET_SYMBOL, 0)
}

func (s *Lambda_argumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Lambda_argumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lambda_argumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Lambda_argumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterLambda_argument(s)
	}
}

func (s *Lambda_argumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitLambda_argument(s)
	}
}

func (s *Lambda_argumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitLambda_argument(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Lambda_argument() (localctx ILambda_argumentContext) {
	localctx = NewLambda_argumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, GoogleSQLParserRULE_lambda_argument)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2388)
		p.Lambda_argument_list()
	}
	{
		p.SetState(2389)
		p.Match(GoogleSQLParserSUB_GT_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2390)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILambda_argument_listContext is an interface to support dynamic dispatch.
type ILambda_argument_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	RR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsLambda_argument_listContext differentiates from other interfaces.
	IsLambda_argument_listContext()
}

type Lambda_argument_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambda_argument_listContext() *Lambda_argument_listContext {
	var p = new(Lambda_argument_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_lambda_argument_list
	return p
}

func InitEmptyLambda_argument_listContext(p *Lambda_argument_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_lambda_argument_list
}

func (*Lambda_argument_listContext) IsLambda_argument_listContext() {}

func NewLambda_argument_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lambda_argument_listContext {
	var p = new(Lambda_argument_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_lambda_argument_list

	return p
}

func (s *Lambda_argument_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Lambda_argument_listContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Lambda_argument_listContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Lambda_argument_listContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Lambda_argument_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lambda_argument_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Lambda_argument_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterLambda_argument_list(s)
	}
}

func (s *Lambda_argument_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitLambda_argument_list(s)
	}
}

func (s *Lambda_argument_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitLambda_argument_list(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Lambda_argument_list() (localctx ILambda_argument_listContext) {
	localctx = NewLambda_argument_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, GoogleSQLParserRULE_lambda_argument_list)
	p.SetState(2395)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 251, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2392)
			p.expression(0)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2393)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2394)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILimit_offset_clauseContext is an interface to support dynamic dispatch.
type ILimit_offset_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT_SYMBOL() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	OFFSET_SYMBOL() antlr.TerminalNode

	// IsLimit_offset_clauseContext differentiates from other interfaces.
	IsLimit_offset_clauseContext()
}

type Limit_offset_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimit_offset_clauseContext() *Limit_offset_clauseContext {
	var p = new(Limit_offset_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_limit_offset_clause
	return p
}

func InitEmptyLimit_offset_clauseContext(p *Limit_offset_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_limit_offset_clause
}

func (*Limit_offset_clauseContext) IsLimit_offset_clauseContext() {}

func NewLimit_offset_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Limit_offset_clauseContext {
	var p = new(Limit_offset_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_limit_offset_clause

	return p
}

func (s *Limit_offset_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Limit_offset_clauseContext) LIMIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLIMIT_SYMBOL, 0)
}

func (s *Limit_offset_clauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Limit_offset_clauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Limit_offset_clauseContext) OFFSET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserOFFSET_SYMBOL, 0)
}

func (s *Limit_offset_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Limit_offset_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Limit_offset_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterLimit_offset_clause(s)
	}
}

func (s *Limit_offset_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitLimit_offset_clause(s)
	}
}

func (s *Limit_offset_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitLimit_offset_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Limit_offset_clause() (localctx ILimit_offset_clauseContext) {
	localctx = NewLimit_offset_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, GoogleSQLParserRULE_limit_offset_clause)
	p.SetState(2404)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 252, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2397)
			p.Match(GoogleSQLParserLIMIT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2398)
			p.expression(0)
		}
		{
			p.SetState(2399)
			p.Match(GoogleSQLParserOFFSET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2400)
			p.expression(0)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2402)
			p.Match(GoogleSQLParserLIMIT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2403)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_having_or_group_by_modifierContext is an interface to support dynamic dispatch.
type IOpt_having_or_group_by_modifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HAVING_SYMBOL() antlr.TerminalNode
	MAX_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext
	MIN_SYMBOL() antlr.TerminalNode
	Group_by_clause_prefix() IGroup_by_clause_prefixContext

	// IsOpt_having_or_group_by_modifierContext differentiates from other interfaces.
	IsOpt_having_or_group_by_modifierContext()
}

type Opt_having_or_group_by_modifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_having_or_group_by_modifierContext() *Opt_having_or_group_by_modifierContext {
	var p = new(Opt_having_or_group_by_modifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_having_or_group_by_modifier
	return p
}

func InitEmptyOpt_having_or_group_by_modifierContext(p *Opt_having_or_group_by_modifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_having_or_group_by_modifier
}

func (*Opt_having_or_group_by_modifierContext) IsOpt_having_or_group_by_modifierContext() {}

func NewOpt_having_or_group_by_modifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_having_or_group_by_modifierContext {
	var p = new(Opt_having_or_group_by_modifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_having_or_group_by_modifier

	return p
}

func (s *Opt_having_or_group_by_modifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_having_or_group_by_modifierContext) HAVING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserHAVING_SYMBOL, 0)
}

func (s *Opt_having_or_group_by_modifierContext) MAX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMAX_SYMBOL, 0)
}

func (s *Opt_having_or_group_by_modifierContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Opt_having_or_group_by_modifierContext) MIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMIN_SYMBOL, 0)
}

func (s *Opt_having_or_group_by_modifierContext) Group_by_clause_prefix() IGroup_by_clause_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroup_by_clause_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroup_by_clause_prefixContext)
}

func (s *Opt_having_or_group_by_modifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_having_or_group_by_modifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_having_or_group_by_modifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_having_or_group_by_modifier(s)
	}
}

func (s *Opt_having_or_group_by_modifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_having_or_group_by_modifier(s)
	}
}

func (s *Opt_having_or_group_by_modifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_having_or_group_by_modifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_having_or_group_by_modifier() (localctx IOpt_having_or_group_by_modifierContext) {
	localctx = NewOpt_having_or_group_by_modifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, GoogleSQLParserRULE_opt_having_or_group_by_modifier)
	p.SetState(2414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 253, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2406)
			p.Match(GoogleSQLParserHAVING_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2407)
			p.Match(GoogleSQLParserMAX_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2408)
			p.expression(0)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2409)
			p.Match(GoogleSQLParserHAVING_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2410)
			p.Match(GoogleSQLParserMIN_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2411)
			p.expression(0)
		}
		{
			p.SetState(2412)
			p.Group_by_clause_prefix()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGroup_by_clause_prefixContext is an interface to support dynamic dispatch.
type IGroup_by_clause_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Group_by_preamble() IGroup_by_preambleContext
	AllGrouping_item() []IGrouping_itemContext
	Grouping_item(i int) IGrouping_itemContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsGroup_by_clause_prefixContext differentiates from other interfaces.
	IsGroup_by_clause_prefixContext()
}

type Group_by_clause_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_by_clause_prefixContext() *Group_by_clause_prefixContext {
	var p = new(Group_by_clause_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_group_by_clause_prefix
	return p
}

func InitEmptyGroup_by_clause_prefixContext(p *Group_by_clause_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_group_by_clause_prefix
}

func (*Group_by_clause_prefixContext) IsGroup_by_clause_prefixContext() {}

func NewGroup_by_clause_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_by_clause_prefixContext {
	var p = new(Group_by_clause_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_group_by_clause_prefix

	return p
}

func (s *Group_by_clause_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_by_clause_prefixContext) Group_by_preamble() IGroup_by_preambleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroup_by_preambleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroup_by_preambleContext)
}

func (s *Group_by_clause_prefixContext) AllGrouping_item() []IGrouping_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGrouping_itemContext); ok {
			len++
		}
	}

	tst := make([]IGrouping_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGrouping_itemContext); ok {
			tst[i] = t.(IGrouping_itemContext)
			i++
		}
	}

	return tst
}

func (s *Group_by_clause_prefixContext) Grouping_item(i int) IGrouping_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrouping_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrouping_itemContext)
}

func (s *Group_by_clause_prefixContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Group_by_clause_prefixContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Group_by_clause_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_by_clause_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Group_by_clause_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterGroup_by_clause_prefix(s)
	}
}

func (s *Group_by_clause_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitGroup_by_clause_prefix(s)
	}
}

func (s *Group_by_clause_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitGroup_by_clause_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Group_by_clause_prefix() (localctx IGroup_by_clause_prefixContext) {
	localctx = NewGroup_by_clause_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, GoogleSQLParserRULE_group_by_clause_prefix)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2416)
		p.Group_by_preamble()
	}
	{
		p.SetState(2417)
		p.Grouping_item()
	}
	p.SetState(2422)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 254, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2418)
				p.Match(GoogleSQLParserCOMMA_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2419)
				p.Grouping_item()
			}


		}
		p.SetState(2424)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 254, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGroup_by_preambleContext is an interface to support dynamic dispatch.
type IGroup_by_preambleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	Hint() IHintContext
	Opt_and_order() IOpt_and_orderContext

	// IsGroup_by_preambleContext differentiates from other interfaces.
	IsGroup_by_preambleContext()
}

type Group_by_preambleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_by_preambleContext() *Group_by_preambleContext {
	var p = new(Group_by_preambleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_group_by_preamble
	return p
}

func InitEmptyGroup_by_preambleContext(p *Group_by_preambleContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_group_by_preamble
}

func (*Group_by_preambleContext) IsGroup_by_preambleContext() {}

func NewGroup_by_preambleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_by_preambleContext {
	var p = new(Group_by_preambleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_group_by_preamble

	return p
}

func (s *Group_by_preambleContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_by_preambleContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserGROUP_SYMBOL, 0)
}

func (s *Group_by_preambleContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserBY_SYMBOL, 0)
}

func (s *Group_by_preambleContext) Hint() IHintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintContext)
}

func (s *Group_by_preambleContext) Opt_and_order() IOpt_and_orderContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_and_orderContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_and_orderContext)
}

func (s *Group_by_preambleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_by_preambleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Group_by_preambleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterGroup_by_preamble(s)
	}
}

func (s *Group_by_preambleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitGroup_by_preamble(s)
	}
}

func (s *Group_by_preambleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitGroup_by_preamble(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Group_by_preamble() (localctx IGroup_by_preambleContext) {
	localctx = NewGroup_by_preambleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, GoogleSQLParserRULE_group_by_preamble)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2425)
		p.Match(GoogleSQLParserGROUP_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2427)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserAT_SYMBOL {
		{
			p.SetState(2426)
			p.Hint()
		}

	}
	p.SetState(2430)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserAND_SYMBOL {
		{
			p.SetState(2429)
			p.Opt_and_order()
		}

	}
	{
		p.SetState(2432)
		p.Match(GoogleSQLParserBY_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_and_orderContext is an interface to support dynamic dispatch.
type IOpt_and_orderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AND_SYMBOL() antlr.TerminalNode
	ORDER_SYMBOL() antlr.TerminalNode

	// IsOpt_and_orderContext differentiates from other interfaces.
	IsOpt_and_orderContext()
}

type Opt_and_orderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_and_orderContext() *Opt_and_orderContext {
	var p = new(Opt_and_orderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_and_order
	return p
}

func InitEmptyOpt_and_orderContext(p *Opt_and_orderContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_and_order
}

func (*Opt_and_orderContext) IsOpt_and_orderContext() {}

func NewOpt_and_orderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_and_orderContext {
	var p = new(Opt_and_orderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_and_order

	return p
}

func (s *Opt_and_orderContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_and_orderContext) AND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAND_SYMBOL, 0)
}

func (s *Opt_and_orderContext) ORDER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserORDER_SYMBOL, 0)
}

func (s *Opt_and_orderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_and_orderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_and_orderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_and_order(s)
	}
}

func (s *Opt_and_orderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_and_order(s)
	}
}

func (s *Opt_and_orderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_and_order(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_and_order() (localctx IOpt_and_orderContext) {
	localctx = NewOpt_and_orderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, GoogleSQLParserRULE_opt_and_order)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2434)
		p.Match(GoogleSQLParserAND_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2435)
		p.Match(GoogleSQLParserORDER_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHintContext is an interface to support dynamic dispatch.
type IHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT_SYMBOL() antlr.TerminalNode
	Integer_literal() IInteger_literalContext
	Hint_with_body() IHint_with_bodyContext

	// IsHintContext differentiates from other interfaces.
	IsHintContext()
}

type HintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHintContext() *HintContext {
	var p = new(HintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_hint
	return p
}

func InitEmptyHintContext(p *HintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_hint
}

func (*HintContext) IsHintContext() {}

func NewHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintContext {
	var p = new(HintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_hint

	return p
}

func (s *HintContext) GetParser() antlr.Parser { return s.parser }

func (s *HintContext) AT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAT_SYMBOL, 0)
}

func (s *HintContext) Integer_literal() IInteger_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInteger_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInteger_literalContext)
}

func (s *HintContext) Hint_with_body() IHint_with_bodyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHint_with_bodyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHint_with_bodyContext)
}

func (s *HintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterHint(s)
	}
}

func (s *HintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitHint(s)
	}
}

func (s *HintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitHint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Hint() (localctx IHintContext) {
	localctx = NewHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, GoogleSQLParserRULE_hint)
	p.SetState(2440)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 257, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2437)
			p.Match(GoogleSQLParserAT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2438)
			p.Integer_literal()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2439)
			p.Hint_with_body()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHint_with_bodyContext is an interface to support dynamic dispatch.
type IHint_with_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Hint_with_body_prefix() IHint_with_body_prefixContext
	RC_BRACKET_SYMBOL() antlr.TerminalNode

	// IsHint_with_bodyContext differentiates from other interfaces.
	IsHint_with_bodyContext()
}

type Hint_with_bodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHint_with_bodyContext() *Hint_with_bodyContext {
	var p = new(Hint_with_bodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_hint_with_body
	return p
}

func InitEmptyHint_with_bodyContext(p *Hint_with_bodyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_hint_with_body
}

func (*Hint_with_bodyContext) IsHint_with_bodyContext() {}

func NewHint_with_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hint_with_bodyContext {
	var p = new(Hint_with_bodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_hint_with_body

	return p
}

func (s *Hint_with_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Hint_with_bodyContext) Hint_with_body_prefix() IHint_with_body_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHint_with_body_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHint_with_body_prefixContext)
}

func (s *Hint_with_bodyContext) RC_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRC_BRACKET_SYMBOL, 0)
}

func (s *Hint_with_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hint_with_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Hint_with_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterHint_with_body(s)
	}
}

func (s *Hint_with_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitHint_with_body(s)
	}
}

func (s *Hint_with_bodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitHint_with_body(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Hint_with_body() (localctx IHint_with_bodyContext) {
	localctx = NewHint_with_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, GoogleSQLParserRULE_hint_with_body)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2442)
		p.Hint_with_body_prefix()
	}
	{
		p.SetState(2443)
		p.Match(GoogleSQLParserRC_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHint_with_body_prefixContext is an interface to support dynamic dispatch.
type IHint_with_body_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAT_SYMBOL() []antlr.TerminalNode
	AT_SYMBOL(i int) antlr.TerminalNode
	LC_BRACKET_SYMBOL() antlr.TerminalNode
	AllHint_entry() []IHint_entryContext
	Hint_entry(i int) IHint_entryContext
	Integer_literal() IInteger_literalContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsHint_with_body_prefixContext differentiates from other interfaces.
	IsHint_with_body_prefixContext()
}

type Hint_with_body_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHint_with_body_prefixContext() *Hint_with_body_prefixContext {
	var p = new(Hint_with_body_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_hint_with_body_prefix
	return p
}

func InitEmptyHint_with_body_prefixContext(p *Hint_with_body_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_hint_with_body_prefix
}

func (*Hint_with_body_prefixContext) IsHint_with_body_prefixContext() {}

func NewHint_with_body_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hint_with_body_prefixContext {
	var p = new(Hint_with_body_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_hint_with_body_prefix

	return p
}

func (s *Hint_with_body_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Hint_with_body_prefixContext) AllAT_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserAT_SYMBOL)
}

func (s *Hint_with_body_prefixContext) AT_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAT_SYMBOL, i)
}

func (s *Hint_with_body_prefixContext) LC_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLC_BRACKET_SYMBOL, 0)
}

func (s *Hint_with_body_prefixContext) AllHint_entry() []IHint_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHint_entryContext); ok {
			len++
		}
	}

	tst := make([]IHint_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHint_entryContext); ok {
			tst[i] = t.(IHint_entryContext)
			i++
		}
	}

	return tst
}

func (s *Hint_with_body_prefixContext) Hint_entry(i int) IHint_entryContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHint_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHint_entryContext)
}

func (s *Hint_with_body_prefixContext) Integer_literal() IInteger_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInteger_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInteger_literalContext)
}

func (s *Hint_with_body_prefixContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Hint_with_body_prefixContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Hint_with_body_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hint_with_body_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Hint_with_body_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterHint_with_body_prefix(s)
	}
}

func (s *Hint_with_body_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitHint_with_body_prefix(s)
	}
}

func (s *Hint_with_body_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitHint_with_body_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Hint_with_body_prefix() (localctx IHint_with_body_prefixContext) {
	localctx = NewHint_with_body_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, GoogleSQLParserRULE_hint_with_body_prefix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2445)
		p.Match(GoogleSQLParserAT_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserINTEGER_LITERAL {
		{
			p.SetState(2446)
			p.Integer_literal()
		}
		{
			p.SetState(2447)
			p.Match(GoogleSQLParserAT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2451)
		p.Match(GoogleSQLParserLC_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2452)
		p.Hint_entry()
	}
	p.SetState(2457)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(2453)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2454)
			p.Hint_entry()
		}


		p.SetState(2459)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHint_entryContext is an interface to support dynamic dispatch.
type IHint_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier_in_hints() []IIdentifier_in_hintsContext
	Identifier_in_hints(i int) IIdentifier_in_hintsContext
	EQUAL_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext
	DOT_SYMBOL() antlr.TerminalNode

	// IsHint_entryContext differentiates from other interfaces.
	IsHint_entryContext()
}

type Hint_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHint_entryContext() *Hint_entryContext {
	var p = new(Hint_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_hint_entry
	return p
}

func InitEmptyHint_entryContext(p *Hint_entryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_hint_entry
}

func (*Hint_entryContext) IsHint_entryContext() {}

func NewHint_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hint_entryContext {
	var p = new(Hint_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_hint_entry

	return p
}

func (s *Hint_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Hint_entryContext) AllIdentifier_in_hints() []IIdentifier_in_hintsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifier_in_hintsContext); ok {
			len++
		}
	}

	tst := make([]IIdentifier_in_hintsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifier_in_hintsContext); ok {
			tst[i] = t.(IIdentifier_in_hintsContext)
			i++
		}
	}

	return tst
}

func (s *Hint_entryContext) Identifier_in_hints(i int) IIdentifier_in_hintsContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifier_in_hintsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifier_in_hintsContext)
}

func (s *Hint_entryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEQUAL_SYMBOL, 0)
}

func (s *Hint_entryContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Hint_entryContext) DOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDOT_SYMBOL, 0)
}

func (s *Hint_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hint_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Hint_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterHint_entry(s)
	}
}

func (s *Hint_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitHint_entry(s)
	}
}

func (s *Hint_entryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitHint_entry(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Hint_entry() (localctx IHint_entryContext) {
	localctx = NewHint_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, GoogleSQLParserRULE_hint_entry)
	p.SetState(2470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 260, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2460)
			p.Identifier_in_hints()
		}
		{
			p.SetState(2461)
			p.Match(GoogleSQLParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2462)
			p.expression(0)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2464)
			p.Identifier_in_hints()
		}
		{
			p.SetState(2465)
			p.Match(GoogleSQLParserDOT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2466)
			p.Identifier_in_hints()
		}
		{
			p.SetState(2467)
			p.Match(GoogleSQLParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2468)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIdentifier_in_hintsContext is an interface to support dynamic dispatch.
type IIdentifier_in_hintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Extra_identifier_in_hints_name() IExtra_identifier_in_hints_nameContext

	// IsIdentifier_in_hintsContext differentiates from other interfaces.
	IsIdentifier_in_hintsContext()
}

type Identifier_in_hintsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifier_in_hintsContext() *Identifier_in_hintsContext {
	var p = new(Identifier_in_hintsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_identifier_in_hints
	return p
}

func InitEmptyIdentifier_in_hintsContext(p *Identifier_in_hintsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_identifier_in_hints
}

func (*Identifier_in_hintsContext) IsIdentifier_in_hintsContext() {}

func NewIdentifier_in_hintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Identifier_in_hintsContext {
	var p = new(Identifier_in_hintsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_identifier_in_hints

	return p
}

func (s *Identifier_in_hintsContext) GetParser() antlr.Parser { return s.parser }

func (s *Identifier_in_hintsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Identifier_in_hintsContext) Extra_identifier_in_hints_name() IExtra_identifier_in_hints_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtra_identifier_in_hints_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtra_identifier_in_hints_nameContext)
}

func (s *Identifier_in_hintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Identifier_in_hintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Identifier_in_hintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterIdentifier_in_hints(s)
	}
}

func (s *Identifier_in_hintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitIdentifier_in_hints(s)
	}
}

func (s *Identifier_in_hintsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitIdentifier_in_hints(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Identifier_in_hints() (localctx IIdentifier_in_hintsContext) {
	localctx = NewIdentifier_in_hintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, GoogleSQLParserRULE_identifier_in_hints)
	p.SetState(2474)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserINCLUDE_SYMBOL, GoogleSQLParserOFFSET_SYMBOL, GoogleSQLParserOPTIONS_SYMBOL, GoogleSQLParserPERCENT_SYMBOL, GoogleSQLParserPIVOT_SYMBOL, GoogleSQLParserREPLACE_SYMBOL, GoogleSQLParserUNPIVOT_SYMBOL, GoogleSQLParserSYSTEM_SYMBOL, GoogleSQLParserSYSTEM_TIME_SYMBOL, GoogleSQLParserVALUE_SYMBOL, GoogleSQLParserNUMERIC_SYMBOL, GoogleSQLParserDECIMAL_SYMBOL, GoogleSQLParserBIGNUMERIC_SYMBOL, GoogleSQLParserBIGDECIMAL_SYMBOL, GoogleSQLParserJSON_SYMBOL, GoogleSQLParserDATE_SYMBOL, GoogleSQLParserTIME_SYMBOL, GoogleSQLParserDATETIME_SYMBOL, GoogleSQLParserTIMESTAMP_SYMBOL, GoogleSQLParserSIMPLE_SYMBOL, GoogleSQLParserABORT_SYMBOL, GoogleSQLParserACCESS_SYMBOL, GoogleSQLParserACTION_SYMBOL, GoogleSQLParserAGGREGATE_SYMBOL, GoogleSQLParserADD_SYMBOL, GoogleSQLParserALTER_SYMBOL, GoogleSQLParserALWAYS_SYMBOL, GoogleSQLParserANALYZE_SYMBOL, GoogleSQLParserAPPROX_SYMBOL, GoogleSQLParserARE_SYMBOL, GoogleSQLParserASSERT_SYMBOL, GoogleSQLParserBATCH_SYMBOL, GoogleSQLParserBEGIN_SYMBOL, GoogleSQLParserBREAK_SYMBOL, GoogleSQLParserCALL_SYMBOL, GoogleSQLParserCASCADE_SYMBOL, GoogleSQLParserCHECK_SYMBOL, GoogleSQLParserCLAMPED_SYMBOL, GoogleSQLParserCLONE_SYMBOL, GoogleSQLParserCOPY_SYMBOL, GoogleSQLParserCLUSTER_SYMBOL, GoogleSQLParserCOLUMN_SYMBOL, GoogleSQLParserCOLUMNS_SYMBOL, GoogleSQLParserCOMMIT_SYMBOL, GoogleSQLParserCONNECTION_SYMBOL, GoogleSQLParserCONSTANT_SYMBOL, GoogleSQLParserCONSTRAINT_SYMBOL, GoogleSQLParserCONTINUE_SYMBOL, GoogleSQLParserCORRESPONDING_SYMBOL, GoogleSQLParserCYCLE_SYMBOL, GoogleSQLParserDATA_SYMBOL, GoogleSQLParserDATABASE_SYMBOL, GoogleSQLParserDECLARE_SYMBOL, GoogleSQLParserDEFINER_SYMBOL, GoogleSQLParserDELETE_SYMBOL, GoogleSQLParserDELETION_SYMBOL, GoogleSQLParserDEPTH_SYMBOL, GoogleSQLParserDESCRIBE_SYMBOL, GoogleSQLParserDETERMINISTIC_SYMBOL, GoogleSQLParserDO_SYMBOL, GoogleSQLParserDROP_SYMBOL, GoogleSQLParserELSEIF_SYMBOL, GoogleSQLParserENFORCED_SYMBOL, GoogleSQLParserERROR_SYMBOL, GoogleSQLParserEXCEPTION_SYMBOL, GoogleSQLParserEXECUTE_SYMBOL, GoogleSQLParserEXPLAIN_SYMBOL, GoogleSQLParserEXPORT_SYMBOL, GoogleSQLParserEXTEND_SYMBOL, GoogleSQLParserEXTERNAL_SYMBOL, GoogleSQLParserFILES_SYMBOL, GoogleSQLParserFILTER_SYMBOL, GoogleSQLParserFILL_SYMBOL, GoogleSQLParserFIRST_SYMBOL, GoogleSQLParserFOREIGN_SYMBOL, GoogleSQLParserFORMAT_SYMBOL, GoogleSQLParserFUNCTION_SYMBOL, GoogleSQLParserGENERATED_SYMBOL, GoogleSQLParserGRANT_SYMBOL, GoogleSQLParserGROUP_ROWS_SYMBOL, GoogleSQLParserHIDDEN_SYMBOL, GoogleSQLParserIDENTITY_SYMBOL, GoogleSQLParserIMMEDIATE_SYMBOL, GoogleSQLParserIMMUTABLE_SYMBOL, GoogleSQLParserIMPORT_SYMBOL, GoogleSQLParserINCREMENT_SYMBOL, GoogleSQLParserINDEX_SYMBOL, GoogleSQLParserINOUT_SYMBOL, GoogleSQLParserINPUT_SYMBOL, GoogleSQLParserINSERT_SYMBOL, GoogleSQLParserINVOKER_SYMBOL, GoogleSQLParserISOLATION_SYMBOL, GoogleSQLParserITERATE_SYMBOL, GoogleSQLParserKEY_SYMBOL, GoogleSQLParserLANGUAGE_SYMBOL, GoogleSQLParserLAST_SYMBOL, GoogleSQLParserLEAVE_SYMBOL, GoogleSQLParserLEVEL_SYMBOL, GoogleSQLParserLOAD_SYMBOL, GoogleSQLParserLOOP_SYMBOL, GoogleSQLParserMACRO_SYMBOL, GoogleSQLParserMAP_SYMBOL, GoogleSQLParserMATCH_SYMBOL, GoogleSQLParserKW_MATCH_RECOGNIZE_NONRESERVED_SYMBOL, GoogleSQLParserMATCHED_SYMBOL, GoogleSQLParserMATERIALIZED_SYMBOL, GoogleSQLParserMAX_SYMBOL, GoogleSQLParserMAXVALUE_SYMBOL, GoogleSQLParserMEASURES_SYMBOL, GoogleSQLParserMESSAGE_SYMBOL, GoogleSQLParserMETADATA_SYMBOL, GoogleSQLParserMIN_SYMBOL, GoogleSQLParserMINVALUE_SYMBOL, GoogleSQLParserMODEL_SYMBOL, GoogleSQLParserMODULE_SYMBOL, GoogleSQLParserONLY_SYMBOL, GoogleSQLParserOUT_SYMBOL, GoogleSQLParserOUTPUT_SYMBOL, GoogleSQLParserOVERWRITE_SYMBOL, GoogleSQLParserPARTITIONS_SYMBOL, GoogleSQLParserPATTERN_SYMBOL, GoogleSQLParserPOLICIES_SYMBOL, GoogleSQLParserPOLICY_SYMBOL, GoogleSQLParserPRIMARY_SYMBOL, GoogleSQLParserPRIVATE_SYMBOL, GoogleSQLParserPRIVILEGE_SYMBOL, GoogleSQLParserPRIVILEGES_SYMBOL, GoogleSQLParserPROCEDURE_SYMBOL, GoogleSQLParserPROJECT_SYMBOL, GoogleSQLParserPUBLIC_SYMBOL, GoogleSQLParserRAISE_SYMBOL, GoogleSQLParserREAD_SYMBOL, GoogleSQLParserREFERENCES_SYMBOL, GoogleSQLParserREMOTE_SYMBOL, GoogleSQLParserREMOVE_SYMBOL, GoogleSQLParserRENAME_SYMBOL, GoogleSQLParserREPEAT_SYMBOL, GoogleSQLParserREPEATABLE_SYMBOL, GoogleSQLParserREPLACE_FIELDS_SYMBOL, GoogleSQLParserREPLICA_SYMBOL, GoogleSQLParserREPORT_SYMBOL, GoogleSQLParserRESTRICT_SYMBOL, GoogleSQLParserRESTRICTION_SYMBOL, GoogleSQLParserRETURNS_SYMBOL, GoogleSQLParserRETURN_SYMBOL, GoogleSQLParserREVOKE_SYMBOL, GoogleSQLParserROLLBACK_SYMBOL, GoogleSQLParserROW_SYMBOL, GoogleSQLParserRUN_SYMBOL, GoogleSQLParserSAFE_CAST_SYMBOL, GoogleSQLParserSCHEMA_SYMBOL, GoogleSQLParserSEARCH_SYMBOL, GoogleSQLParserSECURITY_SYMBOL, GoogleSQLParserSEQUENCE_SYMBOL, GoogleSQLParserSETS_SYMBOL, GoogleSQLParserSHOW_SYMBOL, GoogleSQLParserSNAPSHOT_SYMBOL, GoogleSQLParserSOURCE_SYMBOL, GoogleSQLParserSQL_SYMBOL, GoogleSQLParserSTABLE_SYMBOL, GoogleSQLParserSTART_SYMBOL, GoogleSQLParserSTATIC_DESCRIBE_SYMBOL, GoogleSQLParserSTORED_SYMBOL, GoogleSQLParserSTORING_SYMBOL, GoogleSQLParserSTRICT_SYMBOL, GoogleSQLParserTABLE_SYMBOL, GoogleSQLParserTABLES_SYMBOL, GoogleSQLParserTARGET_SYMBOL, GoogleSQLParserTEMP_SYMBOL, GoogleSQLParserTEMPORARY_SYMBOL, GoogleSQLParserTRANSACTION_SYMBOL, GoogleSQLParserTRANSFORM_SYMBOL, GoogleSQLParserTRUNCATE_SYMBOL, GoogleSQLParserTYPE_SYMBOL, GoogleSQLParserUNDROP_SYMBOL, GoogleSQLParserUNIQUE_SYMBOL, GoogleSQLParserUNKNOWN_SYMBOL, GoogleSQLParserUNTIL_SYMBOL, GoogleSQLParserUPDATE_SYMBOL, GoogleSQLParserVALUES_SYMBOL, GoogleSQLParserVECTOR_SYMBOL, GoogleSQLParserVIEW_SYMBOL, GoogleSQLParserVIEWS_SYMBOL, GoogleSQLParserVOLATILE_SYMBOL, GoogleSQLParserWEIGHT_SYMBOL, GoogleSQLParserWHILE_SYMBOL, GoogleSQLParserWRITE_SYMBOL, GoogleSQLParserZONE_SYMBOL, GoogleSQLParserDESCRIPTOR_SYMBOL, GoogleSQLParserINTERLEAVE_SYMBOL, GoogleSQLParserNULL_FILTERED_SYMBOL, GoogleSQLParserPARENT_SYMBOL, GoogleSQLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2472)
			p.Identifier()
		}


	case GoogleSQLParserHASH_SYMBOL, GoogleSQLParserPROTO_SYMBOL, GoogleSQLParserPARTITION_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2473)
			p.Extra_identifier_in_hints_name()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExtra_identifier_in_hints_nameContext is an interface to support dynamic dispatch.
type IExtra_identifier_in_hints_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HASH_SYMBOL() antlr.TerminalNode
	PROTO_SYMBOL() antlr.TerminalNode
	PARTITION_SYMBOL() antlr.TerminalNode

	// IsExtra_identifier_in_hints_nameContext differentiates from other interfaces.
	IsExtra_identifier_in_hints_nameContext()
}

type Extra_identifier_in_hints_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtra_identifier_in_hints_nameContext() *Extra_identifier_in_hints_nameContext {
	var p = new(Extra_identifier_in_hints_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_extra_identifier_in_hints_name
	return p
}

func InitEmptyExtra_identifier_in_hints_nameContext(p *Extra_identifier_in_hints_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_extra_identifier_in_hints_name
}

func (*Extra_identifier_in_hints_nameContext) IsExtra_identifier_in_hints_nameContext() {}

func NewExtra_identifier_in_hints_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Extra_identifier_in_hints_nameContext {
	var p = new(Extra_identifier_in_hints_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_extra_identifier_in_hints_name

	return p
}

func (s *Extra_identifier_in_hints_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Extra_identifier_in_hints_nameContext) HASH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserHASH_SYMBOL, 0)
}

func (s *Extra_identifier_in_hints_nameContext) PROTO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPROTO_SYMBOL, 0)
}

func (s *Extra_identifier_in_hints_nameContext) PARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPARTITION_SYMBOL, 0)
}

func (s *Extra_identifier_in_hints_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extra_identifier_in_hints_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Extra_identifier_in_hints_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterExtra_identifier_in_hints_name(s)
	}
}

func (s *Extra_identifier_in_hints_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitExtra_identifier_in_hints_name(s)
	}
}

func (s *Extra_identifier_in_hints_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitExtra_identifier_in_hints_name(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Extra_identifier_in_hints_name() (localctx IExtra_identifier_in_hints_nameContext) {
	localctx = NewExtra_identifier_in_hints_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, GoogleSQLParserRULE_extra_identifier_in_hints_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2476)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 254)) & ^0x3f) == 0 && ((int64(1) << (_la - 254)) & 7) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGrouping_itemContext is an interface to support dynamic dispatch.
type IGrouping_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext
	Opt_as_alias_with_required_as() IOpt_as_alias_with_required_asContext
	Opt_grouping_item_order() IOpt_grouping_item_orderContext
	Rollup_list() IRollup_listContext
	Cube_list() ICube_listContext
	Grouping_set_list() IGrouping_set_listContext

	// IsGrouping_itemContext differentiates from other interfaces.
	IsGrouping_itemContext()
}

type Grouping_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrouping_itemContext() *Grouping_itemContext {
	var p = new(Grouping_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_grouping_item
	return p
}

func InitEmptyGrouping_itemContext(p *Grouping_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_grouping_item
}

func (*Grouping_itemContext) IsGrouping_itemContext() {}

func NewGrouping_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grouping_itemContext {
	var p = new(Grouping_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_grouping_item

	return p
}

func (s *Grouping_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Grouping_itemContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Grouping_itemContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Grouping_itemContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Grouping_itemContext) Opt_as_alias_with_required_as() IOpt_as_alias_with_required_asContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_as_alias_with_required_asContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_as_alias_with_required_asContext)
}

func (s *Grouping_itemContext) Opt_grouping_item_order() IOpt_grouping_item_orderContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_grouping_item_orderContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_grouping_item_orderContext)
}

func (s *Grouping_itemContext) Rollup_list() IRollup_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollup_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollup_listContext)
}

func (s *Grouping_itemContext) Cube_list() ICube_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICube_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICube_listContext)
}

func (s *Grouping_itemContext) Grouping_set_list() IGrouping_set_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrouping_set_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrouping_set_listContext)
}

func (s *Grouping_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grouping_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Grouping_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterGrouping_item(s)
	}
}

func (s *Grouping_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitGrouping_item(s)
	}
}

func (s *Grouping_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitGrouping_item(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Grouping_item() (localctx IGrouping_itemContext) {
	localctx = NewGrouping_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, GoogleSQLParserRULE_grouping_item)
	p.SetState(2496)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 264, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2478)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2479)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2480)
			p.expression(0)
		}
		p.SetState(2482)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 262, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2481)
				p.Opt_as_alias_with_required_as()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(2485)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 263, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2484)
				p.Opt_grouping_item_order()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2487)
			p.Rollup_list()
		}
		{
			p.SetState(2488)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2490)
			p.Cube_list()
		}
		{
			p.SetState(2491)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2493)
			p.Grouping_set_list()
		}
		{
			p.SetState(2494)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGrouping_set_listContext is an interface to support dynamic dispatch.
type IGrouping_set_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUPING_SYMBOL() antlr.TerminalNode
	SETS_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	AllGrouping_set() []IGrouping_setContext
	Grouping_set(i int) IGrouping_setContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsGrouping_set_listContext differentiates from other interfaces.
	IsGrouping_set_listContext()
}

type Grouping_set_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrouping_set_listContext() *Grouping_set_listContext {
	var p = new(Grouping_set_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_grouping_set_list
	return p
}

func InitEmptyGrouping_set_listContext(p *Grouping_set_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_grouping_set_list
}

func (*Grouping_set_listContext) IsGrouping_set_listContext() {}

func NewGrouping_set_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grouping_set_listContext {
	var p = new(Grouping_set_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_grouping_set_list

	return p
}

func (s *Grouping_set_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Grouping_set_listContext) GROUPING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserGROUPING_SYMBOL, 0)
}

func (s *Grouping_set_listContext) SETS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSETS_SYMBOL, 0)
}

func (s *Grouping_set_listContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Grouping_set_listContext) AllGrouping_set() []IGrouping_setContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGrouping_setContext); ok {
			len++
		}
	}

	tst := make([]IGrouping_setContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGrouping_setContext); ok {
			tst[i] = t.(IGrouping_setContext)
			i++
		}
	}

	return tst
}

func (s *Grouping_set_listContext) Grouping_set(i int) IGrouping_setContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrouping_setContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrouping_setContext)
}

func (s *Grouping_set_listContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Grouping_set_listContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Grouping_set_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grouping_set_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Grouping_set_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterGrouping_set_list(s)
	}
}

func (s *Grouping_set_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitGrouping_set_list(s)
	}
}

func (s *Grouping_set_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitGrouping_set_list(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Grouping_set_list() (localctx IGrouping_set_listContext) {
	localctx = NewGrouping_set_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, GoogleSQLParserRULE_grouping_set_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2498)
		p.Match(GoogleSQLParserGROUPING_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2499)
		p.Match(GoogleSQLParserSETS_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2500)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2501)
		p.Grouping_set()
	}
	p.SetState(2506)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(2502)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2503)
			p.Grouping_set()
		}


		p.SetState(2508)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGrouping_setContext is an interface to support dynamic dispatch.
type IGrouping_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext
	Rollup_list() IRollup_listContext
	Cube_list() ICube_listContext

	// IsGrouping_setContext differentiates from other interfaces.
	IsGrouping_setContext()
}

type Grouping_setContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrouping_setContext() *Grouping_setContext {
	var p = new(Grouping_setContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_grouping_set
	return p
}

func InitEmptyGrouping_setContext(p *Grouping_setContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_grouping_set
}

func (*Grouping_setContext) IsGrouping_setContext() {}

func NewGrouping_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grouping_setContext {
	var p = new(Grouping_setContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_grouping_set

	return p
}

func (s *Grouping_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Grouping_setContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Grouping_setContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Grouping_setContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Grouping_setContext) Rollup_list() IRollup_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollup_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollup_listContext)
}

func (s *Grouping_setContext) Cube_list() ICube_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICube_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICube_listContext)
}

func (s *Grouping_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grouping_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Grouping_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterGrouping_set(s)
	}
}

func (s *Grouping_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitGrouping_set(s)
	}
}

func (s *Grouping_setContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitGrouping_set(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Grouping_set() (localctx IGrouping_setContext) {
	localctx = NewGrouping_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, GoogleSQLParserRULE_grouping_set)
	p.SetState(2518)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 266, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2509)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2510)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2511)
			p.expression(0)
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2512)
			p.Rollup_list()
		}
		{
			p.SetState(2513)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2515)
			p.Cube_list()
		}
		{
			p.SetState(2516)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICube_listContext is an interface to support dynamic dispatch.
type ICube_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CUBE_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsCube_listContext differentiates from other interfaces.
	IsCube_listContext()
}

type Cube_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCube_listContext() *Cube_listContext {
	var p = new(Cube_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_cube_list
	return p
}

func InitEmptyCube_listContext(p *Cube_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_cube_list
}

func (*Cube_listContext) IsCube_listContext() {}

func NewCube_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cube_listContext {
	var p = new(Cube_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_cube_list

	return p
}

func (s *Cube_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Cube_listContext) CUBE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCUBE_SYMBOL, 0)
}

func (s *Cube_listContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Cube_listContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Cube_listContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Cube_listContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Cube_listContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Cube_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cube_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Cube_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterCube_list(s)
	}
}

func (s *Cube_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitCube_list(s)
	}
}

func (s *Cube_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitCube_list(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Cube_list() (localctx ICube_listContext) {
	localctx = NewCube_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, GoogleSQLParserRULE_cube_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2520)
		p.Match(GoogleSQLParserCUBE_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2521)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2526)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(2522)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2523)
			p.expression(0)
		}


		p.SetState(2528)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRollup_listContext is an interface to support dynamic dispatch.
type IRollup_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLUP_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsRollup_listContext differentiates from other interfaces.
	IsRollup_listContext()
}

type Rollup_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollup_listContext() *Rollup_listContext {
	var p = new(Rollup_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_rollup_list
	return p
}

func InitEmptyRollup_listContext(p *Rollup_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_rollup_list
}

func (*Rollup_listContext) IsRollup_listContext() {}

func NewRollup_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rollup_listContext {
	var p = new(Rollup_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_rollup_list

	return p
}

func (s *Rollup_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Rollup_listContext) ROLLUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserROLLUP_SYMBOL, 0)
}

func (s *Rollup_listContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Rollup_listContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Rollup_listContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Rollup_listContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Rollup_listContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Rollup_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rollup_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Rollup_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterRollup_list(s)
	}
}

func (s *Rollup_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitRollup_list(s)
	}
}

func (s *Rollup_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitRollup_list(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Rollup_list() (localctx IRollup_listContext) {
	localctx = NewRollup_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, GoogleSQLParserRULE_rollup_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2529)
		p.Match(GoogleSQLParserROLLUP_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2530)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2531)
		p.expression(0)
	}
	p.SetState(2536)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(2532)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2533)
			p.expression(0)
		}


		p.SetState(2538)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_as_alias_with_required_asContext is an interface to support dynamic dispatch.
type IOpt_as_alias_with_required_asContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsOpt_as_alias_with_required_asContext differentiates from other interfaces.
	IsOpt_as_alias_with_required_asContext()
}

type Opt_as_alias_with_required_asContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_as_alias_with_required_asContext() *Opt_as_alias_with_required_asContext {
	var p = new(Opt_as_alias_with_required_asContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_as_alias_with_required_as
	return p
}

func InitEmptyOpt_as_alias_with_required_asContext(p *Opt_as_alias_with_required_asContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_as_alias_with_required_as
}

func (*Opt_as_alias_with_required_asContext) IsOpt_as_alias_with_required_asContext() {}

func NewOpt_as_alias_with_required_asContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_as_alias_with_required_asContext {
	var p = new(Opt_as_alias_with_required_asContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_as_alias_with_required_as

	return p
}

func (s *Opt_as_alias_with_required_asContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_as_alias_with_required_asContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAS_SYMBOL, 0)
}

func (s *Opt_as_alias_with_required_asContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Opt_as_alias_with_required_asContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_as_alias_with_required_asContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_as_alias_with_required_asContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_as_alias_with_required_as(s)
	}
}

func (s *Opt_as_alias_with_required_asContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_as_alias_with_required_as(s)
	}
}

func (s *Opt_as_alias_with_required_asContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_as_alias_with_required_as(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_as_alias_with_required_as() (localctx IOpt_as_alias_with_required_asContext) {
	localctx = NewOpt_as_alias_with_required_asContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, GoogleSQLParserRULE_opt_as_alias_with_required_as)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2539)
		p.Match(GoogleSQLParserAS_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2540)
		p.Identifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_grouping_item_orderContext is an interface to support dynamic dispatch.
type IOpt_grouping_item_orderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Opt_selection_item_order() IOpt_selection_item_orderContext
	Null_order() INull_orderContext

	// IsOpt_grouping_item_orderContext differentiates from other interfaces.
	IsOpt_grouping_item_orderContext()
}

type Opt_grouping_item_orderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_grouping_item_orderContext() *Opt_grouping_item_orderContext {
	var p = new(Opt_grouping_item_orderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_grouping_item_order
	return p
}

func InitEmptyOpt_grouping_item_orderContext(p *Opt_grouping_item_orderContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_grouping_item_order
}

func (*Opt_grouping_item_orderContext) IsOpt_grouping_item_orderContext() {}

func NewOpt_grouping_item_orderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_grouping_item_orderContext {
	var p = new(Opt_grouping_item_orderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_grouping_item_order

	return p
}

func (s *Opt_grouping_item_orderContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_grouping_item_orderContext) Opt_selection_item_order() IOpt_selection_item_orderContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_selection_item_orderContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_selection_item_orderContext)
}

func (s *Opt_grouping_item_orderContext) Null_order() INull_orderContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INull_orderContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INull_orderContext)
}

func (s *Opt_grouping_item_orderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_grouping_item_orderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_grouping_item_orderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_grouping_item_order(s)
	}
}

func (s *Opt_grouping_item_orderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_grouping_item_order(s)
	}
}

func (s *Opt_grouping_item_orderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_grouping_item_order(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_grouping_item_order() (localctx IOpt_grouping_item_orderContext) {
	localctx = NewOpt_grouping_item_orderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, GoogleSQLParserRULE_opt_grouping_item_order)
	p.SetState(2544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserASC_SYMBOL, GoogleSQLParserDESC_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2542)
			p.Opt_selection_item_order()
		}


	case GoogleSQLParserNULLS_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2543)
			p.Null_order()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_selection_item_orderContext is an interface to support dynamic dispatch.
type IOpt_selection_item_orderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Asc_or_desc() IAsc_or_descContext
	Null_order() INull_orderContext

	// IsOpt_selection_item_orderContext differentiates from other interfaces.
	IsOpt_selection_item_orderContext()
}

type Opt_selection_item_orderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_selection_item_orderContext() *Opt_selection_item_orderContext {
	var p = new(Opt_selection_item_orderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_selection_item_order
	return p
}

func InitEmptyOpt_selection_item_orderContext(p *Opt_selection_item_orderContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_selection_item_order
}

func (*Opt_selection_item_orderContext) IsOpt_selection_item_orderContext() {}

func NewOpt_selection_item_orderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_selection_item_orderContext {
	var p = new(Opt_selection_item_orderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_selection_item_order

	return p
}

func (s *Opt_selection_item_orderContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_selection_item_orderContext) Asc_or_desc() IAsc_or_descContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsc_or_descContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsc_or_descContext)
}

func (s *Opt_selection_item_orderContext) Null_order() INull_orderContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INull_orderContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INull_orderContext)
}

func (s *Opt_selection_item_orderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_selection_item_orderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_selection_item_orderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_selection_item_order(s)
	}
}

func (s *Opt_selection_item_orderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_selection_item_order(s)
	}
}

func (s *Opt_selection_item_orderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_selection_item_order(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_selection_item_order() (localctx IOpt_selection_item_orderContext) {
	localctx = NewOpt_selection_item_orderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, GoogleSQLParserRULE_opt_selection_item_order)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2546)
		p.Asc_or_desc()
	}
	p.SetState(2548)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 270, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2547)
			p.Null_order()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAsc_or_descContext is an interface to support dynamic dispatch.
type IAsc_or_descContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASC_SYMBOL() antlr.TerminalNode
	DESC_SYMBOL() antlr.TerminalNode

	// IsAsc_or_descContext differentiates from other interfaces.
	IsAsc_or_descContext()
}

type Asc_or_descContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsc_or_descContext() *Asc_or_descContext {
	var p = new(Asc_or_descContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_asc_or_desc
	return p
}

func InitEmptyAsc_or_descContext(p *Asc_or_descContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_asc_or_desc
}

func (*Asc_or_descContext) IsAsc_or_descContext() {}

func NewAsc_or_descContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Asc_or_descContext {
	var p = new(Asc_or_descContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_asc_or_desc

	return p
}

func (s *Asc_or_descContext) GetParser() antlr.Parser { return s.parser }

func (s *Asc_or_descContext) ASC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserASC_SYMBOL, 0)
}

func (s *Asc_or_descContext) DESC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDESC_SYMBOL, 0)
}

func (s *Asc_or_descContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Asc_or_descContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Asc_or_descContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterAsc_or_desc(s)
	}
}

func (s *Asc_or_descContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitAsc_or_desc(s)
	}
}

func (s *Asc_or_descContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitAsc_or_desc(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Asc_or_desc() (localctx IAsc_or_descContext) {
	localctx = NewAsc_or_descContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, GoogleSQLParserRULE_asc_or_desc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2550)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GoogleSQLParserASC_SYMBOL || _la == GoogleSQLParserDESC_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INull_orderContext is an interface to support dynamic dispatch.
type INull_orderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULLS_SYMBOL() antlr.TerminalNode
	FIRST_SYMBOL() antlr.TerminalNode
	LAST_SYMBOL() antlr.TerminalNode

	// IsNull_orderContext differentiates from other interfaces.
	IsNull_orderContext()
}

type Null_orderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNull_orderContext() *Null_orderContext {
	var p = new(Null_orderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_null_order
	return p
}

func InitEmptyNull_orderContext(p *Null_orderContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_null_order
}

func (*Null_orderContext) IsNull_orderContext() {}

func NewNull_orderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Null_orderContext {
	var p = new(Null_orderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_null_order

	return p
}

func (s *Null_orderContext) GetParser() antlr.Parser { return s.parser }

func (s *Null_orderContext) NULLS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserNULLS_SYMBOL, 0)
}

func (s *Null_orderContext) FIRST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFIRST_SYMBOL, 0)
}

func (s *Null_orderContext) LAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLAST_SYMBOL, 0)
}

func (s *Null_orderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Null_orderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Null_orderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterNull_order(s)
	}
}

func (s *Null_orderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitNull_order(s)
	}
}

func (s *Null_orderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitNull_order(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Null_order() (localctx INull_orderContext) {
	localctx = NewNull_orderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, GoogleSQLParserRULE_null_order)
	p.SetState(2556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 271, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2552)
			p.Match(GoogleSQLParserNULLS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2553)
			p.Match(GoogleSQLParserFIRST_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2554)
			p.Match(GoogleSQLParserNULLS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2555)
			p.Match(GoogleSQLParserLAST_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunction_call_expression_baseContext is an interface to support dynamic dispatch.
type IFunction_call_expression_baseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression_higher_prec_than_and() IExpression_higher_prec_than_andContext
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	DISTINCT_SYMBOL() antlr.TerminalNode
	Function_name_from_keyword() IFunction_name_from_keywordContext

	// IsFunction_call_expression_baseContext differentiates from other interfaces.
	IsFunction_call_expression_baseContext()
}

type Function_call_expression_baseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_call_expression_baseContext() *Function_call_expression_baseContext {
	var p = new(Function_call_expression_baseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_function_call_expression_base
	return p
}

func InitEmptyFunction_call_expression_baseContext(p *Function_call_expression_baseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_function_call_expression_base
}

func (*Function_call_expression_baseContext) IsFunction_call_expression_baseContext() {}

func NewFunction_call_expression_baseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_call_expression_baseContext {
	var p = new(Function_call_expression_baseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_function_call_expression_base

	return p
}

func (s *Function_call_expression_baseContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_call_expression_baseContext) Expression_higher_prec_than_and() IExpression_higher_prec_than_andContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpression_higher_prec_than_andContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpression_higher_prec_than_andContext)
}

func (s *Function_call_expression_baseContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Function_call_expression_baseContext) DISTINCT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDISTINCT_SYMBOL, 0)
}

func (s *Function_call_expression_baseContext) Function_name_from_keyword() IFunction_name_from_keywordContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_name_from_keywordContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_name_from_keywordContext)
}

func (s *Function_call_expression_baseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_call_expression_baseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Function_call_expression_baseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterFunction_call_expression_base(s)
	}
}

func (s *Function_call_expression_baseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitFunction_call_expression_base(s)
	}
}

func (s *Function_call_expression_baseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitFunction_call_expression_base(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Function_call_expression_base() (localctx IFunction_call_expression_baseContext) {
	localctx = NewFunction_call_expression_baseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, GoogleSQLParserRULE_function_call_expression_base)
	p.SetState(2568)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 272, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2558)
			p.Expression_higher_prec_than_and()
		}
		{
			p.SetState(2559)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2560)
			p.Match(GoogleSQLParserDISTINCT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2562)
			p.Expression_higher_prec_than_and()
		}
		{
			p.SetState(2563)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2565)
			p.Function_name_from_keyword()
		}
		{
			p.SetState(2566)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunction_name_from_keywordContext is an interface to support dynamic dispatch.
type IFunction_name_from_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF_SYMBOL() antlr.TerminalNode
	GROUPING_SYMBOL() antlr.TerminalNode
	LEFT_SYMBOL() antlr.TerminalNode
	RIGHT_SYMBOL() antlr.TerminalNode
	COLLATE_SYMBOL() antlr.TerminalNode
	RANGE_SYMBOL() antlr.TerminalNode

	// IsFunction_name_from_keywordContext differentiates from other interfaces.
	IsFunction_name_from_keywordContext()
}

type Function_name_from_keywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_name_from_keywordContext() *Function_name_from_keywordContext {
	var p = new(Function_name_from_keywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_function_name_from_keyword
	return p
}

func InitEmptyFunction_name_from_keywordContext(p *Function_name_from_keywordContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_function_name_from_keyword
}

func (*Function_name_from_keywordContext) IsFunction_name_from_keywordContext() {}

func NewFunction_name_from_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_name_from_keywordContext {
	var p = new(Function_name_from_keywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_function_name_from_keyword

	return p
}

func (s *Function_name_from_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_name_from_keywordContext) IF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserIF_SYMBOL, 0)
}

func (s *Function_name_from_keywordContext) GROUPING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserGROUPING_SYMBOL, 0)
}

func (s *Function_name_from_keywordContext) LEFT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLEFT_SYMBOL, 0)
}

func (s *Function_name_from_keywordContext) RIGHT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRIGHT_SYMBOL, 0)
}

func (s *Function_name_from_keywordContext) COLLATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOLLATE_SYMBOL, 0)
}

func (s *Function_name_from_keywordContext) RANGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRANGE_SYMBOL, 0)
}

func (s *Function_name_from_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_name_from_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Function_name_from_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterFunction_name_from_keyword(s)
	}
}

func (s *Function_name_from_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitFunction_name_from_keyword(s)
	}
}

func (s *Function_name_from_keywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitFunction_name_from_keyword(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Function_name_from_keyword() (localctx IFunction_name_from_keywordContext) {
	localctx = NewFunction_name_from_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, GoogleSQLParserRULE_function_name_from_keyword)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2570)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 22)) & ^0x3f) == 0 && ((int64(1) << (_la - 22)) & 4398046527489) != 0) || ((int64((_la - 247)) & ^0x3f) == 0 && ((int64(1) << (_la - 247)) & 7) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReplace_fields_expressionContext is an interface to support dynamic dispatch.
type IReplace_fields_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Replace_fields_prefix() IReplace_fields_prefixContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsReplace_fields_expressionContext differentiates from other interfaces.
	IsReplace_fields_expressionContext()
}

type Replace_fields_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplace_fields_expressionContext() *Replace_fields_expressionContext {
	var p = new(Replace_fields_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_replace_fields_expression
	return p
}

func InitEmptyReplace_fields_expressionContext(p *Replace_fields_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_replace_fields_expression
}

func (*Replace_fields_expressionContext) IsReplace_fields_expressionContext() {}

func NewReplace_fields_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Replace_fields_expressionContext {
	var p = new(Replace_fields_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_replace_fields_expression

	return p
}

func (s *Replace_fields_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Replace_fields_expressionContext) Replace_fields_prefix() IReplace_fields_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplace_fields_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplace_fields_prefixContext)
}

func (s *Replace_fields_expressionContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Replace_fields_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Replace_fields_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Replace_fields_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterReplace_fields_expression(s)
	}
}

func (s *Replace_fields_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitReplace_fields_expression(s)
	}
}

func (s *Replace_fields_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitReplace_fields_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Replace_fields_expression() (localctx IReplace_fields_expressionContext) {
	localctx = NewReplace_fields_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, GoogleSQLParserRULE_replace_fields_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2572)
		p.Replace_fields_prefix()
	}
	{
		p.SetState(2573)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReplace_fields_prefixContext is an interface to support dynamic dispatch.
type IReplace_fields_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE_FIELDS_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	AllReplace_fields_arg() []IReplace_fields_argContext
	Replace_fields_arg(i int) IReplace_fields_argContext

	// IsReplace_fields_prefixContext differentiates from other interfaces.
	IsReplace_fields_prefixContext()
}

type Replace_fields_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplace_fields_prefixContext() *Replace_fields_prefixContext {
	var p = new(Replace_fields_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_replace_fields_prefix
	return p
}

func InitEmptyReplace_fields_prefixContext(p *Replace_fields_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_replace_fields_prefix
}

func (*Replace_fields_prefixContext) IsReplace_fields_prefixContext() {}

func NewReplace_fields_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Replace_fields_prefixContext {
	var p = new(Replace_fields_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_replace_fields_prefix

	return p
}

func (s *Replace_fields_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Replace_fields_prefixContext) REPLACE_FIELDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserREPLACE_FIELDS_SYMBOL, 0)
}

func (s *Replace_fields_prefixContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Replace_fields_prefixContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Replace_fields_prefixContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Replace_fields_prefixContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Replace_fields_prefixContext) AllReplace_fields_arg() []IReplace_fields_argContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplace_fields_argContext); ok {
			len++
		}
	}

	tst := make([]IReplace_fields_argContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplace_fields_argContext); ok {
			tst[i] = t.(IReplace_fields_argContext)
			i++
		}
	}

	return tst
}

func (s *Replace_fields_prefixContext) Replace_fields_arg(i int) IReplace_fields_argContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplace_fields_argContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplace_fields_argContext)
}

func (s *Replace_fields_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Replace_fields_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Replace_fields_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterReplace_fields_prefix(s)
	}
}

func (s *Replace_fields_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitReplace_fields_prefix(s)
	}
}

func (s *Replace_fields_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitReplace_fields_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Replace_fields_prefix() (localctx IReplace_fields_prefixContext) {
	localctx = NewReplace_fields_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, GoogleSQLParserRULE_replace_fields_prefix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2575)
		p.Match(GoogleSQLParserREPLACE_FIELDS_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2576)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2577)
		p.expression(0)
	}
	{
		p.SetState(2578)
		p.Match(GoogleSQLParserCOMMA_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2579)
		p.Replace_fields_arg()
	}
	p.SetState(2584)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(2580)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2581)
			p.Replace_fields_arg()
		}


		p.SetState(2586)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReplace_fields_argContext is an interface to support dynamic dispatch.
type IReplace_fields_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AS_SYMBOL() antlr.TerminalNode
	Generalized_path_expression() IGeneralized_path_expressionContext
	Generalized_extension_path() IGeneralized_extension_pathContext

	// IsReplace_fields_argContext differentiates from other interfaces.
	IsReplace_fields_argContext()
}

type Replace_fields_argContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplace_fields_argContext() *Replace_fields_argContext {
	var p = new(Replace_fields_argContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_replace_fields_arg
	return p
}

func InitEmptyReplace_fields_argContext(p *Replace_fields_argContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_replace_fields_arg
}

func (*Replace_fields_argContext) IsReplace_fields_argContext() {}

func NewReplace_fields_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Replace_fields_argContext {
	var p = new(Replace_fields_argContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_replace_fields_arg

	return p
}

func (s *Replace_fields_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Replace_fields_argContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Replace_fields_argContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAS_SYMBOL, 0)
}

func (s *Replace_fields_argContext) Generalized_path_expression() IGeneralized_path_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralized_path_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralized_path_expressionContext)
}

func (s *Replace_fields_argContext) Generalized_extension_path() IGeneralized_extension_pathContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralized_extension_pathContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralized_extension_pathContext)
}

func (s *Replace_fields_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Replace_fields_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Replace_fields_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterReplace_fields_arg(s)
	}
}

func (s *Replace_fields_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitReplace_fields_arg(s)
	}
}

func (s *Replace_fields_argContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitReplace_fields_arg(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Replace_fields_arg() (localctx IReplace_fields_argContext) {
	localctx = NewReplace_fields_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, GoogleSQLParserRULE_replace_fields_arg)
	p.SetState(2595)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 274, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2587)
			p.expression(0)
		}
		{
			p.SetState(2588)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2589)
			p.generalized_path_expression(0)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2591)
			p.expression(0)
		}
		{
			p.SetState(2592)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2593)
			p.Generalized_extension_path()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGeneralized_path_expressionContext is an interface to support dynamic dispatch.
type IGeneralized_path_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Generalized_path_expression() IGeneralized_path_expressionContext
	DOT_SYMBOL() antlr.TerminalNode
	Generalized_extension_path() IGeneralized_extension_pathContext
	LS_BRACKET_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext
	RS_BRACKET_SYMBOL() antlr.TerminalNode

	// IsGeneralized_path_expressionContext differentiates from other interfaces.
	IsGeneralized_path_expressionContext()
}

type Generalized_path_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralized_path_expressionContext() *Generalized_path_expressionContext {
	var p = new(Generalized_path_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_generalized_path_expression
	return p
}

func InitEmptyGeneralized_path_expressionContext(p *Generalized_path_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_generalized_path_expression
}

func (*Generalized_path_expressionContext) IsGeneralized_path_expressionContext() {}

func NewGeneralized_path_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generalized_path_expressionContext {
	var p = new(Generalized_path_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_generalized_path_expression

	return p
}

func (s *Generalized_path_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Generalized_path_expressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Generalized_path_expressionContext) Generalized_path_expression() IGeneralized_path_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralized_path_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralized_path_expressionContext)
}

func (s *Generalized_path_expressionContext) DOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDOT_SYMBOL, 0)
}

func (s *Generalized_path_expressionContext) Generalized_extension_path() IGeneralized_extension_pathContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralized_extension_pathContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralized_extension_pathContext)
}

func (s *Generalized_path_expressionContext) LS_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLS_BRACKET_SYMBOL, 0)
}

func (s *Generalized_path_expressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Generalized_path_expressionContext) RS_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRS_BRACKET_SYMBOL, 0)
}

func (s *Generalized_path_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generalized_path_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Generalized_path_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterGeneralized_path_expression(s)
	}
}

func (s *Generalized_path_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitGeneralized_path_expression(s)
	}
}

func (s *Generalized_path_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitGeneralized_path_expression(s)

	default:
		return t.VisitChildren(s)
	}
}





func (p *GoogleSQLParser) Generalized_path_expression() (localctx IGeneralized_path_expressionContext) {
	return p.generalized_path_expression(0)
}

func (p *GoogleSQLParser) generalized_path_expression(_p int) (localctx IGeneralized_path_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewGeneralized_path_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IGeneralized_path_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 454
	p.EnterRecursionRule(localctx, 454, GoogleSQLParserRULE_generalized_path_expression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2598)
		p.Identifier()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 276, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2611)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 275, p.GetParserRuleContext()) {
			case 1:
				localctx = NewGeneralized_path_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_generalized_path_expression)
				p.SetState(2600)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(2601)
					p.Match(GoogleSQLParserDOT_SYMBOL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(2602)
					p.Generalized_extension_path()
				}


			case 2:
				localctx = NewGeneralized_path_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_generalized_path_expression)
				p.SetState(2603)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(2604)
					p.Match(GoogleSQLParserDOT_SYMBOL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(2605)
					p.Identifier()
				}


			case 3:
				localctx = NewGeneralized_path_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_generalized_path_expression)
				p.SetState(2606)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(2607)
					p.Match(GoogleSQLParserLS_BRACKET_SYMBOL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(2608)
					p.expression(0)
				}
				{
					p.SetState(2609)
					p.Match(GoogleSQLParserRS_BRACKET_SYMBOL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2615)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 276, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGeneralized_extension_pathContext is an interface to support dynamic dispatch.
type IGeneralized_extension_pathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Generalized_path_expression() IGeneralized_path_expressionContext
	DOT_SYMBOL() antlr.TerminalNode
	Generalized_extension_path() IGeneralized_extension_pathContext
	LS_BRACKET_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext
	RS_BRACKET_SYMBOL() antlr.TerminalNode

	// IsGeneralized_extension_pathContext differentiates from other interfaces.
	IsGeneralized_extension_pathContext()
}

type Generalized_extension_pathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralized_extension_pathContext() *Generalized_extension_pathContext {
	var p = new(Generalized_extension_pathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_generalized_extension_path
	return p
}

func InitEmptyGeneralized_extension_pathContext(p *Generalized_extension_pathContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_generalized_extension_path
}

func (*Generalized_extension_pathContext) IsGeneralized_extension_pathContext() {}

func NewGeneralized_extension_pathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generalized_extension_pathContext {
	var p = new(Generalized_extension_pathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_generalized_extension_path

	return p
}

func (s *Generalized_extension_pathContext) GetParser() antlr.Parser { return s.parser }

func (s *Generalized_extension_pathContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Generalized_extension_pathContext) Generalized_path_expression() IGeneralized_path_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralized_path_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralized_path_expressionContext)
}

func (s *Generalized_extension_pathContext) DOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDOT_SYMBOL, 0)
}

func (s *Generalized_extension_pathContext) Generalized_extension_path() IGeneralized_extension_pathContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralized_extension_pathContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralized_extension_pathContext)
}

func (s *Generalized_extension_pathContext) LS_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLS_BRACKET_SYMBOL, 0)
}

func (s *Generalized_extension_pathContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Generalized_extension_pathContext) RS_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRS_BRACKET_SYMBOL, 0)
}

func (s *Generalized_extension_pathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generalized_extension_pathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Generalized_extension_pathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterGeneralized_extension_path(s)
	}
}

func (s *Generalized_extension_pathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitGeneralized_extension_path(s)
	}
}

func (s *Generalized_extension_pathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitGeneralized_extension_path(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Generalized_extension_path() (localctx IGeneralized_extension_pathContext) {
	localctx = NewGeneralized_extension_pathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, GoogleSQLParserRULE_generalized_extension_path)
	p.SetState(2630)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 277, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2616)
			p.Identifier()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2617)
			p.generalized_path_expression(0)
		}
		{
			p.SetState(2618)
			p.Match(GoogleSQLParserDOT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2619)
			p.Generalized_extension_path()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2621)
			p.generalized_path_expression(0)
		}
		{
			p.SetState(2622)
			p.Match(GoogleSQLParserDOT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2623)
			p.Identifier()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2625)
			p.generalized_path_expression(0)
		}
		{
			p.SetState(2626)
			p.Match(GoogleSQLParserLS_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2627)
			p.expression(0)
		}
		{
			p.SetState(2628)
			p.Match(GoogleSQLParserRS_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWith_expressionContext is an interface to support dynamic dispatch.
type IWith_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	With_expression_variable_prefix() IWith_expression_variable_prefixContext
	COMMA_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsWith_expressionContext differentiates from other interfaces.
	IsWith_expressionContext()
}

type With_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_expressionContext() *With_expressionContext {
	var p = new(With_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_with_expression
	return p
}

func InitEmptyWith_expressionContext(p *With_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_with_expression
}

func (*With_expressionContext) IsWith_expressionContext() {}

func NewWith_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_expressionContext {
	var p = new(With_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_with_expression

	return p
}

func (s *With_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *With_expressionContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWITH_SYMBOL, 0)
}

func (s *With_expressionContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *With_expressionContext) With_expression_variable_prefix() IWith_expression_variable_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_expression_variable_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_expression_variable_prefixContext)
}

func (s *With_expressionContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, 0)
}

func (s *With_expressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *With_expressionContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *With_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *With_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterWith_expression(s)
	}
}

func (s *With_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitWith_expression(s)
	}
}

func (s *With_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitWith_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) With_expression() (localctx IWith_expressionContext) {
	localctx = NewWith_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, GoogleSQLParserRULE_with_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2632)
		p.Match(GoogleSQLParserWITH_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2633)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2634)
		p.With_expression_variable_prefix()
	}
	{
		p.SetState(2635)
		p.Match(GoogleSQLParserCOMMA_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2636)
		p.expression(0)
	}
	{
		p.SetState(2637)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWith_expression_variable_prefixContext is an interface to support dynamic dispatch.
type IWith_expression_variable_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWith_expression_variable() []IWith_expression_variableContext
	With_expression_variable(i int) IWith_expression_variableContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsWith_expression_variable_prefixContext differentiates from other interfaces.
	IsWith_expression_variable_prefixContext()
}

type With_expression_variable_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_expression_variable_prefixContext() *With_expression_variable_prefixContext {
	var p = new(With_expression_variable_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_with_expression_variable_prefix
	return p
}

func InitEmptyWith_expression_variable_prefixContext(p *With_expression_variable_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_with_expression_variable_prefix
}

func (*With_expression_variable_prefixContext) IsWith_expression_variable_prefixContext() {}

func NewWith_expression_variable_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_expression_variable_prefixContext {
	var p = new(With_expression_variable_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_with_expression_variable_prefix

	return p
}

func (s *With_expression_variable_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *With_expression_variable_prefixContext) AllWith_expression_variable() []IWith_expression_variableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWith_expression_variableContext); ok {
			len++
		}
	}

	tst := make([]IWith_expression_variableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWith_expression_variableContext); ok {
			tst[i] = t.(IWith_expression_variableContext)
			i++
		}
	}

	return tst
}

func (s *With_expression_variable_prefixContext) With_expression_variable(i int) IWith_expression_variableContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_expression_variableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_expression_variableContext)
}

func (s *With_expression_variable_prefixContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *With_expression_variable_prefixContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *With_expression_variable_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_expression_variable_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *With_expression_variable_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterWith_expression_variable_prefix(s)
	}
}

func (s *With_expression_variable_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitWith_expression_variable_prefix(s)
	}
}

func (s *With_expression_variable_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitWith_expression_variable_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) With_expression_variable_prefix() (localctx IWith_expression_variable_prefixContext) {
	localctx = NewWith_expression_variable_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, GoogleSQLParserRULE_with_expression_variable_prefix)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2639)
		p.With_expression_variable()
	}
	p.SetState(2644)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 278, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2640)
				p.Match(GoogleSQLParserCOMMA_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2641)
				p.With_expression_variable()
			}


		}
		p.SetState(2646)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 278, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWith_expression_variableContext is an interface to support dynamic dispatch.
type IWith_expression_variableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AS_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsWith_expression_variableContext differentiates from other interfaces.
	IsWith_expression_variableContext()
}

type With_expression_variableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_expression_variableContext() *With_expression_variableContext {
	var p = new(With_expression_variableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_with_expression_variable
	return p
}

func InitEmptyWith_expression_variableContext(p *With_expression_variableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_with_expression_variable
}

func (*With_expression_variableContext) IsWith_expression_variableContext() {}

func NewWith_expression_variableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_expression_variableContext {
	var p = new(With_expression_variableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_with_expression_variable

	return p
}

func (s *With_expression_variableContext) GetParser() antlr.Parser { return s.parser }

func (s *With_expression_variableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *With_expression_variableContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAS_SYMBOL, 0)
}

func (s *With_expression_variableContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *With_expression_variableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_expression_variableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *With_expression_variableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterWith_expression_variable(s)
	}
}

func (s *With_expression_variableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitWith_expression_variable(s)
	}
}

func (s *With_expression_variableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitWith_expression_variable(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) With_expression_variable() (localctx IWith_expression_variableContext) {
	localctx = NewWith_expression_variableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, GoogleSQLParserRULE_with_expression_variable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2647)
		p.Identifier()
	}
	{
		p.SetState(2648)
		p.Match(GoogleSQLParserAS_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2649)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExtract_expressionContext is an interface to support dynamic dispatch.
type IExtract_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Extract_expression_base() IExtract_expression_baseContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	AT_SYMBOL() antlr.TerminalNode
	TIME_SYMBOL() antlr.TerminalNode
	ZONE_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsExtract_expressionContext differentiates from other interfaces.
	IsExtract_expressionContext()
}

type Extract_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtract_expressionContext() *Extract_expressionContext {
	var p = new(Extract_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_extract_expression
	return p
}

func InitEmptyExtract_expressionContext(p *Extract_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_extract_expression
}

func (*Extract_expressionContext) IsExtract_expressionContext() {}

func NewExtract_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Extract_expressionContext {
	var p = new(Extract_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_extract_expression

	return p
}

func (s *Extract_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Extract_expressionContext) Extract_expression_base() IExtract_expression_baseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtract_expression_baseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtract_expression_baseContext)
}

func (s *Extract_expressionContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Extract_expressionContext) AT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAT_SYMBOL, 0)
}

func (s *Extract_expressionContext) TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTIME_SYMBOL, 0)
}

func (s *Extract_expressionContext) ZONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserZONE_SYMBOL, 0)
}

func (s *Extract_expressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Extract_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extract_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Extract_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterExtract_expression(s)
	}
}

func (s *Extract_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitExtract_expression(s)
	}
}

func (s *Extract_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitExtract_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Extract_expression() (localctx IExtract_expressionContext) {
	localctx = NewExtract_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, GoogleSQLParserRULE_extract_expression)
	p.SetState(2661)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 279, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2651)
			p.Extract_expression_base()
		}
		{
			p.SetState(2652)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2654)
			p.Extract_expression_base()
		}
		{
			p.SetState(2655)
			p.Match(GoogleSQLParserAT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2656)
			p.Match(GoogleSQLParserTIME_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2657)
			p.Match(GoogleSQLParserZONE_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2658)
			p.expression(0)
		}
		{
			p.SetState(2659)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExtract_expression_baseContext is an interface to support dynamic dispatch.
type IExtract_expression_baseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTRACT_SYMBOL() antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	FROM_SYMBOL() antlr.TerminalNode

	// IsExtract_expression_baseContext differentiates from other interfaces.
	IsExtract_expression_baseContext()
}

type Extract_expression_baseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtract_expression_baseContext() *Extract_expression_baseContext {
	var p = new(Extract_expression_baseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_extract_expression_base
	return p
}

func InitEmptyExtract_expression_baseContext(p *Extract_expression_baseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_extract_expression_base
}

func (*Extract_expression_baseContext) IsExtract_expression_baseContext() {}

func NewExtract_expression_baseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Extract_expression_baseContext {
	var p = new(Extract_expression_baseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_extract_expression_base

	return p
}

func (s *Extract_expression_baseContext) GetParser() antlr.Parser { return s.parser }

func (s *Extract_expression_baseContext) EXTRACT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEXTRACT_SYMBOL, 0)
}

func (s *Extract_expression_baseContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Extract_expression_baseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Extract_expression_baseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Extract_expression_baseContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFROM_SYMBOL, 0)
}

func (s *Extract_expression_baseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extract_expression_baseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Extract_expression_baseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterExtract_expression_base(s)
	}
}

func (s *Extract_expression_baseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitExtract_expression_base(s)
	}
}

func (s *Extract_expression_baseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitExtract_expression_base(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Extract_expression_base() (localctx IExtract_expression_baseContext) {
	localctx = NewExtract_expression_baseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, GoogleSQLParserRULE_extract_expression_base)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2663)
		p.Match(GoogleSQLParserEXTRACT_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2664)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2665)
		p.expression(0)
	}
	{
		p.SetState(2666)
		p.Match(GoogleSQLParserFROM_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2667)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_formatContext is an interface to support dynamic dispatch.
type IOpt_formatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FORMAT_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext
	Opt_at_time_zone() IOpt_at_time_zoneContext

	// IsOpt_formatContext differentiates from other interfaces.
	IsOpt_formatContext()
}

type Opt_formatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_formatContext() *Opt_formatContext {
	var p = new(Opt_formatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_format
	return p
}

func InitEmptyOpt_formatContext(p *Opt_formatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_format
}

func (*Opt_formatContext) IsOpt_formatContext() {}

func NewOpt_formatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_formatContext {
	var p = new(Opt_formatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_format

	return p
}

func (s *Opt_formatContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_formatContext) FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFORMAT_SYMBOL, 0)
}

func (s *Opt_formatContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Opt_formatContext) Opt_at_time_zone() IOpt_at_time_zoneContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_at_time_zoneContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_at_time_zoneContext)
}

func (s *Opt_formatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_formatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_formatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_format(s)
	}
}

func (s *Opt_formatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_format(s)
	}
}

func (s *Opt_formatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_format(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_format() (localctx IOpt_formatContext) {
	localctx = NewOpt_formatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, GoogleSQLParserRULE_opt_format)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2669)
		p.Match(GoogleSQLParserFORMAT_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2670)
		p.expression(0)
	}
	p.SetState(2672)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserAT_SYMBOL {
		{
			p.SetState(2671)
			p.Opt_at_time_zone()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_at_time_zoneContext is an interface to support dynamic dispatch.
type IOpt_at_time_zoneContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT_SYMBOL() antlr.TerminalNode
	TIME_SYMBOL() antlr.TerminalNode
	ZONE_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsOpt_at_time_zoneContext differentiates from other interfaces.
	IsOpt_at_time_zoneContext()
}

type Opt_at_time_zoneContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_at_time_zoneContext() *Opt_at_time_zoneContext {
	var p = new(Opt_at_time_zoneContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_at_time_zone
	return p
}

func InitEmptyOpt_at_time_zoneContext(p *Opt_at_time_zoneContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_at_time_zone
}

func (*Opt_at_time_zoneContext) IsOpt_at_time_zoneContext() {}

func NewOpt_at_time_zoneContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_at_time_zoneContext {
	var p = new(Opt_at_time_zoneContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_at_time_zone

	return p
}

func (s *Opt_at_time_zoneContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_at_time_zoneContext) AT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAT_SYMBOL, 0)
}

func (s *Opt_at_time_zoneContext) TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTIME_SYMBOL, 0)
}

func (s *Opt_at_time_zoneContext) ZONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserZONE_SYMBOL, 0)
}

func (s *Opt_at_time_zoneContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Opt_at_time_zoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_at_time_zoneContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_at_time_zoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_at_time_zone(s)
	}
}

func (s *Opt_at_time_zoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_at_time_zone(s)
	}
}

func (s *Opt_at_time_zoneContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_at_time_zone(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_at_time_zone() (localctx IOpt_at_time_zoneContext) {
	localctx = NewOpt_at_time_zoneContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, GoogleSQLParserRULE_opt_at_time_zone)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2674)
		p.Match(GoogleSQLParserAT_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2675)
		p.Match(GoogleSQLParserTIME_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2676)
		p.Match(GoogleSQLParserZONE_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2677)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICast_expressionContext is an interface to support dynamic dispatch.
type ICast_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCAST_SYMBOL() []antlr.TerminalNode
	CAST_SYMBOL(i int) antlr.TerminalNode
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	AS_SYMBOL() antlr.TerminalNode
	Type_() ITypeContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	Opt_format() IOpt_formatContext
	AllSAFE_CAST_SYMBOL() []antlr.TerminalNode
	SAFE_CAST_SYMBOL(i int) antlr.TerminalNode

	// IsCast_expressionContext differentiates from other interfaces.
	IsCast_expressionContext()
}

type Cast_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCast_expressionContext() *Cast_expressionContext {
	var p = new(Cast_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_cast_expression
	return p
}

func InitEmptyCast_expressionContext(p *Cast_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_cast_expression
}

func (*Cast_expressionContext) IsCast_expressionContext() {}

func NewCast_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cast_expressionContext {
	var p = new(Cast_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_cast_expression

	return p
}

func (s *Cast_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Cast_expressionContext) AllCAST_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCAST_SYMBOL)
}

func (s *Cast_expressionContext) CAST_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCAST_SYMBOL, i)
}

func (s *Cast_expressionContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Cast_expressionContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAS_SYMBOL, 0)
}

func (s *Cast_expressionContext) Type_() ITypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Cast_expressionContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Cast_expressionContext) Opt_format() IOpt_formatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_formatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_formatContext)
}

func (s *Cast_expressionContext) AllSAFE_CAST_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserSAFE_CAST_SYMBOL)
}

func (s *Cast_expressionContext) SAFE_CAST_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSAFE_CAST_SYMBOL, i)
}

func (s *Cast_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cast_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Cast_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterCast_expression(s)
	}
}

func (s *Cast_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitCast_expression(s)
	}
}

func (s *Cast_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitCast_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Cast_expression() (localctx ICast_expressionContext) {
	localctx = NewCast_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, GoogleSQLParserRULE_cast_expression)
	var _la int

	p.SetState(2705)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 283, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2679)
			p.Match(GoogleSQLParserCAST_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2680)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2681)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2682)
			p.Type_()
		}
		p.SetState(2684)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserFORMAT_SYMBOL {
			{
				p.SetState(2683)
				p.Opt_format()
			}

		}
		{
			p.SetState(2686)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2688)
			p.Match(GoogleSQLParserCAST_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2689)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2690)
			p.Match(GoogleSQLParserCAST_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		 p.NotifyErrorListeners("The argument to CAST is an
			 expression, not a query; to use a query " "as an expression, the query must be wrapped with
			 additional " "parentheses to make it a scalar subquery expression", nil, nil); 


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2692)
			p.Match(GoogleSQLParserSAFE_CAST_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2693)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2694)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2695)
			p.Type_()
		}
		p.SetState(2697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoogleSQLParserFORMAT_SYMBOL {
			{
				p.SetState(2696)
				p.Opt_format()
			}

		}
		{
			p.SetState(2699)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2701)
			p.Match(GoogleSQLParserSAFE_CAST_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2702)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2703)
			p.Match(GoogleSQLParserSAFE_CAST_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		 p.NotifyErrorListeners("The argument to
			 CAST is an expression, not a query; to use a query " "as an expression, the query must be
			 wrapped with additional " "parentheses to make it a scalar subquery expression", nil, nil); 

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICase_expressionContext is an interface to support dynamic dispatch.
type ICase_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Case_expression_prefix() ICase_expression_prefixContext
	END_SYMBOL() antlr.TerminalNode
	ELSE_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsCase_expressionContext differentiates from other interfaces.
	IsCase_expressionContext()
}

type Case_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_expressionContext() *Case_expressionContext {
	var p = new(Case_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_case_expression
	return p
}

func InitEmptyCase_expressionContext(p *Case_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_case_expression
}

func (*Case_expressionContext) IsCase_expressionContext() {}

func NewCase_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_expressionContext {
	var p = new(Case_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_case_expression

	return p
}

func (s *Case_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_expressionContext) Case_expression_prefix() ICase_expression_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICase_expression_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICase_expression_prefixContext)
}

func (s *Case_expressionContext) END_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEND_SYMBOL, 0)
}

func (s *Case_expressionContext) ELSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserELSE_SYMBOL, 0)
}

func (s *Case_expressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Case_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Case_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterCase_expression(s)
	}
}

func (s *Case_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitCase_expression(s)
	}
}

func (s *Case_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitCase_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Case_expression() (localctx ICase_expressionContext) {
	localctx = NewCase_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, GoogleSQLParserRULE_case_expression)
	p.SetState(2715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 284, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2707)
			p.Case_expression_prefix()
		}
		{
			p.SetState(2708)
			p.Match(GoogleSQLParserEND_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2710)
			p.Case_expression_prefix()
		}
		{
			p.SetState(2711)
			p.Match(GoogleSQLParserELSE_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2712)
			p.expression(0)
		}
		{
			p.SetState(2713)
			p.Match(GoogleSQLParserEND_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICase_expression_prefixContext is an interface to support dynamic dispatch.
type ICase_expression_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Case_no_value_expression_prefix() ICase_no_value_expression_prefixContext
	Case_value_expression_prefix() ICase_value_expression_prefixContext

	// IsCase_expression_prefixContext differentiates from other interfaces.
	IsCase_expression_prefixContext()
}

type Case_expression_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_expression_prefixContext() *Case_expression_prefixContext {
	var p = new(Case_expression_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_case_expression_prefix
	return p
}

func InitEmptyCase_expression_prefixContext(p *Case_expression_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_case_expression_prefix
}

func (*Case_expression_prefixContext) IsCase_expression_prefixContext() {}

func NewCase_expression_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_expression_prefixContext {
	var p = new(Case_expression_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_case_expression_prefix

	return p
}

func (s *Case_expression_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_expression_prefixContext) Case_no_value_expression_prefix() ICase_no_value_expression_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICase_no_value_expression_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICase_no_value_expression_prefixContext)
}

func (s *Case_expression_prefixContext) Case_value_expression_prefix() ICase_value_expression_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICase_value_expression_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICase_value_expression_prefixContext)
}

func (s *Case_expression_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_expression_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Case_expression_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterCase_expression_prefix(s)
	}
}

func (s *Case_expression_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitCase_expression_prefix(s)
	}
}

func (s *Case_expression_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitCase_expression_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Case_expression_prefix() (localctx ICase_expression_prefixContext) {
	localctx = NewCase_expression_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, GoogleSQLParserRULE_case_expression_prefix)
	p.SetState(2719)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 285, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2717)
			p.Case_no_value_expression_prefix()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2718)
			p.Case_value_expression_prefix()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICase_value_expression_prefixContext is an interface to support dynamic dispatch.
type ICase_value_expression_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE_SYMBOL() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllWHEN_SYMBOL() []antlr.TerminalNode
	WHEN_SYMBOL(i int) antlr.TerminalNode
	AllTHEN_SYMBOL() []antlr.TerminalNode
	THEN_SYMBOL(i int) antlr.TerminalNode

	// IsCase_value_expression_prefixContext differentiates from other interfaces.
	IsCase_value_expression_prefixContext()
}

type Case_value_expression_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_value_expression_prefixContext() *Case_value_expression_prefixContext {
	var p = new(Case_value_expression_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_case_value_expression_prefix
	return p
}

func InitEmptyCase_value_expression_prefixContext(p *Case_value_expression_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_case_value_expression_prefix
}

func (*Case_value_expression_prefixContext) IsCase_value_expression_prefixContext() {}

func NewCase_value_expression_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_value_expression_prefixContext {
	var p = new(Case_value_expression_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_case_value_expression_prefix

	return p
}

func (s *Case_value_expression_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_value_expression_prefixContext) CASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCASE_SYMBOL, 0)
}

func (s *Case_value_expression_prefixContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Case_value_expression_prefixContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Case_value_expression_prefixContext) AllWHEN_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserWHEN_SYMBOL)
}

func (s *Case_value_expression_prefixContext) WHEN_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWHEN_SYMBOL, i)
}

func (s *Case_value_expression_prefixContext) AllTHEN_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserTHEN_SYMBOL)
}

func (s *Case_value_expression_prefixContext) THEN_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTHEN_SYMBOL, i)
}

func (s *Case_value_expression_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_value_expression_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Case_value_expression_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterCase_value_expression_prefix(s)
	}
}

func (s *Case_value_expression_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitCase_value_expression_prefix(s)
	}
}

func (s *Case_value_expression_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitCase_value_expression_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Case_value_expression_prefix() (localctx ICase_value_expression_prefixContext) {
	localctx = NewCase_value_expression_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, GoogleSQLParserRULE_case_value_expression_prefix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2721)
		p.Match(GoogleSQLParserCASE_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2722)
		p.expression(0)
	}
	p.SetState(2728)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == GoogleSQLParserWHEN_SYMBOL {
		{
			p.SetState(2723)
			p.Match(GoogleSQLParserWHEN_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2724)
			p.expression(0)
		}
		{
			p.SetState(2725)
			p.Match(GoogleSQLParserTHEN_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2726)
			p.expression(0)
		}


		p.SetState(2730)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICase_no_value_expression_prefixContext is an interface to support dynamic dispatch.
type ICase_no_value_expression_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE_SYMBOL() antlr.TerminalNode
	AllWHEN_SYMBOL() []antlr.TerminalNode
	WHEN_SYMBOL(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllTHEN_SYMBOL() []antlr.TerminalNode
	THEN_SYMBOL(i int) antlr.TerminalNode

	// IsCase_no_value_expression_prefixContext differentiates from other interfaces.
	IsCase_no_value_expression_prefixContext()
}

type Case_no_value_expression_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_no_value_expression_prefixContext() *Case_no_value_expression_prefixContext {
	var p = new(Case_no_value_expression_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_case_no_value_expression_prefix
	return p
}

func InitEmptyCase_no_value_expression_prefixContext(p *Case_no_value_expression_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_case_no_value_expression_prefix
}

func (*Case_no_value_expression_prefixContext) IsCase_no_value_expression_prefixContext() {}

func NewCase_no_value_expression_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_no_value_expression_prefixContext {
	var p = new(Case_no_value_expression_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_case_no_value_expression_prefix

	return p
}

func (s *Case_no_value_expression_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_no_value_expression_prefixContext) CASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCASE_SYMBOL, 0)
}

func (s *Case_no_value_expression_prefixContext) AllWHEN_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserWHEN_SYMBOL)
}

func (s *Case_no_value_expression_prefixContext) WHEN_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWHEN_SYMBOL, i)
}

func (s *Case_no_value_expression_prefixContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Case_no_value_expression_prefixContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Case_no_value_expression_prefixContext) AllTHEN_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserTHEN_SYMBOL)
}

func (s *Case_no_value_expression_prefixContext) THEN_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTHEN_SYMBOL, i)
}

func (s *Case_no_value_expression_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_no_value_expression_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Case_no_value_expression_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterCase_no_value_expression_prefix(s)
	}
}

func (s *Case_no_value_expression_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitCase_no_value_expression_prefix(s)
	}
}

func (s *Case_no_value_expression_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitCase_no_value_expression_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Case_no_value_expression_prefix() (localctx ICase_no_value_expression_prefixContext) {
	localctx = NewCase_no_value_expression_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, GoogleSQLParserRULE_case_no_value_expression_prefix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2732)
		p.Match(GoogleSQLParserCASE_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2738)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == GoogleSQLParserWHEN_SYMBOL {
		{
			p.SetState(2733)
			p.Match(GoogleSQLParserWHEN_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2734)
			p.expression(0)
		}
		{
			p.SetState(2735)
			p.Match(GoogleSQLParserTHEN_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2736)
			p.expression(0)
		}


		p.SetState(2740)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStruct_braced_constructorContext is an interface to support dynamic dispatch.
type IStruct_braced_constructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStype returns the stype rule contexts.
	GetStype() IStruct_typeContext

	// GetCtor returns the ctor rule contexts.
	GetCtor() IBraced_constructorContext


	// SetStype sets the stype rule contexts.
	SetStype(IStruct_typeContext)

	// SetCtor sets the ctor rule contexts.
	SetCtor(IBraced_constructorContext)


	// Getter signatures
	Struct_type() IStruct_typeContext
	Braced_constructor() IBraced_constructorContext
	STRUCT_SYMBOL() antlr.TerminalNode

	// IsStruct_braced_constructorContext differentiates from other interfaces.
	IsStruct_braced_constructorContext()
}

type Struct_braced_constructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	stype IStruct_typeContext 
	ctor IBraced_constructorContext 
}

func NewEmptyStruct_braced_constructorContext() *Struct_braced_constructorContext {
	var p = new(Struct_braced_constructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_struct_braced_constructor
	return p
}

func InitEmptyStruct_braced_constructorContext(p *Struct_braced_constructorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_struct_braced_constructor
}

func (*Struct_braced_constructorContext) IsStruct_braced_constructorContext() {}

func NewStruct_braced_constructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_braced_constructorContext {
	var p = new(Struct_braced_constructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_struct_braced_constructor

	return p
}

func (s *Struct_braced_constructorContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_braced_constructorContext) GetStype() IStruct_typeContext { return s.stype }

func (s *Struct_braced_constructorContext) GetCtor() IBraced_constructorContext { return s.ctor }


func (s *Struct_braced_constructorContext) SetStype(v IStruct_typeContext) { s.stype = v }

func (s *Struct_braced_constructorContext) SetCtor(v IBraced_constructorContext) { s.ctor = v }


func (s *Struct_braced_constructorContext) Struct_type() IStruct_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_typeContext)
}

func (s *Struct_braced_constructorContext) Braced_constructor() IBraced_constructorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBraced_constructorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBraced_constructorContext)
}

func (s *Struct_braced_constructorContext) STRUCT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSTRUCT_SYMBOL, 0)
}

func (s *Struct_braced_constructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_braced_constructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Struct_braced_constructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterStruct_braced_constructor(s)
	}
}

func (s *Struct_braced_constructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitStruct_braced_constructor(s)
	}
}

func (s *Struct_braced_constructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitStruct_braced_constructor(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Struct_braced_constructor() (localctx IStruct_braced_constructorContext) {
	localctx = NewStruct_braced_constructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, GoogleSQLParserRULE_struct_braced_constructor)
	p.SetState(2747)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 288, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2742)

			var _x = p.Struct_type()


			localctx.(*Struct_braced_constructorContext).stype = _x
		}
		{
			p.SetState(2743)

			var _x = p.Braced_constructor()


			localctx.(*Struct_braced_constructorContext).ctor = _x
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2745)
			p.Match(GoogleSQLParserSTRUCT_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2746)

			var _x = p.Braced_constructor()


			localctx.(*Struct_braced_constructorContext).ctor = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBraced_new_constructorContext is an interface to support dynamic dispatch.
type IBraced_new_constructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NEW_SYMBOL() antlr.TerminalNode
	Type_name() IType_nameContext
	New_constructor() INew_constructorContext

	// IsBraced_new_constructorContext differentiates from other interfaces.
	IsBraced_new_constructorContext()
}

type Braced_new_constructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBraced_new_constructorContext() *Braced_new_constructorContext {
	var p = new(Braced_new_constructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_braced_new_constructor
	return p
}

func InitEmptyBraced_new_constructorContext(p *Braced_new_constructorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_braced_new_constructor
}

func (*Braced_new_constructorContext) IsBraced_new_constructorContext() {}

func NewBraced_new_constructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Braced_new_constructorContext {
	var p = new(Braced_new_constructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_braced_new_constructor

	return p
}

func (s *Braced_new_constructorContext) GetParser() antlr.Parser { return s.parser }

func (s *Braced_new_constructorContext) NEW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserNEW_SYMBOL, 0)
}

func (s *Braced_new_constructorContext) Type_name() IType_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Braced_new_constructorContext) New_constructor() INew_constructorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INew_constructorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INew_constructorContext)
}

func (s *Braced_new_constructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Braced_new_constructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Braced_new_constructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterBraced_new_constructor(s)
	}
}

func (s *Braced_new_constructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitBraced_new_constructor(s)
	}
}

func (s *Braced_new_constructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitBraced_new_constructor(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Braced_new_constructor() (localctx IBraced_new_constructorContext) {
	localctx = NewBraced_new_constructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, GoogleSQLParserRULE_braced_new_constructor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2749)
		p.Match(GoogleSQLParserNEW_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2750)
		p.Type_name()
	}
	{
		p.SetState(2751)
		p.New_constructor()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBraced_constructorContext is an interface to support dynamic dispatch.
type IBraced_constructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Braced_constructor_start() IBraced_constructor_startContext
	AllRC_BRACKET_SYMBOL() []antlr.TerminalNode
	RC_BRACKET_SYMBOL(i int) antlr.TerminalNode
	Braced_constructor_prefix() IBraced_constructor_prefixContext
	COMMA_SYMBOL() antlr.TerminalNode

	// IsBraced_constructorContext differentiates from other interfaces.
	IsBraced_constructorContext()
}

type Braced_constructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBraced_constructorContext() *Braced_constructorContext {
	var p = new(Braced_constructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor
	return p
}

func InitEmptyBraced_constructorContext(p *Braced_constructorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor
}

func (*Braced_constructorContext) IsBraced_constructorContext() {}

func NewBraced_constructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Braced_constructorContext {
	var p = new(Braced_constructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor

	return p
}

func (s *Braced_constructorContext) GetParser() antlr.Parser { return s.parser }

func (s *Braced_constructorContext) Braced_constructor_start() IBraced_constructor_startContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBraced_constructor_startContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBraced_constructor_startContext)
}

func (s *Braced_constructorContext) AllRC_BRACKET_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserRC_BRACKET_SYMBOL)
}

func (s *Braced_constructorContext) RC_BRACKET_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRC_BRACKET_SYMBOL, i)
}

func (s *Braced_constructorContext) Braced_constructor_prefix() IBraced_constructor_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBraced_constructor_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBraced_constructor_prefixContext)
}

func (s *Braced_constructorContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, 0)
}

func (s *Braced_constructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Braced_constructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Braced_constructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterBraced_constructor(s)
	}
}

func (s *Braced_constructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitBraced_constructor(s)
	}
}

func (s *Braced_constructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitBraced_constructor(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Braced_constructor() (localctx IBraced_constructorContext) {
	localctx = NewBraced_constructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, GoogleSQLParserRULE_braced_constructor)
	p.SetState(2761)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 289, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2753)
			p.Braced_constructor_start()
		}
		{
			p.SetState(2754)
			p.Match(GoogleSQLParserRC_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2756)
			p.braced_constructor_prefix(0)
		}
		{
			p.SetState(2757)
			p.Match(GoogleSQLParserRC_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2758)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2759)
			p.Match(GoogleSQLParserRC_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBraced_constructor_startContext is an interface to support dynamic dispatch.
type IBraced_constructor_startContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RC_BRACKET_SYMBOL() antlr.TerminalNode

	// IsBraced_constructor_startContext differentiates from other interfaces.
	IsBraced_constructor_startContext()
}

type Braced_constructor_startContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBraced_constructor_startContext() *Braced_constructor_startContext {
	var p = new(Braced_constructor_startContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor_start
	return p
}

func InitEmptyBraced_constructor_startContext(p *Braced_constructor_startContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor_start
}

func (*Braced_constructor_startContext) IsBraced_constructor_startContext() {}

func NewBraced_constructor_startContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Braced_constructor_startContext {
	var p = new(Braced_constructor_startContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor_start

	return p
}

func (s *Braced_constructor_startContext) GetParser() antlr.Parser { return s.parser }

func (s *Braced_constructor_startContext) RC_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRC_BRACKET_SYMBOL, 0)
}

func (s *Braced_constructor_startContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Braced_constructor_startContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Braced_constructor_startContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterBraced_constructor_start(s)
	}
}

func (s *Braced_constructor_startContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitBraced_constructor_start(s)
	}
}

func (s *Braced_constructor_startContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitBraced_constructor_start(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Braced_constructor_start() (localctx IBraced_constructor_startContext) {
	localctx = NewBraced_constructor_startContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, GoogleSQLParserRULE_braced_constructor_start)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2763)
		p.Match(GoogleSQLParserRC_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBraced_constructor_prefixContext is an interface to support dynamic dispatch.
type IBraced_constructor_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Braced_constructor_start() IBraced_constructor_startContext
	Braced_constructor_field() IBraced_constructor_fieldContext
	Braced_constructor_extension() IBraced_constructor_extensionContext
	Braced_constructor_prefix() IBraced_constructor_prefixContext
	COMMA_SYMBOL() antlr.TerminalNode

	// IsBraced_constructor_prefixContext differentiates from other interfaces.
	IsBraced_constructor_prefixContext()
}

type Braced_constructor_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBraced_constructor_prefixContext() *Braced_constructor_prefixContext {
	var p = new(Braced_constructor_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor_prefix
	return p
}

func InitEmptyBraced_constructor_prefixContext(p *Braced_constructor_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor_prefix
}

func (*Braced_constructor_prefixContext) IsBraced_constructor_prefixContext() {}

func NewBraced_constructor_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Braced_constructor_prefixContext {
	var p = new(Braced_constructor_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor_prefix

	return p
}

func (s *Braced_constructor_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Braced_constructor_prefixContext) Braced_constructor_start() IBraced_constructor_startContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBraced_constructor_startContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBraced_constructor_startContext)
}

func (s *Braced_constructor_prefixContext) Braced_constructor_field() IBraced_constructor_fieldContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBraced_constructor_fieldContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBraced_constructor_fieldContext)
}

func (s *Braced_constructor_prefixContext) Braced_constructor_extension() IBraced_constructor_extensionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBraced_constructor_extensionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBraced_constructor_extensionContext)
}

func (s *Braced_constructor_prefixContext) Braced_constructor_prefix() IBraced_constructor_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBraced_constructor_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBraced_constructor_prefixContext)
}

func (s *Braced_constructor_prefixContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, 0)
}

func (s *Braced_constructor_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Braced_constructor_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Braced_constructor_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterBraced_constructor_prefix(s)
	}
}

func (s *Braced_constructor_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitBraced_constructor_prefix(s)
	}
}

func (s *Braced_constructor_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitBraced_constructor_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}





func (p *GoogleSQLParser) Braced_constructor_prefix() (localctx IBraced_constructor_prefixContext) {
	return p.braced_constructor_prefix(0)
}

func (p *GoogleSQLParser) braced_constructor_prefix(_p int) (localctx IBraced_constructor_prefixContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBraced_constructor_prefixContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBraced_constructor_prefixContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 490
	p.EnterRecursionRule(localctx, 490, GoogleSQLParserRULE_braced_constructor_prefix, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2772)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 290, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2766)
			p.Braced_constructor_start()
		}
		{
			p.SetState(2767)
			p.Braced_constructor_field()
		}


	case 2:
		{
			p.SetState(2769)
			p.Braced_constructor_start()
		}
		{
			p.SetState(2770)
			p.Braced_constructor_extension()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2784)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 292, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2782)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 291, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBraced_constructor_prefixContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_braced_constructor_prefix)
				p.SetState(2774)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(2775)
					p.Match(GoogleSQLParserCOMMA_SYMBOL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(2776)
					p.Braced_constructor_field()
				}


			case 2:
				localctx = NewBraced_constructor_prefixContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_braced_constructor_prefix)
				p.SetState(2777)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(2778)
					p.Braced_constructor_field()
				}


			case 3:
				localctx = NewBraced_constructor_prefixContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_braced_constructor_prefix)
				p.SetState(2779)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(2780)
					p.Match(GoogleSQLParserCOMMA_SYMBOL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(2781)
					p.Braced_constructor_extension()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2786)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 292, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBraced_constructor_fieldContext is an interface to support dynamic dispatch.
type IBraced_constructor_fieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Braced_constructor_lhs() IBraced_constructor_lhsContext
	Braced_constructor_field_value() IBraced_constructor_field_valueContext

	// IsBraced_constructor_fieldContext differentiates from other interfaces.
	IsBraced_constructor_fieldContext()
}

type Braced_constructor_fieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBraced_constructor_fieldContext() *Braced_constructor_fieldContext {
	var p = new(Braced_constructor_fieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor_field
	return p
}

func InitEmptyBraced_constructor_fieldContext(p *Braced_constructor_fieldContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor_field
}

func (*Braced_constructor_fieldContext) IsBraced_constructor_fieldContext() {}

func NewBraced_constructor_fieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Braced_constructor_fieldContext {
	var p = new(Braced_constructor_fieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor_field

	return p
}

func (s *Braced_constructor_fieldContext) GetParser() antlr.Parser { return s.parser }

func (s *Braced_constructor_fieldContext) Braced_constructor_lhs() IBraced_constructor_lhsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBraced_constructor_lhsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBraced_constructor_lhsContext)
}

func (s *Braced_constructor_fieldContext) Braced_constructor_field_value() IBraced_constructor_field_valueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBraced_constructor_field_valueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBraced_constructor_field_valueContext)
}

func (s *Braced_constructor_fieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Braced_constructor_fieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Braced_constructor_fieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterBraced_constructor_field(s)
	}
}

func (s *Braced_constructor_fieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitBraced_constructor_field(s)
	}
}

func (s *Braced_constructor_fieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitBraced_constructor_field(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Braced_constructor_field() (localctx IBraced_constructor_fieldContext) {
	localctx = NewBraced_constructor_fieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, GoogleSQLParserRULE_braced_constructor_field)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2787)
		p.Braced_constructor_lhs()
	}
	{
		p.SetState(2788)
		p.Braced_constructor_field_value()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBraced_constructor_lhsContext is an interface to support dynamic dispatch.
type IBraced_constructor_lhsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Generalized_path_expression() IGeneralized_path_expressionContext

	// IsBraced_constructor_lhsContext differentiates from other interfaces.
	IsBraced_constructor_lhsContext()
}

type Braced_constructor_lhsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBraced_constructor_lhsContext() *Braced_constructor_lhsContext {
	var p = new(Braced_constructor_lhsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor_lhs
	return p
}

func InitEmptyBraced_constructor_lhsContext(p *Braced_constructor_lhsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor_lhs
}

func (*Braced_constructor_lhsContext) IsBraced_constructor_lhsContext() {}

func NewBraced_constructor_lhsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Braced_constructor_lhsContext {
	var p = new(Braced_constructor_lhsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor_lhs

	return p
}

func (s *Braced_constructor_lhsContext) GetParser() antlr.Parser { return s.parser }

func (s *Braced_constructor_lhsContext) Generalized_path_expression() IGeneralized_path_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralized_path_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralized_path_expressionContext)
}

func (s *Braced_constructor_lhsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Braced_constructor_lhsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Braced_constructor_lhsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterBraced_constructor_lhs(s)
	}
}

func (s *Braced_constructor_lhsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitBraced_constructor_lhs(s)
	}
}

func (s *Braced_constructor_lhsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitBraced_constructor_lhs(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Braced_constructor_lhs() (localctx IBraced_constructor_lhsContext) {
	localctx = NewBraced_constructor_lhsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, GoogleSQLParserRULE_braced_constructor_lhs)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2790)
		p.generalized_path_expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBraced_constructor_field_valueContext is an interface to support dynamic dispatch.
type IBraced_constructor_field_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext
	Braced_constructor() IBraced_constructorContext

	// IsBraced_constructor_field_valueContext differentiates from other interfaces.
	IsBraced_constructor_field_valueContext()
}

type Braced_constructor_field_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBraced_constructor_field_valueContext() *Braced_constructor_field_valueContext {
	var p = new(Braced_constructor_field_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor_field_value
	return p
}

func InitEmptyBraced_constructor_field_valueContext(p *Braced_constructor_field_valueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor_field_value
}

func (*Braced_constructor_field_valueContext) IsBraced_constructor_field_valueContext() {}

func NewBraced_constructor_field_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Braced_constructor_field_valueContext {
	var p = new(Braced_constructor_field_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor_field_value

	return p
}

func (s *Braced_constructor_field_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Braced_constructor_field_valueContext) COLON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOLON_SYMBOL, 0)
}

func (s *Braced_constructor_field_valueContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Braced_constructor_field_valueContext) Braced_constructor() IBraced_constructorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBraced_constructorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBraced_constructorContext)
}

func (s *Braced_constructor_field_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Braced_constructor_field_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Braced_constructor_field_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterBraced_constructor_field_value(s)
	}
}

func (s *Braced_constructor_field_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitBraced_constructor_field_value(s)
	}
}

func (s *Braced_constructor_field_valueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitBraced_constructor_field_value(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Braced_constructor_field_value() (localctx IBraced_constructor_field_valueContext) {
	localctx = NewBraced_constructor_field_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, GoogleSQLParserRULE_braced_constructor_field_value)
	p.SetState(2795)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserCOLON_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2792)
			p.Match(GoogleSQLParserCOLON_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2793)
			p.expression(0)
		}


	case GoogleSQLParserRC_BRACKET_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2794)
			p.Braced_constructor()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBraced_constructor_extensionContext is an interface to support dynamic dispatch.
type IBraced_constructor_extensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Path_expression() IPath_expressionContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsBraced_constructor_extensionContext differentiates from other interfaces.
	IsBraced_constructor_extensionContext()
}

type Braced_constructor_extensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBraced_constructor_extensionContext() *Braced_constructor_extensionContext {
	var p = new(Braced_constructor_extensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor_extension
	return p
}

func InitEmptyBraced_constructor_extensionContext(p *Braced_constructor_extensionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor_extension
}

func (*Braced_constructor_extensionContext) IsBraced_constructor_extensionContext() {}

func NewBraced_constructor_extensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Braced_constructor_extensionContext {
	var p = new(Braced_constructor_extensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_braced_constructor_extension

	return p
}

func (s *Braced_constructor_extensionContext) GetParser() antlr.Parser { return s.parser }

func (s *Braced_constructor_extensionContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Braced_constructor_extensionContext) Path_expression() IPath_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPath_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPath_expressionContext)
}

func (s *Braced_constructor_extensionContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Braced_constructor_extensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Braced_constructor_extensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Braced_constructor_extensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterBraced_constructor_extension(s)
	}
}

func (s *Braced_constructor_extensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitBraced_constructor_extension(s)
	}
}

func (s *Braced_constructor_extensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitBraced_constructor_extension(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Braced_constructor_extension() (localctx IBraced_constructor_extensionContext) {
	localctx = NewBraced_constructor_extensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, GoogleSQLParserRULE_braced_constructor_extension)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2797)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2798)
		p.path_expression(0)
	}
	{
		p.SetState(2799)
		p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INew_constructorContext is an interface to support dynamic dispatch.
type INew_constructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	New_constructor_prefix() INew_constructor_prefixContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	New_constructor_prefix_no_arg() INew_constructor_prefix_no_argContext

	// IsNew_constructorContext differentiates from other interfaces.
	IsNew_constructorContext()
}

type New_constructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNew_constructorContext() *New_constructorContext {
	var p = new(New_constructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_new_constructor
	return p
}

func InitEmptyNew_constructorContext(p *New_constructorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_new_constructor
}

func (*New_constructorContext) IsNew_constructorContext() {}

func NewNew_constructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *New_constructorContext {
	var p = new(New_constructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_new_constructor

	return p
}

func (s *New_constructorContext) GetParser() antlr.Parser { return s.parser }

func (s *New_constructorContext) New_constructor_prefix() INew_constructor_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INew_constructor_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INew_constructor_prefixContext)
}

func (s *New_constructorContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *New_constructorContext) New_constructor_prefix_no_arg() INew_constructor_prefix_no_argContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INew_constructor_prefix_no_argContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INew_constructor_prefix_no_argContext)
}

func (s *New_constructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *New_constructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *New_constructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterNew_constructor(s)
	}
}

func (s *New_constructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitNew_constructor(s)
	}
}

func (s *New_constructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitNew_constructor(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) New_constructor() (localctx INew_constructorContext) {
	localctx = NewNew_constructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, GoogleSQLParserRULE_new_constructor)
	p.SetState(2807)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2801)
			p.New_constructor_prefix()
		}
		{
			p.SetState(2802)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2804)
			p.New_constructor_prefix_no_arg()
		}
		{
			p.SetState(2805)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INew_constructor_prefixContext is an interface to support dynamic dispatch.
type INew_constructor_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	New_constructor_prefix_no_arg() INew_constructor_prefix_no_argContext
	AllNew_constructor_arg() []INew_constructor_argContext
	New_constructor_arg(i int) INew_constructor_argContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsNew_constructor_prefixContext differentiates from other interfaces.
	IsNew_constructor_prefixContext()
}

type New_constructor_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNew_constructor_prefixContext() *New_constructor_prefixContext {
	var p = new(New_constructor_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_new_constructor_prefix
	return p
}

func InitEmptyNew_constructor_prefixContext(p *New_constructor_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_new_constructor_prefix
}

func (*New_constructor_prefixContext) IsNew_constructor_prefixContext() {}

func NewNew_constructor_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *New_constructor_prefixContext {
	var p = new(New_constructor_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_new_constructor_prefix

	return p
}

func (s *New_constructor_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *New_constructor_prefixContext) New_constructor_prefix_no_arg() INew_constructor_prefix_no_argContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INew_constructor_prefix_no_argContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INew_constructor_prefix_no_argContext)
}

func (s *New_constructor_prefixContext) AllNew_constructor_arg() []INew_constructor_argContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INew_constructor_argContext); ok {
			len++
		}
	}

	tst := make([]INew_constructor_argContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INew_constructor_argContext); ok {
			tst[i] = t.(INew_constructor_argContext)
			i++
		}
	}

	return tst
}

func (s *New_constructor_prefixContext) New_constructor_arg(i int) INew_constructor_argContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INew_constructor_argContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INew_constructor_argContext)
}

func (s *New_constructor_prefixContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *New_constructor_prefixContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *New_constructor_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *New_constructor_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *New_constructor_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterNew_constructor_prefix(s)
	}
}

func (s *New_constructor_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitNew_constructor_prefix(s)
	}
}

func (s *New_constructor_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitNew_constructor_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) New_constructor_prefix() (localctx INew_constructor_prefixContext) {
	localctx = NewNew_constructor_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, GoogleSQLParserRULE_new_constructor_prefix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2809)
		p.New_constructor_prefix_no_arg()
	}
	{
		p.SetState(2810)
		p.New_constructor_arg()
	}
	p.SetState(2815)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(2811)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2812)
			p.New_constructor_arg()
		}


		p.SetState(2817)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INew_constructor_prefix_no_argContext is an interface to support dynamic dispatch.
type INew_constructor_prefix_no_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NEW_SYMBOL() antlr.TerminalNode
	Type_name() IType_nameContext
	LR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsNew_constructor_prefix_no_argContext differentiates from other interfaces.
	IsNew_constructor_prefix_no_argContext()
}

type New_constructor_prefix_no_argContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNew_constructor_prefix_no_argContext() *New_constructor_prefix_no_argContext {
	var p = new(New_constructor_prefix_no_argContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_new_constructor_prefix_no_arg
	return p
}

func InitEmptyNew_constructor_prefix_no_argContext(p *New_constructor_prefix_no_argContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_new_constructor_prefix_no_arg
}

func (*New_constructor_prefix_no_argContext) IsNew_constructor_prefix_no_argContext() {}

func NewNew_constructor_prefix_no_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *New_constructor_prefix_no_argContext {
	var p = new(New_constructor_prefix_no_argContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_new_constructor_prefix_no_arg

	return p
}

func (s *New_constructor_prefix_no_argContext) GetParser() antlr.Parser { return s.parser }

func (s *New_constructor_prefix_no_argContext) NEW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserNEW_SYMBOL, 0)
}

func (s *New_constructor_prefix_no_argContext) Type_name() IType_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *New_constructor_prefix_no_argContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *New_constructor_prefix_no_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *New_constructor_prefix_no_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *New_constructor_prefix_no_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterNew_constructor_prefix_no_arg(s)
	}
}

func (s *New_constructor_prefix_no_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitNew_constructor_prefix_no_arg(s)
	}
}

func (s *New_constructor_prefix_no_argContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitNew_constructor_prefix_no_arg(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) New_constructor_prefix_no_arg() (localctx INew_constructor_prefix_no_argContext) {
	localctx = NewNew_constructor_prefix_no_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, GoogleSQLParserRULE_new_constructor_prefix_no_arg)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2818)
		p.Match(GoogleSQLParserNEW_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2819)
		p.Type_name()
	}
	{
		p.SetState(2820)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INew_constructor_argContext is an interface to support dynamic dispatch.
type INew_constructor_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AS_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	Path_expression() IPath_expressionContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode

	// IsNew_constructor_argContext differentiates from other interfaces.
	IsNew_constructor_argContext()
}

type New_constructor_argContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNew_constructor_argContext() *New_constructor_argContext {
	var p = new(New_constructor_argContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_new_constructor_arg
	return p
}

func InitEmptyNew_constructor_argContext(p *New_constructor_argContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_new_constructor_arg
}

func (*New_constructor_argContext) IsNew_constructor_argContext() {}

func NewNew_constructor_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *New_constructor_argContext {
	var p = new(New_constructor_argContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_new_constructor_arg

	return p
}

func (s *New_constructor_argContext) GetParser() antlr.Parser { return s.parser }

func (s *New_constructor_argContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *New_constructor_argContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAS_SYMBOL, 0)
}

func (s *New_constructor_argContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *New_constructor_argContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *New_constructor_argContext) Path_expression() IPath_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPath_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPath_expressionContext)
}

func (s *New_constructor_argContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *New_constructor_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *New_constructor_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *New_constructor_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterNew_constructor_arg(s)
	}
}

func (s *New_constructor_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitNew_constructor_arg(s)
	}
}

func (s *New_constructor_argContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitNew_constructor_arg(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) New_constructor_arg() (localctx INew_constructor_argContext) {
	localctx = NewNew_constructor_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, GoogleSQLParserRULE_new_constructor_arg)
	p.SetState(2833)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 296, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2822)
			p.expression(0)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2823)
			p.expression(0)
		}
		{
			p.SetState(2824)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2825)
			p.Identifier()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2827)
			p.expression(0)
		}
		{
			p.SetState(2828)
			p.Match(GoogleSQLParserAS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2829)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2830)
			p.path_expression(0)
		}
		{
			p.SetState(2831)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IArray_constructorContext is an interface to support dynamic dispatch.
type IArray_constructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Array_constructor_prefix_no_expressions() IArray_constructor_prefix_no_expressionsContext
	RS_BRACKET_SYMBOL() antlr.TerminalNode
	Array_constructor_prefix() IArray_constructor_prefixContext

	// IsArray_constructorContext differentiates from other interfaces.
	IsArray_constructorContext()
}

type Array_constructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_constructorContext() *Array_constructorContext {
	var p = new(Array_constructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_array_constructor
	return p
}

func InitEmptyArray_constructorContext(p *Array_constructorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_array_constructor
}

func (*Array_constructorContext) IsArray_constructorContext() {}

func NewArray_constructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_constructorContext {
	var p = new(Array_constructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_array_constructor

	return p
}

func (s *Array_constructorContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_constructorContext) Array_constructor_prefix_no_expressions() IArray_constructor_prefix_no_expressionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_constructor_prefix_no_expressionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_constructor_prefix_no_expressionsContext)
}

func (s *Array_constructorContext) RS_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRS_BRACKET_SYMBOL, 0)
}

func (s *Array_constructorContext) Array_constructor_prefix() IArray_constructor_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_constructor_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_constructor_prefixContext)
}

func (s *Array_constructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_constructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Array_constructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterArray_constructor(s)
	}
}

func (s *Array_constructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitArray_constructor(s)
	}
}

func (s *Array_constructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitArray_constructor(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Array_constructor() (localctx IArray_constructorContext) {
	localctx = NewArray_constructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, GoogleSQLParserRULE_array_constructor)
	p.SetState(2841)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 297, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2835)
			p.Array_constructor_prefix_no_expressions()
		}
		{
			p.SetState(2836)
			p.Match(GoogleSQLParserRS_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2838)
			p.Array_constructor_prefix()
		}
		{
			p.SetState(2839)
			p.Match(GoogleSQLParserRS_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IArray_constructor_prefixContext is an interface to support dynamic dispatch.
type IArray_constructor_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Array_constructor_prefix_no_expressions() IArray_constructor_prefix_no_expressionsContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsArray_constructor_prefixContext differentiates from other interfaces.
	IsArray_constructor_prefixContext()
}

type Array_constructor_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_constructor_prefixContext() *Array_constructor_prefixContext {
	var p = new(Array_constructor_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_array_constructor_prefix
	return p
}

func InitEmptyArray_constructor_prefixContext(p *Array_constructor_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_array_constructor_prefix
}

func (*Array_constructor_prefixContext) IsArray_constructor_prefixContext() {}

func NewArray_constructor_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_constructor_prefixContext {
	var p = new(Array_constructor_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_array_constructor_prefix

	return p
}

func (s *Array_constructor_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_constructor_prefixContext) Array_constructor_prefix_no_expressions() IArray_constructor_prefix_no_expressionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_constructor_prefix_no_expressionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_constructor_prefix_no_expressionsContext)
}

func (s *Array_constructor_prefixContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Array_constructor_prefixContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Array_constructor_prefixContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Array_constructor_prefixContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Array_constructor_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_constructor_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Array_constructor_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterArray_constructor_prefix(s)
	}
}

func (s *Array_constructor_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitArray_constructor_prefix(s)
	}
}

func (s *Array_constructor_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitArray_constructor_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Array_constructor_prefix() (localctx IArray_constructor_prefixContext) {
	localctx = NewArray_constructor_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, GoogleSQLParserRULE_array_constructor_prefix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2843)
		p.Array_constructor_prefix_no_expressions()
	}
	{
		p.SetState(2844)
		p.expression(0)
	}
	p.SetState(2849)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(2845)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2846)
			p.expression(0)
		}


		p.SetState(2851)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IArray_constructor_prefix_no_expressionsContext is an interface to support dynamic dispatch.
type IArray_constructor_prefix_no_expressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_SYMBOL() antlr.TerminalNode
	LS_BRACKET_SYMBOL() antlr.TerminalNode
	Array_type() IArray_typeContext

	// IsArray_constructor_prefix_no_expressionsContext differentiates from other interfaces.
	IsArray_constructor_prefix_no_expressionsContext()
}

type Array_constructor_prefix_no_expressionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_constructor_prefix_no_expressionsContext() *Array_constructor_prefix_no_expressionsContext {
	var p = new(Array_constructor_prefix_no_expressionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_array_constructor_prefix_no_expressions
	return p
}

func InitEmptyArray_constructor_prefix_no_expressionsContext(p *Array_constructor_prefix_no_expressionsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_array_constructor_prefix_no_expressions
}

func (*Array_constructor_prefix_no_expressionsContext) IsArray_constructor_prefix_no_expressionsContext() {}

func NewArray_constructor_prefix_no_expressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_constructor_prefix_no_expressionsContext {
	var p = new(Array_constructor_prefix_no_expressionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_array_constructor_prefix_no_expressions

	return p
}

func (s *Array_constructor_prefix_no_expressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_constructor_prefix_no_expressionsContext) ARRAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserARRAY_SYMBOL, 0)
}

func (s *Array_constructor_prefix_no_expressionsContext) LS_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLS_BRACKET_SYMBOL, 0)
}

func (s *Array_constructor_prefix_no_expressionsContext) Array_type() IArray_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_typeContext)
}

func (s *Array_constructor_prefix_no_expressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_constructor_prefix_no_expressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Array_constructor_prefix_no_expressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterArray_constructor_prefix_no_expressions(s)
	}
}

func (s *Array_constructor_prefix_no_expressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitArray_constructor_prefix_no_expressions(s)
	}
}

func (s *Array_constructor_prefix_no_expressionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitArray_constructor_prefix_no_expressions(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Array_constructor_prefix_no_expressions() (localctx IArray_constructor_prefix_no_expressionsContext) {
	localctx = NewArray_constructor_prefix_no_expressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, GoogleSQLParserRULE_array_constructor_prefix_no_expressions)
	p.SetState(2856)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 299, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2852)
			p.Match(GoogleSQLParserARRAY_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2853)
			p.Match(GoogleSQLParserLS_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2854)
			p.Match(GoogleSQLParserLS_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2855)
			p.Array_type()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRange_literalContext is an interface to support dynamic dispatch.
type IRange_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Range_type() IRange_typeContext
	String_literal() IString_literalContext

	// IsRange_literalContext differentiates from other interfaces.
	IsRange_literalContext()
}

type Range_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_literalContext() *Range_literalContext {
	var p = new(Range_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_range_literal
	return p
}

func InitEmptyRange_literalContext(p *Range_literalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_range_literal
}

func (*Range_literalContext) IsRange_literalContext() {}

func NewRange_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_literalContext {
	var p = new(Range_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_range_literal

	return p
}

func (s *Range_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_literalContext) Range_type() IRange_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRange_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRange_typeContext)
}

func (s *Range_literalContext) String_literal() IString_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_literalContext)
}

func (s *Range_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Range_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterRange_literal(s)
	}
}

func (s *Range_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitRange_literal(s)
	}
}

func (s *Range_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitRange_literal(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Range_literal() (localctx IRange_literalContext) {
	localctx = NewRange_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, GoogleSQLParserRULE_range_literal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2858)
		p.Range_type()
	}
	{
		p.SetState(2859)
		p.string_literal(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRange_typeContext is an interface to support dynamic dispatch.
type IRange_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RANGE_SYMBOL() antlr.TerminalNode
	Template_type_open() ITemplate_type_openContext
	Type_() ITypeContext
	Template_type_close() ITemplate_type_closeContext

	// IsRange_typeContext differentiates from other interfaces.
	IsRange_typeContext()
}

type Range_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_typeContext() *Range_typeContext {
	var p = new(Range_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_range_type
	return p
}

func InitEmptyRange_typeContext(p *Range_typeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_range_type
}

func (*Range_typeContext) IsRange_typeContext() {}

func NewRange_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_typeContext {
	var p = new(Range_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_range_type

	return p
}

func (s *Range_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_typeContext) RANGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRANGE_SYMBOL, 0)
}

func (s *Range_typeContext) Template_type_open() ITemplate_type_openContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplate_type_openContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplate_type_openContext)
}

func (s *Range_typeContext) Type_() ITypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Range_typeContext) Template_type_close() ITemplate_type_closeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplate_type_closeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplate_type_closeContext)
}

func (s *Range_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Range_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterRange_type(s)
	}
}

func (s *Range_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitRange_type(s)
	}
}

func (s *Range_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitRange_type(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Range_type() (localctx IRange_typeContext) {
	localctx = NewRange_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, GoogleSQLParserRULE_range_type)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2861)
		p.Match(GoogleSQLParserRANGE_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2862)
		p.Template_type_open()
	}
	{
		p.SetState(2863)
		p.Type_()
	}
	{
		p.SetState(2864)
		p.Template_type_close()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Raw_type() IRaw_typeContext
	Opt_type_parameters() IOpt_type_parametersContext
	Collate_clause() ICollate_clauseContext

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_type
	return p
}

func InitEmptyTypeContext(p *TypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_type
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) Raw_type() IRaw_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRaw_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRaw_typeContext)
}

func (s *TypeContext) Opt_type_parameters() IOpt_type_parametersContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_type_parametersContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_type_parametersContext)
}

func (s *TypeContext) Collate_clause() ICollate_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollate_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollate_clauseContext)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterType(s)
	}
}

func (s *TypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitType(s)
	}
}

func (s *TypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Type_() (localctx ITypeContext) {
	localctx = NewTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, GoogleSQLParserRULE_type)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2866)
		p.Raw_type()
	}
	p.SetState(2868)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserLR_BRACKET_SYMBOL {
		{
			p.SetState(2867)
			p.Opt_type_parameters()
		}

	}
	p.SetState(2871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoogleSQLParserCOLLATE_SYMBOL {
		{
			p.SetState(2870)
			p.Collate_clause()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICollate_clauseContext is an interface to support dynamic dispatch.
type ICollate_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLLATE_SYMBOL() antlr.TerminalNode
	String_literal_or_parameter() IString_literal_or_parameterContext

	// IsCollate_clauseContext differentiates from other interfaces.
	IsCollate_clauseContext()
}

type Collate_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollate_clauseContext() *Collate_clauseContext {
	var p = new(Collate_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_collate_clause
	return p
}

func InitEmptyCollate_clauseContext(p *Collate_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_collate_clause
}

func (*Collate_clauseContext) IsCollate_clauseContext() {}

func NewCollate_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collate_clauseContext {
	var p = new(Collate_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_collate_clause

	return p
}

func (s *Collate_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Collate_clauseContext) COLLATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOLLATE_SYMBOL, 0)
}

func (s *Collate_clauseContext) String_literal_or_parameter() IString_literal_or_parameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_literal_or_parameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_literal_or_parameterContext)
}

func (s *Collate_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collate_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Collate_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterCollate_clause(s)
	}
}

func (s *Collate_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitCollate_clause(s)
	}
}

func (s *Collate_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitCollate_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Collate_clause() (localctx ICollate_clauseContext) {
	localctx = NewCollate_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, GoogleSQLParserRULE_collate_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2873)
		p.Match(GoogleSQLParserCOLLATE_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2874)
		p.String_literal_or_parameter()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IString_literal_or_parameterContext is an interface to support dynamic dispatch.
type IString_literal_or_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	String_literal() IString_literalContext
	Parameter_expression() IParameter_expressionContext
	System_variable_expression() ISystem_variable_expressionContext

	// IsString_literal_or_parameterContext differentiates from other interfaces.
	IsString_literal_or_parameterContext()
}

type String_literal_or_parameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_literal_or_parameterContext() *String_literal_or_parameterContext {
	var p = new(String_literal_or_parameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_string_literal_or_parameter
	return p
}

func InitEmptyString_literal_or_parameterContext(p *String_literal_or_parameterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_string_literal_or_parameter
}

func (*String_literal_or_parameterContext) IsString_literal_or_parameterContext() {}

func NewString_literal_or_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_literal_or_parameterContext {
	var p = new(String_literal_or_parameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_string_literal_or_parameter

	return p
}

func (s *String_literal_or_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *String_literal_or_parameterContext) String_literal() IString_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_literalContext)
}

func (s *String_literal_or_parameterContext) Parameter_expression() IParameter_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameter_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameter_expressionContext)
}

func (s *String_literal_or_parameterContext) System_variable_expression() ISystem_variable_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystem_variable_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystem_variable_expressionContext)
}

func (s *String_literal_or_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_literal_or_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *String_literal_or_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterString_literal_or_parameter(s)
	}
}

func (s *String_literal_or_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitString_literal_or_parameter(s)
	}
}

func (s *String_literal_or_parameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitString_literal_or_parameter(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) String_literal_or_parameter() (localctx IString_literal_or_parameterContext) {
	localctx = NewString_literal_or_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, GoogleSQLParserRULE_string_literal_or_parameter)
	p.SetState(2879)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2876)
			p.string_literal(0)
		}


	case GoogleSQLParserQUESTION_SYMBOL, GoogleSQLParserAT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2877)
			p.Parameter_expression()
		}


	case GoogleSQLParserATAT_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2878)
			p.System_variable_expression()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISystem_variable_expressionContext is an interface to support dynamic dispatch.
type ISystem_variable_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ATAT_SYMBOL() antlr.TerminalNode
	Path_expression() IPath_expressionContext

	// IsSystem_variable_expressionContext differentiates from other interfaces.
	IsSystem_variable_expressionContext()
}

type System_variable_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_variable_expressionContext() *System_variable_expressionContext {
	var p = new(System_variable_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_system_variable_expression
	return p
}

func InitEmptySystem_variable_expressionContext(p *System_variable_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_system_variable_expression
}

func (*System_variable_expressionContext) IsSystem_variable_expressionContext() {}

func NewSystem_variable_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_variable_expressionContext {
	var p = new(System_variable_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_system_variable_expression

	return p
}

func (s *System_variable_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *System_variable_expressionContext) ATAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserATAT_SYMBOL, 0)
}

func (s *System_variable_expressionContext) Path_expression() IPath_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPath_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPath_expressionContext)
}

func (s *System_variable_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_variable_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *System_variable_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSystem_variable_expression(s)
	}
}

func (s *System_variable_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSystem_variable_expression(s)
	}
}

func (s *System_variable_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSystem_variable_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) System_variable_expression() (localctx ISystem_variable_expressionContext) {
	localctx = NewSystem_variable_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, GoogleSQLParserRULE_system_variable_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2881)
		p.Match(GoogleSQLParserATAT_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2882)
		p.path_expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IParameter_expressionContext is an interface to support dynamic dispatch.
type IParameter_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Named_parameter_expression() INamed_parameter_expressionContext
	QUESTION_SYMBOL() antlr.TerminalNode

	// IsParameter_expressionContext differentiates from other interfaces.
	IsParameter_expressionContext()
}

type Parameter_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_expressionContext() *Parameter_expressionContext {
	var p = new(Parameter_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_parameter_expression
	return p
}

func InitEmptyParameter_expressionContext(p *Parameter_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_parameter_expression
}

func (*Parameter_expressionContext) IsParameter_expressionContext() {}

func NewParameter_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_expressionContext {
	var p = new(Parameter_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_parameter_expression

	return p
}

func (s *Parameter_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_expressionContext) Named_parameter_expression() INamed_parameter_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_parameter_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_parameter_expressionContext)
}

func (s *Parameter_expressionContext) QUESTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserQUESTION_SYMBOL, 0)
}

func (s *Parameter_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Parameter_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterParameter_expression(s)
	}
}

func (s *Parameter_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitParameter_expression(s)
	}
}

func (s *Parameter_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitParameter_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Parameter_expression() (localctx IParameter_expressionContext) {
	localctx = NewParameter_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, GoogleSQLParserRULE_parameter_expression)
	p.SetState(2886)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserAT_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2884)
			p.Named_parameter_expression()
		}


	case GoogleSQLParserQUESTION_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2885)
			p.Match(GoogleSQLParserQUESTION_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INamed_parameter_expressionContext is an interface to support dynamic dispatch.
type INamed_parameter_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsNamed_parameter_expressionContext differentiates from other interfaces.
	IsNamed_parameter_expressionContext()
}

type Named_parameter_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_parameter_expressionContext() *Named_parameter_expressionContext {
	var p = new(Named_parameter_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_named_parameter_expression
	return p
}

func InitEmptyNamed_parameter_expressionContext(p *Named_parameter_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_named_parameter_expression
}

func (*Named_parameter_expressionContext) IsNamed_parameter_expressionContext() {}

func NewNamed_parameter_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_parameter_expressionContext {
	var p = new(Named_parameter_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_named_parameter_expression

	return p
}

func (s *Named_parameter_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_parameter_expressionContext) AT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAT_SYMBOL, 0)
}

func (s *Named_parameter_expressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Named_parameter_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_parameter_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Named_parameter_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterNamed_parameter_expression(s)
	}
}

func (s *Named_parameter_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitNamed_parameter_expression(s)
	}
}

func (s *Named_parameter_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitNamed_parameter_expression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Named_parameter_expression() (localctx INamed_parameter_expressionContext) {
	localctx = NewNamed_parameter_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, GoogleSQLParserRULE_named_parameter_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2888)
		p.Match(GoogleSQLParserAT_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2889)
		p.Identifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpt_type_parametersContext is an interface to support dynamic dispatch.
type IOpt_type_parametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_parameters_prefix() IType_parameters_prefixContext
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	COMMA_SYMBOL() antlr.TerminalNode

	// IsOpt_type_parametersContext differentiates from other interfaces.
	IsOpt_type_parametersContext()
}

type Opt_type_parametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_type_parametersContext() *Opt_type_parametersContext {
	var p = new(Opt_type_parametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_type_parameters
	return p
}

func InitEmptyOpt_type_parametersContext(p *Opt_type_parametersContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_opt_type_parameters
}

func (*Opt_type_parametersContext) IsOpt_type_parametersContext() {}

func NewOpt_type_parametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_type_parametersContext {
	var p = new(Opt_type_parametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_opt_type_parameters

	return p
}

func (s *Opt_type_parametersContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_type_parametersContext) Type_parameters_prefix() IType_parameters_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_parameters_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_parameters_prefixContext)
}

func (s *Opt_type_parametersContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Opt_type_parametersContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, 0)
}

func (s *Opt_type_parametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_type_parametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Opt_type_parametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterOpt_type_parameters(s)
	}
}

func (s *Opt_type_parametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitOpt_type_parameters(s)
	}
}

func (s *Opt_type_parametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitOpt_type_parameters(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Opt_type_parameters() (localctx IOpt_type_parametersContext) {
	localctx = NewOpt_type_parametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, GoogleSQLParserRULE_opt_type_parameters)
	p.SetState(2899)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 304, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2891)
			p.Type_parameters_prefix()
		}
		{
			p.SetState(2892)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2894)
			p.Type_parameters_prefix()
		}
		{
			p.SetState(2895)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2896)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		 p.NotifyErrorListeners("Syntax error: Trailing comma in type
			 parameters list is not allowed.", nil, nil); 

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_parameters_prefixContext is an interface to support dynamic dispatch.
type IType_parameters_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	AllType_parameter() []IType_parameterContext
	Type_parameter(i int) IType_parameterContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsType_parameters_prefixContext differentiates from other interfaces.
	IsType_parameters_prefixContext()
}

type Type_parameters_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_parameters_prefixContext() *Type_parameters_prefixContext {
	var p = new(Type_parameters_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_type_parameters_prefix
	return p
}

func InitEmptyType_parameters_prefixContext(p *Type_parameters_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_type_parameters_prefix
}

func (*Type_parameters_prefixContext) IsType_parameters_prefixContext() {}

func NewType_parameters_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_parameters_prefixContext {
	var p = new(Type_parameters_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_type_parameters_prefix

	return p
}

func (s *Type_parameters_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_parameters_prefixContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Type_parameters_prefixContext) AllType_parameter() []IType_parameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IType_parameterContext); ok {
			len++
		}
	}

	tst := make([]IType_parameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IType_parameterContext); ok {
			tst[i] = t.(IType_parameterContext)
			i++
		}
	}

	return tst
}

func (s *Type_parameters_prefixContext) Type_parameter(i int) IType_parameterContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_parameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_parameterContext)
}

func (s *Type_parameters_prefixContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Type_parameters_prefixContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Type_parameters_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_parameters_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_parameters_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterType_parameters_prefix(s)
	}
}

func (s *Type_parameters_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitType_parameters_prefix(s)
	}
}

func (s *Type_parameters_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitType_parameters_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Type_parameters_prefix() (localctx IType_parameters_prefixContext) {
	localctx = NewType_parameters_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, GoogleSQLParserRULE_type_parameters_prefix)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2901)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2902)
		p.Type_parameter()
	}
	p.SetState(2907)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 305, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2903)
				p.Match(GoogleSQLParserCOMMA_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2904)
				p.Type_parameter()
			}


		}
		p.SetState(2909)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 305, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_parameterContext is an interface to support dynamic dispatch.
type IType_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Integer_literal() IInteger_literalContext
	Boolean_literal() IBoolean_literalContext
	String_literal() IString_literalContext
	Bytes_literal() IBytes_literalContext
	Floating_point_literal() IFloating_point_literalContext
	MAX_SYMBOL() antlr.TerminalNode

	// IsType_parameterContext differentiates from other interfaces.
	IsType_parameterContext()
}

type Type_parameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_parameterContext() *Type_parameterContext {
	var p = new(Type_parameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_type_parameter
	return p
}

func InitEmptyType_parameterContext(p *Type_parameterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_type_parameter
}

func (*Type_parameterContext) IsType_parameterContext() {}

func NewType_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_parameterContext {
	var p = new(Type_parameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_type_parameter

	return p
}

func (s *Type_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_parameterContext) Integer_literal() IInteger_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInteger_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInteger_literalContext)
}

func (s *Type_parameterContext) Boolean_literal() IBoolean_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoolean_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoolean_literalContext)
}

func (s *Type_parameterContext) String_literal() IString_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_literalContext)
}

func (s *Type_parameterContext) Bytes_literal() IBytes_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBytes_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBytes_literalContext)
}

func (s *Type_parameterContext) Floating_point_literal() IFloating_point_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloating_point_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloating_point_literalContext)
}

func (s *Type_parameterContext) MAX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMAX_SYMBOL, 0)
}

func (s *Type_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterType_parameter(s)
	}
}

func (s *Type_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitType_parameter(s)
	}
}

func (s *Type_parameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitType_parameter(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Type_parameter() (localctx IType_parameterContext) {
	localctx = NewType_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, GoogleSQLParserRULE_type_parameter)
	p.SetState(2916)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserINTEGER_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2910)
			p.Integer_literal()
		}


	case GoogleSQLParserTRUE_SYMBOL, GoogleSQLParserFALSE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2911)
			p.Boolean_literal()
		}


	case GoogleSQLParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2912)
			p.string_literal(0)
		}


	case GoogleSQLParserBYTES_LITERAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2913)
			p.bytes_literal(0)
		}


	case GoogleSQLParserFLOAT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2914)
			p.Floating_point_literal()
		}


	case GoogleSQLParserMAX_SYMBOL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2915)
			p.Match(GoogleSQLParserMAX_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRaw_typeContext is an interface to support dynamic dispatch.
type IRaw_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Array_type() IArray_typeContext
	Struct_type() IStruct_typeContext
	Type_name() IType_nameContext
	Range_type() IRange_typeContext
	Function_type() IFunction_typeContext
	Map_type() IMap_typeContext

	// IsRaw_typeContext differentiates from other interfaces.
	IsRaw_typeContext()
}

type Raw_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaw_typeContext() *Raw_typeContext {
	var p = new(Raw_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_raw_type
	return p
}

func InitEmptyRaw_typeContext(p *Raw_typeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_raw_type
}

func (*Raw_typeContext) IsRaw_typeContext() {}

func NewRaw_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Raw_typeContext {
	var p = new(Raw_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_raw_type

	return p
}

func (s *Raw_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Raw_typeContext) Array_type() IArray_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_typeContext)
}

func (s *Raw_typeContext) Struct_type() IStruct_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_typeContext)
}

func (s *Raw_typeContext) Type_name() IType_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Raw_typeContext) Range_type() IRange_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRange_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRange_typeContext)
}

func (s *Raw_typeContext) Function_type() IFunction_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_typeContext)
}

func (s *Raw_typeContext) Map_type() IMap_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMap_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMap_typeContext)
}

func (s *Raw_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Raw_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Raw_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterRaw_type(s)
	}
}

func (s *Raw_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitRaw_type(s)
	}
}

func (s *Raw_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitRaw_type(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Raw_type() (localctx IRaw_typeContext) {
	localctx = NewRaw_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, GoogleSQLParserRULE_raw_type)
	p.SetState(2924)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 307, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2918)
			p.Array_type()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2919)
			p.Struct_type()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2920)
			p.Type_name()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2921)
			p.Range_type()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2922)
			p.Function_type()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2923)
			p.Map_type()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMap_typeContext is an interface to support dynamic dispatch.
type IMap_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey_type returns the key_type rule contexts.
	GetKey_type() ITypeContext

	// GetValue_type returns the value_type rule contexts.
	GetValue_type() ITypeContext


	// SetKey_type sets the key_type rule contexts.
	SetKey_type(ITypeContext)

	// SetValue_type sets the value_type rule contexts.
	SetValue_type(ITypeContext)


	// Getter signatures
	MAP_SYMBOL() antlr.TerminalNode
	Template_type_open() ITemplate_type_openContext
	COMMA_SYMBOL() antlr.TerminalNode
	Template_type_close() ITemplate_type_closeContext
	AllType_() []ITypeContext
	Type_(i int) ITypeContext

	// IsMap_typeContext differentiates from other interfaces.
	IsMap_typeContext()
}

type Map_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key_type ITypeContext 
	value_type ITypeContext 
}

func NewEmptyMap_typeContext() *Map_typeContext {
	var p = new(Map_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_map_type
	return p
}

func InitEmptyMap_typeContext(p *Map_typeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_map_type
}

func (*Map_typeContext) IsMap_typeContext() {}

func NewMap_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Map_typeContext {
	var p = new(Map_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_map_type

	return p
}

func (s *Map_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Map_typeContext) GetKey_type() ITypeContext { return s.key_type }

func (s *Map_typeContext) GetValue_type() ITypeContext { return s.value_type }


func (s *Map_typeContext) SetKey_type(v ITypeContext) { s.key_type = v }

func (s *Map_typeContext) SetValue_type(v ITypeContext) { s.value_type = v }


func (s *Map_typeContext) MAP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMAP_SYMBOL, 0)
}

func (s *Map_typeContext) Template_type_open() ITemplate_type_openContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplate_type_openContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplate_type_openContext)
}

func (s *Map_typeContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, 0)
}

func (s *Map_typeContext) Template_type_close() ITemplate_type_closeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplate_type_closeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplate_type_closeContext)
}

func (s *Map_typeContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *Map_typeContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Map_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Map_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Map_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterMap_type(s)
	}
}

func (s *Map_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitMap_type(s)
	}
}

func (s *Map_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitMap_type(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Map_type() (localctx IMap_typeContext) {
	localctx = NewMap_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, GoogleSQLParserRULE_map_type)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2926)
		p.Match(GoogleSQLParserMAP_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2927)
		p.Template_type_open()
	}
	{
		p.SetState(2928)

		var _x = p.Type_()


		localctx.(*Map_typeContext).key_type = _x
	}
	{
		p.SetState(2929)
		p.Match(GoogleSQLParserCOMMA_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2930)

		var _x = p.Type_()


		localctx.(*Map_typeContext).value_type = _x
	}
	{
		p.SetState(2931)
		p.Template_type_close()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunction_typeContext is an interface to support dynamic dispatch.
type IFunction_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetReturn_type returns the return_type rule contexts.
	GetReturn_type() ITypeContext

	// GetArg_type returns the arg_type rule contexts.
	GetArg_type() ITypeContext

	// GetArg_list returns the arg_list rule contexts.
	GetArg_list() IFunction_type_prefixContext


	// SetReturn_type sets the return_type rule contexts.
	SetReturn_type(ITypeContext)

	// SetArg_type sets the arg_type rule contexts.
	SetArg_type(ITypeContext)

	// SetArg_list sets the arg_list rule contexts.
	SetArg_list(IFunction_type_prefixContext)


	// Getter signatures
	FUNCTION_SYMBOL() antlr.TerminalNode
	Template_type_open() ITemplate_type_openContext
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	RR_BRACKET_SYMBOL() antlr.TerminalNode
	SUB_GT_BRACKET_SYMBOL() antlr.TerminalNode
	Template_type_close() ITemplate_type_closeContext
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	Function_type_prefix() IFunction_type_prefixContext

	// IsFunction_typeContext differentiates from other interfaces.
	IsFunction_typeContext()
}

type Function_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	return_type ITypeContext 
	arg_type ITypeContext 
	arg_list IFunction_type_prefixContext 
}

func NewEmptyFunction_typeContext() *Function_typeContext {
	var p = new(Function_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_function_type
	return p
}

func InitEmptyFunction_typeContext(p *Function_typeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_function_type
}

func (*Function_typeContext) IsFunction_typeContext() {}

func NewFunction_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_typeContext {
	var p = new(Function_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_function_type

	return p
}

func (s *Function_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_typeContext) GetReturn_type() ITypeContext { return s.return_type }

func (s *Function_typeContext) GetArg_type() ITypeContext { return s.arg_type }

func (s *Function_typeContext) GetArg_list() IFunction_type_prefixContext { return s.arg_list }


func (s *Function_typeContext) SetReturn_type(v ITypeContext) { s.return_type = v }

func (s *Function_typeContext) SetArg_type(v ITypeContext) { s.arg_type = v }

func (s *Function_typeContext) SetArg_list(v IFunction_type_prefixContext) { s.arg_list = v }


func (s *Function_typeContext) FUNCTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFUNCTION_SYMBOL, 0)
}

func (s *Function_typeContext) Template_type_open() ITemplate_type_openContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplate_type_openContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplate_type_openContext)
}

func (s *Function_typeContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Function_typeContext) RR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRR_BRACKET_SYMBOL, 0)
}

func (s *Function_typeContext) SUB_GT_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSUB_GT_BRACKET_SYMBOL, 0)
}

func (s *Function_typeContext) Template_type_close() ITemplate_type_closeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplate_type_closeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplate_type_closeContext)
}

func (s *Function_typeContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *Function_typeContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Function_typeContext) Function_type_prefix() IFunction_type_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_type_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_type_prefixContext)
}

func (s *Function_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Function_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterFunction_type(s)
	}
}

func (s *Function_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitFunction_type(s)
	}
}

func (s *Function_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitFunction_type(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Function_type() (localctx IFunction_typeContext) {
	localctx = NewFunction_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, GoogleSQLParserRULE_function_type)
	p.SetState(2954)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 308, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2933)
			p.Match(GoogleSQLParserFUNCTION_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2934)
			p.Template_type_open()
		}
		{
			p.SetState(2935)
			p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2936)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2937)
			p.Match(GoogleSQLParserSUB_GT_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2938)

			var _x = p.Type_()


			localctx.(*Function_typeContext).return_type = _x
		}
		{
			p.SetState(2939)
			p.Template_type_close()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2941)
			p.Match(GoogleSQLParserFUNCTION_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2942)
			p.Template_type_open()
		}
		{
			p.SetState(2943)

			var _x = p.Type_()


			localctx.(*Function_typeContext).arg_type = _x
		}
		{
			p.SetState(2944)
			p.Match(GoogleSQLParserSUB_GT_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2945)

			var _x = p.Type_()


			localctx.(*Function_typeContext).return_type = _x
		}
		{
			p.SetState(2946)
			p.Template_type_close()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2948)

			var _x = p.Function_type_prefix()


			localctx.(*Function_typeContext).arg_list = _x
		}
		{
			p.SetState(2949)
			p.Match(GoogleSQLParserRR_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2950)
			p.Match(GoogleSQLParserSUB_GT_BRACKET_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2951)

			var _x = p.Type_()


			localctx.(*Function_typeContext).return_type = _x
		}
		{
			p.SetState(2952)
			p.Template_type_close()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunction_type_prefixContext is an interface to support dynamic dispatch.
type IFunction_type_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNCTION_SYMBOL() antlr.TerminalNode
	Template_type_open() ITemplate_type_openContext
	LR_BRACKET_SYMBOL() antlr.TerminalNode
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsFunction_type_prefixContext differentiates from other interfaces.
	IsFunction_type_prefixContext()
}

type Function_type_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_type_prefixContext() *Function_type_prefixContext {
	var p = new(Function_type_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_function_type_prefix
	return p
}

func InitEmptyFunction_type_prefixContext(p *Function_type_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_function_type_prefix
}

func (*Function_type_prefixContext) IsFunction_type_prefixContext() {}

func NewFunction_type_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_type_prefixContext {
	var p = new(Function_type_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_function_type_prefix

	return p
}

func (s *Function_type_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_type_prefixContext) FUNCTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFUNCTION_SYMBOL, 0)
}

func (s *Function_type_prefixContext) Template_type_open() ITemplate_type_openContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplate_type_openContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplate_type_openContext)
}

func (s *Function_type_prefixContext) LR_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLR_BRACKET_SYMBOL, 0)
}

func (s *Function_type_prefixContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *Function_type_prefixContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Function_type_prefixContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(GoogleSQLParserCOMMA_SYMBOL)
}

func (s *Function_type_prefixContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMA_SYMBOL, i)
}

func (s *Function_type_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_type_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Function_type_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterFunction_type_prefix(s)
	}
}

func (s *Function_type_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitFunction_type_prefix(s)
	}
}

func (s *Function_type_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitFunction_type_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Function_type_prefix() (localctx IFunction_type_prefixContext) {
	localctx = NewFunction_type_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, GoogleSQLParserRULE_function_type_prefix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2956)
		p.Match(GoogleSQLParserFUNCTION_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2957)
		p.Template_type_open()
	}
	{
		p.SetState(2958)
		p.Match(GoogleSQLParserLR_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2959)
		p.Type_()
	}
	p.SetState(2964)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoogleSQLParserCOMMA_SYMBOL {
		{
			p.SetState(2960)
			p.Match(GoogleSQLParserCOMMA_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2961)
			p.Type_()
		}


		p.SetState(2966)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_nameContext is an interface to support dynamic dispatch.
type IType_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Path_expression() IPath_expressionContext
	INTERVAL_SYMBOL() antlr.TerminalNode

	// IsType_nameContext differentiates from other interfaces.
	IsType_nameContext()
}

type Type_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_nameContext() *Type_nameContext {
	var p = new(Type_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_type_name
	return p
}

func InitEmptyType_nameContext(p *Type_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_type_name
}

func (*Type_nameContext) IsType_nameContext() {}

func NewType_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_nameContext {
	var p = new(Type_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_type_name

	return p
}

func (s *Type_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_nameContext) Path_expression() IPath_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPath_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPath_expressionContext)
}

func (s *Type_nameContext) INTERVAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINTERVAL_SYMBOL, 0)
}

func (s *Type_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterType_name(s)
	}
}

func (s *Type_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitType_name(s)
	}
}

func (s *Type_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitType_name(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Type_name() (localctx IType_nameContext) {
	localctx = NewType_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, GoogleSQLParserRULE_type_name)
	p.SetState(2969)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserINCLUDE_SYMBOL, GoogleSQLParserOFFSET_SYMBOL, GoogleSQLParserOPTIONS_SYMBOL, GoogleSQLParserPERCENT_SYMBOL, GoogleSQLParserPIVOT_SYMBOL, GoogleSQLParserREPLACE_SYMBOL, GoogleSQLParserUNPIVOT_SYMBOL, GoogleSQLParserSYSTEM_SYMBOL, GoogleSQLParserSYSTEM_TIME_SYMBOL, GoogleSQLParserVALUE_SYMBOL, GoogleSQLParserNUMERIC_SYMBOL, GoogleSQLParserDECIMAL_SYMBOL, GoogleSQLParserBIGNUMERIC_SYMBOL, GoogleSQLParserBIGDECIMAL_SYMBOL, GoogleSQLParserJSON_SYMBOL, GoogleSQLParserDATE_SYMBOL, GoogleSQLParserTIME_SYMBOL, GoogleSQLParserDATETIME_SYMBOL, GoogleSQLParserTIMESTAMP_SYMBOL, GoogleSQLParserSIMPLE_SYMBOL, GoogleSQLParserABORT_SYMBOL, GoogleSQLParserACCESS_SYMBOL, GoogleSQLParserACTION_SYMBOL, GoogleSQLParserAGGREGATE_SYMBOL, GoogleSQLParserADD_SYMBOL, GoogleSQLParserALTER_SYMBOL, GoogleSQLParserALWAYS_SYMBOL, GoogleSQLParserANALYZE_SYMBOL, GoogleSQLParserAPPROX_SYMBOL, GoogleSQLParserARE_SYMBOL, GoogleSQLParserASSERT_SYMBOL, GoogleSQLParserBATCH_SYMBOL, GoogleSQLParserBEGIN_SYMBOL, GoogleSQLParserBREAK_SYMBOL, GoogleSQLParserCALL_SYMBOL, GoogleSQLParserCASCADE_SYMBOL, GoogleSQLParserCHECK_SYMBOL, GoogleSQLParserCLAMPED_SYMBOL, GoogleSQLParserCLONE_SYMBOL, GoogleSQLParserCOPY_SYMBOL, GoogleSQLParserCLUSTER_SYMBOL, GoogleSQLParserCOLUMN_SYMBOL, GoogleSQLParserCOLUMNS_SYMBOL, GoogleSQLParserCOMMIT_SYMBOL, GoogleSQLParserCONNECTION_SYMBOL, GoogleSQLParserCONSTANT_SYMBOL, GoogleSQLParserCONSTRAINT_SYMBOL, GoogleSQLParserCONTINUE_SYMBOL, GoogleSQLParserCORRESPONDING_SYMBOL, GoogleSQLParserCYCLE_SYMBOL, GoogleSQLParserDATA_SYMBOL, GoogleSQLParserDATABASE_SYMBOL, GoogleSQLParserDECLARE_SYMBOL, GoogleSQLParserDEFINER_SYMBOL, GoogleSQLParserDELETE_SYMBOL, GoogleSQLParserDELETION_SYMBOL, GoogleSQLParserDEPTH_SYMBOL, GoogleSQLParserDESCRIBE_SYMBOL, GoogleSQLParserDETERMINISTIC_SYMBOL, GoogleSQLParserDO_SYMBOL, GoogleSQLParserDROP_SYMBOL, GoogleSQLParserELSEIF_SYMBOL, GoogleSQLParserENFORCED_SYMBOL, GoogleSQLParserERROR_SYMBOL, GoogleSQLParserEXCEPTION_SYMBOL, GoogleSQLParserEXECUTE_SYMBOL, GoogleSQLParserEXPLAIN_SYMBOL, GoogleSQLParserEXPORT_SYMBOL, GoogleSQLParserEXTEND_SYMBOL, GoogleSQLParserEXTERNAL_SYMBOL, GoogleSQLParserFILES_SYMBOL, GoogleSQLParserFILTER_SYMBOL, GoogleSQLParserFILL_SYMBOL, GoogleSQLParserFIRST_SYMBOL, GoogleSQLParserFOREIGN_SYMBOL, GoogleSQLParserFORMAT_SYMBOL, GoogleSQLParserFUNCTION_SYMBOL, GoogleSQLParserGENERATED_SYMBOL, GoogleSQLParserGRANT_SYMBOL, GoogleSQLParserGROUP_ROWS_SYMBOL, GoogleSQLParserHIDDEN_SYMBOL, GoogleSQLParserIDENTITY_SYMBOL, GoogleSQLParserIMMEDIATE_SYMBOL, GoogleSQLParserIMMUTABLE_SYMBOL, GoogleSQLParserIMPORT_SYMBOL, GoogleSQLParserINCREMENT_SYMBOL, GoogleSQLParserINDEX_SYMBOL, GoogleSQLParserINOUT_SYMBOL, GoogleSQLParserINPUT_SYMBOL, GoogleSQLParserINSERT_SYMBOL, GoogleSQLParserINVOKER_SYMBOL, GoogleSQLParserISOLATION_SYMBOL, GoogleSQLParserITERATE_SYMBOL, GoogleSQLParserKEY_SYMBOL, GoogleSQLParserLANGUAGE_SYMBOL, GoogleSQLParserLAST_SYMBOL, GoogleSQLParserLEAVE_SYMBOL, GoogleSQLParserLEVEL_SYMBOL, GoogleSQLParserLOAD_SYMBOL, GoogleSQLParserLOOP_SYMBOL, GoogleSQLParserMACRO_SYMBOL, GoogleSQLParserMAP_SYMBOL, GoogleSQLParserMATCH_SYMBOL, GoogleSQLParserKW_MATCH_RECOGNIZE_NONRESERVED_SYMBOL, GoogleSQLParserMATCHED_SYMBOL, GoogleSQLParserMATERIALIZED_SYMBOL, GoogleSQLParserMAX_SYMBOL, GoogleSQLParserMAXVALUE_SYMBOL, GoogleSQLParserMEASURES_SYMBOL, GoogleSQLParserMESSAGE_SYMBOL, GoogleSQLParserMETADATA_SYMBOL, GoogleSQLParserMIN_SYMBOL, GoogleSQLParserMINVALUE_SYMBOL, GoogleSQLParserMODEL_SYMBOL, GoogleSQLParserMODULE_SYMBOL, GoogleSQLParserONLY_SYMBOL, GoogleSQLParserOUT_SYMBOL, GoogleSQLParserOUTPUT_SYMBOL, GoogleSQLParserOVERWRITE_SYMBOL, GoogleSQLParserPARTITIONS_SYMBOL, GoogleSQLParserPATTERN_SYMBOL, GoogleSQLParserPOLICIES_SYMBOL, GoogleSQLParserPOLICY_SYMBOL, GoogleSQLParserPRIMARY_SYMBOL, GoogleSQLParserPRIVATE_SYMBOL, GoogleSQLParserPRIVILEGE_SYMBOL, GoogleSQLParserPRIVILEGES_SYMBOL, GoogleSQLParserPROCEDURE_SYMBOL, GoogleSQLParserPROJECT_SYMBOL, GoogleSQLParserPUBLIC_SYMBOL, GoogleSQLParserRAISE_SYMBOL, GoogleSQLParserREAD_SYMBOL, GoogleSQLParserREFERENCES_SYMBOL, GoogleSQLParserREMOTE_SYMBOL, GoogleSQLParserREMOVE_SYMBOL, GoogleSQLParserRENAME_SYMBOL, GoogleSQLParserREPEAT_SYMBOL, GoogleSQLParserREPEATABLE_SYMBOL, GoogleSQLParserREPLACE_FIELDS_SYMBOL, GoogleSQLParserREPLICA_SYMBOL, GoogleSQLParserREPORT_SYMBOL, GoogleSQLParserRESTRICT_SYMBOL, GoogleSQLParserRESTRICTION_SYMBOL, GoogleSQLParserRETURNS_SYMBOL, GoogleSQLParserRETURN_SYMBOL, GoogleSQLParserREVOKE_SYMBOL, GoogleSQLParserROLLBACK_SYMBOL, GoogleSQLParserROW_SYMBOL, GoogleSQLParserRUN_SYMBOL, GoogleSQLParserSAFE_CAST_SYMBOL, GoogleSQLParserSCHEMA_SYMBOL, GoogleSQLParserSEARCH_SYMBOL, GoogleSQLParserSECURITY_SYMBOL, GoogleSQLParserSEQUENCE_SYMBOL, GoogleSQLParserSETS_SYMBOL, GoogleSQLParserSHOW_SYMBOL, GoogleSQLParserSNAPSHOT_SYMBOL, GoogleSQLParserSOURCE_SYMBOL, GoogleSQLParserSQL_SYMBOL, GoogleSQLParserSTABLE_SYMBOL, GoogleSQLParserSTART_SYMBOL, GoogleSQLParserSTATIC_DESCRIBE_SYMBOL, GoogleSQLParserSTORED_SYMBOL, GoogleSQLParserSTORING_SYMBOL, GoogleSQLParserSTRICT_SYMBOL, GoogleSQLParserTABLE_SYMBOL, GoogleSQLParserTABLES_SYMBOL, GoogleSQLParserTARGET_SYMBOL, GoogleSQLParserTEMP_SYMBOL, GoogleSQLParserTEMPORARY_SYMBOL, GoogleSQLParserTRANSACTION_SYMBOL, GoogleSQLParserTRANSFORM_SYMBOL, GoogleSQLParserTRUNCATE_SYMBOL, GoogleSQLParserTYPE_SYMBOL, GoogleSQLParserUNDROP_SYMBOL, GoogleSQLParserUNIQUE_SYMBOL, GoogleSQLParserUNKNOWN_SYMBOL, GoogleSQLParserUNTIL_SYMBOL, GoogleSQLParserUPDATE_SYMBOL, GoogleSQLParserVALUES_SYMBOL, GoogleSQLParserVECTOR_SYMBOL, GoogleSQLParserVIEW_SYMBOL, GoogleSQLParserVIEWS_SYMBOL, GoogleSQLParserVOLATILE_SYMBOL, GoogleSQLParserWEIGHT_SYMBOL, GoogleSQLParserWHILE_SYMBOL, GoogleSQLParserWRITE_SYMBOL, GoogleSQLParserZONE_SYMBOL, GoogleSQLParserDESCRIPTOR_SYMBOL, GoogleSQLParserINTERLEAVE_SYMBOL, GoogleSQLParserNULL_FILTERED_SYMBOL, GoogleSQLParserPARENT_SYMBOL, GoogleSQLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2967)
			p.path_expression(0)
		}


	case GoogleSQLParserINTERVAL_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2968)
			p.Match(GoogleSQLParserINTERVAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPath_expressionContext is an interface to support dynamic dispatch.
type IPath_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Path_expression() IPath_expressionContext
	DOT_SYMBOL() antlr.TerminalNode

	// IsPath_expressionContext differentiates from other interfaces.
	IsPath_expressionContext()
}

type Path_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPath_expressionContext() *Path_expressionContext {
	var p = new(Path_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_path_expression
	return p
}

func InitEmptyPath_expressionContext(p *Path_expressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_path_expression
}

func (*Path_expressionContext) IsPath_expressionContext() {}

func NewPath_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Path_expressionContext {
	var p = new(Path_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_path_expression

	return p
}

func (s *Path_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Path_expressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Path_expressionContext) Path_expression() IPath_expressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPath_expressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPath_expressionContext)
}

func (s *Path_expressionContext) DOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDOT_SYMBOL, 0)
}

func (s *Path_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Path_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Path_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterPath_expression(s)
	}
}

func (s *Path_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitPath_expression(s)
	}
}

func (s *Path_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitPath_expression(s)

	default:
		return t.VisitChildren(s)
	}
}





func (p *GoogleSQLParser) Path_expression() (localctx IPath_expressionContext) {
	return p.path_expression(0)
}

func (p *GoogleSQLParser) path_expression(_p int) (localctx IPath_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPath_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPath_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 546
	p.EnterRecursionRule(localctx, 546, GoogleSQLParserRULE_path_expression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2972)
		p.Identifier()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2979)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 311, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewPath_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_path_expression)
			p.SetState(2974)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(2975)
				p.Match(GoogleSQLParserDOT_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2976)
				p.Identifier()
			}


		}
		p.SetState(2981)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 311, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Token_identifier() IToken_identifierContext
	Keyword_as_identifier() IKeyword_as_identifierContext

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Token_identifier() IToken_identifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IToken_identifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IToken_identifierContext)
}

func (s *IdentifierContext) Keyword_as_identifier() IKeyword_as_identifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_as_identifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_as_identifierContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, GoogleSQLParserRULE_identifier)
	p.SetState(2984)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2982)
			p.Token_identifier()
		}


	case GoogleSQLParserINCLUDE_SYMBOL, GoogleSQLParserOFFSET_SYMBOL, GoogleSQLParserOPTIONS_SYMBOL, GoogleSQLParserPERCENT_SYMBOL, GoogleSQLParserPIVOT_SYMBOL, GoogleSQLParserREPLACE_SYMBOL, GoogleSQLParserUNPIVOT_SYMBOL, GoogleSQLParserSYSTEM_SYMBOL, GoogleSQLParserSYSTEM_TIME_SYMBOL, GoogleSQLParserVALUE_SYMBOL, GoogleSQLParserNUMERIC_SYMBOL, GoogleSQLParserDECIMAL_SYMBOL, GoogleSQLParserBIGNUMERIC_SYMBOL, GoogleSQLParserBIGDECIMAL_SYMBOL, GoogleSQLParserJSON_SYMBOL, GoogleSQLParserDATE_SYMBOL, GoogleSQLParserTIME_SYMBOL, GoogleSQLParserDATETIME_SYMBOL, GoogleSQLParserTIMESTAMP_SYMBOL, GoogleSQLParserSIMPLE_SYMBOL, GoogleSQLParserABORT_SYMBOL, GoogleSQLParserACCESS_SYMBOL, GoogleSQLParserACTION_SYMBOL, GoogleSQLParserAGGREGATE_SYMBOL, GoogleSQLParserADD_SYMBOL, GoogleSQLParserALTER_SYMBOL, GoogleSQLParserALWAYS_SYMBOL, GoogleSQLParserANALYZE_SYMBOL, GoogleSQLParserAPPROX_SYMBOL, GoogleSQLParserARE_SYMBOL, GoogleSQLParserASSERT_SYMBOL, GoogleSQLParserBATCH_SYMBOL, GoogleSQLParserBEGIN_SYMBOL, GoogleSQLParserBREAK_SYMBOL, GoogleSQLParserCALL_SYMBOL, GoogleSQLParserCASCADE_SYMBOL, GoogleSQLParserCHECK_SYMBOL, GoogleSQLParserCLAMPED_SYMBOL, GoogleSQLParserCLONE_SYMBOL, GoogleSQLParserCOPY_SYMBOL, GoogleSQLParserCLUSTER_SYMBOL, GoogleSQLParserCOLUMN_SYMBOL, GoogleSQLParserCOLUMNS_SYMBOL, GoogleSQLParserCOMMIT_SYMBOL, GoogleSQLParserCONNECTION_SYMBOL, GoogleSQLParserCONSTANT_SYMBOL, GoogleSQLParserCONSTRAINT_SYMBOL, GoogleSQLParserCONTINUE_SYMBOL, GoogleSQLParserCORRESPONDING_SYMBOL, GoogleSQLParserCYCLE_SYMBOL, GoogleSQLParserDATA_SYMBOL, GoogleSQLParserDATABASE_SYMBOL, GoogleSQLParserDECLARE_SYMBOL, GoogleSQLParserDEFINER_SYMBOL, GoogleSQLParserDELETE_SYMBOL, GoogleSQLParserDELETION_SYMBOL, GoogleSQLParserDEPTH_SYMBOL, GoogleSQLParserDESCRIBE_SYMBOL, GoogleSQLParserDETERMINISTIC_SYMBOL, GoogleSQLParserDO_SYMBOL, GoogleSQLParserDROP_SYMBOL, GoogleSQLParserELSEIF_SYMBOL, GoogleSQLParserENFORCED_SYMBOL, GoogleSQLParserERROR_SYMBOL, GoogleSQLParserEXCEPTION_SYMBOL, GoogleSQLParserEXECUTE_SYMBOL, GoogleSQLParserEXPLAIN_SYMBOL, GoogleSQLParserEXPORT_SYMBOL, GoogleSQLParserEXTEND_SYMBOL, GoogleSQLParserEXTERNAL_SYMBOL, GoogleSQLParserFILES_SYMBOL, GoogleSQLParserFILTER_SYMBOL, GoogleSQLParserFILL_SYMBOL, GoogleSQLParserFIRST_SYMBOL, GoogleSQLParserFOREIGN_SYMBOL, GoogleSQLParserFORMAT_SYMBOL, GoogleSQLParserFUNCTION_SYMBOL, GoogleSQLParserGENERATED_SYMBOL, GoogleSQLParserGRANT_SYMBOL, GoogleSQLParserGROUP_ROWS_SYMBOL, GoogleSQLParserHIDDEN_SYMBOL, GoogleSQLParserIDENTITY_SYMBOL, GoogleSQLParserIMMEDIATE_SYMBOL, GoogleSQLParserIMMUTABLE_SYMBOL, GoogleSQLParserIMPORT_SYMBOL, GoogleSQLParserINCREMENT_SYMBOL, GoogleSQLParserINDEX_SYMBOL, GoogleSQLParserINOUT_SYMBOL, GoogleSQLParserINPUT_SYMBOL, GoogleSQLParserINSERT_SYMBOL, GoogleSQLParserINVOKER_SYMBOL, GoogleSQLParserISOLATION_SYMBOL, GoogleSQLParserITERATE_SYMBOL, GoogleSQLParserKEY_SYMBOL, GoogleSQLParserLANGUAGE_SYMBOL, GoogleSQLParserLAST_SYMBOL, GoogleSQLParserLEAVE_SYMBOL, GoogleSQLParserLEVEL_SYMBOL, GoogleSQLParserLOAD_SYMBOL, GoogleSQLParserLOOP_SYMBOL, GoogleSQLParserMACRO_SYMBOL, GoogleSQLParserMAP_SYMBOL, GoogleSQLParserMATCH_SYMBOL, GoogleSQLParserKW_MATCH_RECOGNIZE_NONRESERVED_SYMBOL, GoogleSQLParserMATCHED_SYMBOL, GoogleSQLParserMATERIALIZED_SYMBOL, GoogleSQLParserMAX_SYMBOL, GoogleSQLParserMAXVALUE_SYMBOL, GoogleSQLParserMEASURES_SYMBOL, GoogleSQLParserMESSAGE_SYMBOL, GoogleSQLParserMETADATA_SYMBOL, GoogleSQLParserMIN_SYMBOL, GoogleSQLParserMINVALUE_SYMBOL, GoogleSQLParserMODEL_SYMBOL, GoogleSQLParserMODULE_SYMBOL, GoogleSQLParserONLY_SYMBOL, GoogleSQLParserOUT_SYMBOL, GoogleSQLParserOUTPUT_SYMBOL, GoogleSQLParserOVERWRITE_SYMBOL, GoogleSQLParserPARTITIONS_SYMBOL, GoogleSQLParserPATTERN_SYMBOL, GoogleSQLParserPOLICIES_SYMBOL, GoogleSQLParserPOLICY_SYMBOL, GoogleSQLParserPRIMARY_SYMBOL, GoogleSQLParserPRIVATE_SYMBOL, GoogleSQLParserPRIVILEGE_SYMBOL, GoogleSQLParserPRIVILEGES_SYMBOL, GoogleSQLParserPROCEDURE_SYMBOL, GoogleSQLParserPROJECT_SYMBOL, GoogleSQLParserPUBLIC_SYMBOL, GoogleSQLParserRAISE_SYMBOL, GoogleSQLParserREAD_SYMBOL, GoogleSQLParserREFERENCES_SYMBOL, GoogleSQLParserREMOTE_SYMBOL, GoogleSQLParserREMOVE_SYMBOL, GoogleSQLParserRENAME_SYMBOL, GoogleSQLParserREPEAT_SYMBOL, GoogleSQLParserREPEATABLE_SYMBOL, GoogleSQLParserREPLACE_FIELDS_SYMBOL, GoogleSQLParserREPLICA_SYMBOL, GoogleSQLParserREPORT_SYMBOL, GoogleSQLParserRESTRICT_SYMBOL, GoogleSQLParserRESTRICTION_SYMBOL, GoogleSQLParserRETURNS_SYMBOL, GoogleSQLParserRETURN_SYMBOL, GoogleSQLParserREVOKE_SYMBOL, GoogleSQLParserROLLBACK_SYMBOL, GoogleSQLParserROW_SYMBOL, GoogleSQLParserRUN_SYMBOL, GoogleSQLParserSAFE_CAST_SYMBOL, GoogleSQLParserSCHEMA_SYMBOL, GoogleSQLParserSEARCH_SYMBOL, GoogleSQLParserSECURITY_SYMBOL, GoogleSQLParserSEQUENCE_SYMBOL, GoogleSQLParserSETS_SYMBOL, GoogleSQLParserSHOW_SYMBOL, GoogleSQLParserSNAPSHOT_SYMBOL, GoogleSQLParserSOURCE_SYMBOL, GoogleSQLParserSQL_SYMBOL, GoogleSQLParserSTABLE_SYMBOL, GoogleSQLParserSTART_SYMBOL, GoogleSQLParserSTATIC_DESCRIBE_SYMBOL, GoogleSQLParserSTORED_SYMBOL, GoogleSQLParserSTORING_SYMBOL, GoogleSQLParserSTRICT_SYMBOL, GoogleSQLParserTABLE_SYMBOL, GoogleSQLParserTABLES_SYMBOL, GoogleSQLParserTARGET_SYMBOL, GoogleSQLParserTEMP_SYMBOL, GoogleSQLParserTEMPORARY_SYMBOL, GoogleSQLParserTRANSACTION_SYMBOL, GoogleSQLParserTRANSFORM_SYMBOL, GoogleSQLParserTRUNCATE_SYMBOL, GoogleSQLParserTYPE_SYMBOL, GoogleSQLParserUNDROP_SYMBOL, GoogleSQLParserUNIQUE_SYMBOL, GoogleSQLParserUNKNOWN_SYMBOL, GoogleSQLParserUNTIL_SYMBOL, GoogleSQLParserUPDATE_SYMBOL, GoogleSQLParserVALUES_SYMBOL, GoogleSQLParserVECTOR_SYMBOL, GoogleSQLParserVIEW_SYMBOL, GoogleSQLParserVIEWS_SYMBOL, GoogleSQLParserVOLATILE_SYMBOL, GoogleSQLParserWEIGHT_SYMBOL, GoogleSQLParserWHILE_SYMBOL, GoogleSQLParserWRITE_SYMBOL, GoogleSQLParserZONE_SYMBOL, GoogleSQLParserDESCRIPTOR_SYMBOL, GoogleSQLParserINTERLEAVE_SYMBOL, GoogleSQLParserNULL_FILTERED_SYMBOL, GoogleSQLParserPARENT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2983)
			p.Keyword_as_identifier()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKeyword_as_identifierContext is an interface to support dynamic dispatch.
type IKeyword_as_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Common_keyword_as_identifier() ICommon_keyword_as_identifierContext
	SIMPLE_SYMBOL() antlr.TerminalNode

	// IsKeyword_as_identifierContext differentiates from other interfaces.
	IsKeyword_as_identifierContext()
}

type Keyword_as_identifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_as_identifierContext() *Keyword_as_identifierContext {
	var p = new(Keyword_as_identifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_keyword_as_identifier
	return p
}

func InitEmptyKeyword_as_identifierContext(p *Keyword_as_identifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_keyword_as_identifier
}

func (*Keyword_as_identifierContext) IsKeyword_as_identifierContext() {}

func NewKeyword_as_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_as_identifierContext {
	var p = new(Keyword_as_identifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_keyword_as_identifier

	return p
}

func (s *Keyword_as_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_as_identifierContext) Common_keyword_as_identifier() ICommon_keyword_as_identifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommon_keyword_as_identifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommon_keyword_as_identifierContext)
}

func (s *Keyword_as_identifierContext) SIMPLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSIMPLE_SYMBOL, 0)
}

func (s *Keyword_as_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_as_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Keyword_as_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterKeyword_as_identifier(s)
	}
}

func (s *Keyword_as_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitKeyword_as_identifier(s)
	}
}

func (s *Keyword_as_identifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitKeyword_as_identifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Keyword_as_identifier() (localctx IKeyword_as_identifierContext) {
	localctx = NewKeyword_as_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, GoogleSQLParserRULE_keyword_as_identifier)
	p.SetState(2988)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserINCLUDE_SYMBOL, GoogleSQLParserOFFSET_SYMBOL, GoogleSQLParserOPTIONS_SYMBOL, GoogleSQLParserPERCENT_SYMBOL, GoogleSQLParserPIVOT_SYMBOL, GoogleSQLParserREPLACE_SYMBOL, GoogleSQLParserUNPIVOT_SYMBOL, GoogleSQLParserSYSTEM_SYMBOL, GoogleSQLParserSYSTEM_TIME_SYMBOL, GoogleSQLParserVALUE_SYMBOL, GoogleSQLParserNUMERIC_SYMBOL, GoogleSQLParserDECIMAL_SYMBOL, GoogleSQLParserBIGNUMERIC_SYMBOL, GoogleSQLParserBIGDECIMAL_SYMBOL, GoogleSQLParserJSON_SYMBOL, GoogleSQLParserDATE_SYMBOL, GoogleSQLParserTIME_SYMBOL, GoogleSQLParserDATETIME_SYMBOL, GoogleSQLParserTIMESTAMP_SYMBOL, GoogleSQLParserABORT_SYMBOL, GoogleSQLParserACCESS_SYMBOL, GoogleSQLParserACTION_SYMBOL, GoogleSQLParserAGGREGATE_SYMBOL, GoogleSQLParserADD_SYMBOL, GoogleSQLParserALTER_SYMBOL, GoogleSQLParserALWAYS_SYMBOL, GoogleSQLParserANALYZE_SYMBOL, GoogleSQLParserAPPROX_SYMBOL, GoogleSQLParserARE_SYMBOL, GoogleSQLParserASSERT_SYMBOL, GoogleSQLParserBATCH_SYMBOL, GoogleSQLParserBEGIN_SYMBOL, GoogleSQLParserBREAK_SYMBOL, GoogleSQLParserCALL_SYMBOL, GoogleSQLParserCASCADE_SYMBOL, GoogleSQLParserCHECK_SYMBOL, GoogleSQLParserCLAMPED_SYMBOL, GoogleSQLParserCLONE_SYMBOL, GoogleSQLParserCOPY_SYMBOL, GoogleSQLParserCLUSTER_SYMBOL, GoogleSQLParserCOLUMN_SYMBOL, GoogleSQLParserCOLUMNS_SYMBOL, GoogleSQLParserCOMMIT_SYMBOL, GoogleSQLParserCONNECTION_SYMBOL, GoogleSQLParserCONSTANT_SYMBOL, GoogleSQLParserCONSTRAINT_SYMBOL, GoogleSQLParserCONTINUE_SYMBOL, GoogleSQLParserCORRESPONDING_SYMBOL, GoogleSQLParserCYCLE_SYMBOL, GoogleSQLParserDATA_SYMBOL, GoogleSQLParserDATABASE_SYMBOL, GoogleSQLParserDECLARE_SYMBOL, GoogleSQLParserDEFINER_SYMBOL, GoogleSQLParserDELETE_SYMBOL, GoogleSQLParserDELETION_SYMBOL, GoogleSQLParserDEPTH_SYMBOL, GoogleSQLParserDESCRIBE_SYMBOL, GoogleSQLParserDETERMINISTIC_SYMBOL, GoogleSQLParserDO_SYMBOL, GoogleSQLParserDROP_SYMBOL, GoogleSQLParserELSEIF_SYMBOL, GoogleSQLParserENFORCED_SYMBOL, GoogleSQLParserERROR_SYMBOL, GoogleSQLParserEXCEPTION_SYMBOL, GoogleSQLParserEXECUTE_SYMBOL, GoogleSQLParserEXPLAIN_SYMBOL, GoogleSQLParserEXPORT_SYMBOL, GoogleSQLParserEXTEND_SYMBOL, GoogleSQLParserEXTERNAL_SYMBOL, GoogleSQLParserFILES_SYMBOL, GoogleSQLParserFILTER_SYMBOL, GoogleSQLParserFILL_SYMBOL, GoogleSQLParserFIRST_SYMBOL, GoogleSQLParserFOREIGN_SYMBOL, GoogleSQLParserFORMAT_SYMBOL, GoogleSQLParserFUNCTION_SYMBOL, GoogleSQLParserGENERATED_SYMBOL, GoogleSQLParserGRANT_SYMBOL, GoogleSQLParserGROUP_ROWS_SYMBOL, GoogleSQLParserHIDDEN_SYMBOL, GoogleSQLParserIDENTITY_SYMBOL, GoogleSQLParserIMMEDIATE_SYMBOL, GoogleSQLParserIMMUTABLE_SYMBOL, GoogleSQLParserIMPORT_SYMBOL, GoogleSQLParserINCREMENT_SYMBOL, GoogleSQLParserINDEX_SYMBOL, GoogleSQLParserINOUT_SYMBOL, GoogleSQLParserINPUT_SYMBOL, GoogleSQLParserINSERT_SYMBOL, GoogleSQLParserINVOKER_SYMBOL, GoogleSQLParserISOLATION_SYMBOL, GoogleSQLParserITERATE_SYMBOL, GoogleSQLParserKEY_SYMBOL, GoogleSQLParserLANGUAGE_SYMBOL, GoogleSQLParserLAST_SYMBOL, GoogleSQLParserLEAVE_SYMBOL, GoogleSQLParserLEVEL_SYMBOL, GoogleSQLParserLOAD_SYMBOL, GoogleSQLParserLOOP_SYMBOL, GoogleSQLParserMACRO_SYMBOL, GoogleSQLParserMAP_SYMBOL, GoogleSQLParserMATCH_SYMBOL, GoogleSQLParserKW_MATCH_RECOGNIZE_NONRESERVED_SYMBOL, GoogleSQLParserMATCHED_SYMBOL, GoogleSQLParserMATERIALIZED_SYMBOL, GoogleSQLParserMAX_SYMBOL, GoogleSQLParserMAXVALUE_SYMBOL, GoogleSQLParserMEASURES_SYMBOL, GoogleSQLParserMESSAGE_SYMBOL, GoogleSQLParserMETADATA_SYMBOL, GoogleSQLParserMIN_SYMBOL, GoogleSQLParserMINVALUE_SYMBOL, GoogleSQLParserMODEL_SYMBOL, GoogleSQLParserMODULE_SYMBOL, GoogleSQLParserONLY_SYMBOL, GoogleSQLParserOUT_SYMBOL, GoogleSQLParserOUTPUT_SYMBOL, GoogleSQLParserOVERWRITE_SYMBOL, GoogleSQLParserPARTITIONS_SYMBOL, GoogleSQLParserPATTERN_SYMBOL, GoogleSQLParserPOLICIES_SYMBOL, GoogleSQLParserPOLICY_SYMBOL, GoogleSQLParserPRIMARY_SYMBOL, GoogleSQLParserPRIVATE_SYMBOL, GoogleSQLParserPRIVILEGE_SYMBOL, GoogleSQLParserPRIVILEGES_SYMBOL, GoogleSQLParserPROCEDURE_SYMBOL, GoogleSQLParserPROJECT_SYMBOL, GoogleSQLParserPUBLIC_SYMBOL, GoogleSQLParserRAISE_SYMBOL, GoogleSQLParserREAD_SYMBOL, GoogleSQLParserREFERENCES_SYMBOL, GoogleSQLParserREMOTE_SYMBOL, GoogleSQLParserREMOVE_SYMBOL, GoogleSQLParserRENAME_SYMBOL, GoogleSQLParserREPEAT_SYMBOL, GoogleSQLParserREPEATABLE_SYMBOL, GoogleSQLParserREPLACE_FIELDS_SYMBOL, GoogleSQLParserREPLICA_SYMBOL, GoogleSQLParserREPORT_SYMBOL, GoogleSQLParserRESTRICT_SYMBOL, GoogleSQLParserRESTRICTION_SYMBOL, GoogleSQLParserRETURNS_SYMBOL, GoogleSQLParserRETURN_SYMBOL, GoogleSQLParserREVOKE_SYMBOL, GoogleSQLParserROLLBACK_SYMBOL, GoogleSQLParserROW_SYMBOL, GoogleSQLParserRUN_SYMBOL, GoogleSQLParserSAFE_CAST_SYMBOL, GoogleSQLParserSCHEMA_SYMBOL, GoogleSQLParserSEARCH_SYMBOL, GoogleSQLParserSECURITY_SYMBOL, GoogleSQLParserSEQUENCE_SYMBOL, GoogleSQLParserSETS_SYMBOL, GoogleSQLParserSHOW_SYMBOL, GoogleSQLParserSNAPSHOT_SYMBOL, GoogleSQLParserSOURCE_SYMBOL, GoogleSQLParserSQL_SYMBOL, GoogleSQLParserSTABLE_SYMBOL, GoogleSQLParserSTART_SYMBOL, GoogleSQLParserSTATIC_DESCRIBE_SYMBOL, GoogleSQLParserSTORED_SYMBOL, GoogleSQLParserSTORING_SYMBOL, GoogleSQLParserSTRICT_SYMBOL, GoogleSQLParserTABLE_SYMBOL, GoogleSQLParserTABLES_SYMBOL, GoogleSQLParserTARGET_SYMBOL, GoogleSQLParserTEMP_SYMBOL, GoogleSQLParserTEMPORARY_SYMBOL, GoogleSQLParserTRANSACTION_SYMBOL, GoogleSQLParserTRANSFORM_SYMBOL, GoogleSQLParserTRUNCATE_SYMBOL, GoogleSQLParserTYPE_SYMBOL, GoogleSQLParserUNDROP_SYMBOL, GoogleSQLParserUNIQUE_SYMBOL, GoogleSQLParserUNKNOWN_SYMBOL, GoogleSQLParserUNTIL_SYMBOL, GoogleSQLParserUPDATE_SYMBOL, GoogleSQLParserVALUES_SYMBOL, GoogleSQLParserVECTOR_SYMBOL, GoogleSQLParserVIEW_SYMBOL, GoogleSQLParserVIEWS_SYMBOL, GoogleSQLParserVOLATILE_SYMBOL, GoogleSQLParserWEIGHT_SYMBOL, GoogleSQLParserWHILE_SYMBOL, GoogleSQLParserWRITE_SYMBOL, GoogleSQLParserZONE_SYMBOL, GoogleSQLParserDESCRIPTOR_SYMBOL, GoogleSQLParserINTERLEAVE_SYMBOL, GoogleSQLParserNULL_FILTERED_SYMBOL, GoogleSQLParserPARENT_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2986)
			p.Common_keyword_as_identifier()
		}


	case GoogleSQLParserSIMPLE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2987)
			p.Match(GoogleSQLParserSIMPLE_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICommon_keyword_as_identifierContext is an interface to support dynamic dispatch.
type ICommon_keyword_as_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABORT_SYMBOL() antlr.TerminalNode
	ACCESS_SYMBOL() antlr.TerminalNode
	ACTION_SYMBOL() antlr.TerminalNode
	AGGREGATE_SYMBOL() antlr.TerminalNode
	ADD_SYMBOL() antlr.TerminalNode
	ALTER_SYMBOL() antlr.TerminalNode
	ALWAYS_SYMBOL() antlr.TerminalNode
	ANALYZE_SYMBOL() antlr.TerminalNode
	APPROX_SYMBOL() antlr.TerminalNode
	ARE_SYMBOL() antlr.TerminalNode
	ASSERT_SYMBOL() antlr.TerminalNode
	BATCH_SYMBOL() antlr.TerminalNode
	BEGIN_SYMBOL() antlr.TerminalNode
	BIGDECIMAL_SYMBOL() antlr.TerminalNode
	BIGNUMERIC_SYMBOL() antlr.TerminalNode
	BREAK_SYMBOL() antlr.TerminalNode
	CALL_SYMBOL() antlr.TerminalNode
	CASCADE_SYMBOL() antlr.TerminalNode
	CHECK_SYMBOL() antlr.TerminalNode
	CLAMPED_SYMBOL() antlr.TerminalNode
	CLONE_SYMBOL() antlr.TerminalNode
	COPY_SYMBOL() antlr.TerminalNode
	CLUSTER_SYMBOL() antlr.TerminalNode
	COLUMN_SYMBOL() antlr.TerminalNode
	COLUMNS_SYMBOL() antlr.TerminalNode
	COMMIT_SYMBOL() antlr.TerminalNode
	CONNECTION_SYMBOL() antlr.TerminalNode
	CONSTANT_SYMBOL() antlr.TerminalNode
	CONSTRAINT_SYMBOL() antlr.TerminalNode
	CONTINUE_SYMBOL() antlr.TerminalNode
	CORRESPONDING_SYMBOL() antlr.TerminalNode
	CYCLE_SYMBOL() antlr.TerminalNode
	DATA_SYMBOL() antlr.TerminalNode
	DATABASE_SYMBOL() antlr.TerminalNode
	DATE_SYMBOL() antlr.TerminalNode
	DATETIME_SYMBOL() antlr.TerminalNode
	DECIMAL_SYMBOL() antlr.TerminalNode
	DECLARE_SYMBOL() antlr.TerminalNode
	DEFINER_SYMBOL() antlr.TerminalNode
	DELETE_SYMBOL() antlr.TerminalNode
	DELETION_SYMBOL() antlr.TerminalNode
	DEPTH_SYMBOL() antlr.TerminalNode
	DESCRIBE_SYMBOL() antlr.TerminalNode
	DETERMINISTIC_SYMBOL() antlr.TerminalNode
	DO_SYMBOL() antlr.TerminalNode
	DROP_SYMBOL() antlr.TerminalNode
	ELSEIF_SYMBOL() antlr.TerminalNode
	ENFORCED_SYMBOL() antlr.TerminalNode
	ERROR_SYMBOL() antlr.TerminalNode
	EXCEPTION_SYMBOL() antlr.TerminalNode
	EXECUTE_SYMBOL() antlr.TerminalNode
	EXPLAIN_SYMBOL() antlr.TerminalNode
	EXPORT_SYMBOL() antlr.TerminalNode
	EXTEND_SYMBOL() antlr.TerminalNode
	EXTERNAL_SYMBOL() antlr.TerminalNode
	FILES_SYMBOL() antlr.TerminalNode
	FILTER_SYMBOL() antlr.TerminalNode
	FILL_SYMBOL() antlr.TerminalNode
	FIRST_SYMBOL() antlr.TerminalNode
	FOREIGN_SYMBOL() antlr.TerminalNode
	FORMAT_SYMBOL() antlr.TerminalNode
	FUNCTION_SYMBOL() antlr.TerminalNode
	GENERATED_SYMBOL() antlr.TerminalNode
	GRANT_SYMBOL() antlr.TerminalNode
	GROUP_ROWS_SYMBOL() antlr.TerminalNode
	HIDDEN_SYMBOL() antlr.TerminalNode
	IDENTITY_SYMBOL() antlr.TerminalNode
	IMMEDIATE_SYMBOL() antlr.TerminalNode
	IMMUTABLE_SYMBOL() antlr.TerminalNode
	IMPORT_SYMBOL() antlr.TerminalNode
	INCLUDE_SYMBOL() antlr.TerminalNode
	INCREMENT_SYMBOL() antlr.TerminalNode
	INDEX_SYMBOL() antlr.TerminalNode
	INOUT_SYMBOL() antlr.TerminalNode
	INPUT_SYMBOL() antlr.TerminalNode
	INSERT_SYMBOL() antlr.TerminalNode
	INVOKER_SYMBOL() antlr.TerminalNode
	ISOLATION_SYMBOL() antlr.TerminalNode
	ITERATE_SYMBOL() antlr.TerminalNode
	JSON_SYMBOL() antlr.TerminalNode
	KEY_SYMBOL() antlr.TerminalNode
	LANGUAGE_SYMBOL() antlr.TerminalNode
	LAST_SYMBOL() antlr.TerminalNode
	LEAVE_SYMBOL() antlr.TerminalNode
	LEVEL_SYMBOL() antlr.TerminalNode
	LOAD_SYMBOL() antlr.TerminalNode
	LOOP_SYMBOL() antlr.TerminalNode
	MACRO_SYMBOL() antlr.TerminalNode
	MAP_SYMBOL() antlr.TerminalNode
	MATCH_SYMBOL() antlr.TerminalNode
	KW_MATCH_RECOGNIZE_NONRESERVED_SYMBOL() antlr.TerminalNode
	MATCHED_SYMBOL() antlr.TerminalNode
	MATERIALIZED_SYMBOL() antlr.TerminalNode
	MAX_SYMBOL() antlr.TerminalNode
	MAXVALUE_SYMBOL() antlr.TerminalNode
	MEASURES_SYMBOL() antlr.TerminalNode
	MESSAGE_SYMBOL() antlr.TerminalNode
	METADATA_SYMBOL() antlr.TerminalNode
	MIN_SYMBOL() antlr.TerminalNode
	MINVALUE_SYMBOL() antlr.TerminalNode
	MODEL_SYMBOL() antlr.TerminalNode
	MODULE_SYMBOL() antlr.TerminalNode
	NUMERIC_SYMBOL() antlr.TerminalNode
	OFFSET_SYMBOL() antlr.TerminalNode
	ONLY_SYMBOL() antlr.TerminalNode
	OPTIONS_SYMBOL() antlr.TerminalNode
	OUT_SYMBOL() antlr.TerminalNode
	OUTPUT_SYMBOL() antlr.TerminalNode
	OVERWRITE_SYMBOL() antlr.TerminalNode
	PARTITIONS_SYMBOL() antlr.TerminalNode
	PATTERN_SYMBOL() antlr.TerminalNode
	PERCENT_SYMBOL() antlr.TerminalNode
	PIVOT_SYMBOL() antlr.TerminalNode
	POLICIES_SYMBOL() antlr.TerminalNode
	POLICY_SYMBOL() antlr.TerminalNode
	PRIMARY_SYMBOL() antlr.TerminalNode
	PRIVATE_SYMBOL() antlr.TerminalNode
	PRIVILEGE_SYMBOL() antlr.TerminalNode
	PRIVILEGES_SYMBOL() antlr.TerminalNode
	PROCEDURE_SYMBOL() antlr.TerminalNode
	PROJECT_SYMBOL() antlr.TerminalNode
	PUBLIC_SYMBOL() antlr.TerminalNode
	RAISE_SYMBOL() antlr.TerminalNode
	READ_SYMBOL() antlr.TerminalNode
	REFERENCES_SYMBOL() antlr.TerminalNode
	REMOTE_SYMBOL() antlr.TerminalNode
	REMOVE_SYMBOL() antlr.TerminalNode
	RENAME_SYMBOL() antlr.TerminalNode
	REPEAT_SYMBOL() antlr.TerminalNode
	REPEATABLE_SYMBOL() antlr.TerminalNode
	REPLACE_SYMBOL() antlr.TerminalNode
	REPLACE_FIELDS_SYMBOL() antlr.TerminalNode
	REPLICA_SYMBOL() antlr.TerminalNode
	REPORT_SYMBOL() antlr.TerminalNode
	RESTRICT_SYMBOL() antlr.TerminalNode
	RESTRICTION_SYMBOL() antlr.TerminalNode
	RETURNS_SYMBOL() antlr.TerminalNode
	RETURN_SYMBOL() antlr.TerminalNode
	REVOKE_SYMBOL() antlr.TerminalNode
	ROLLBACK_SYMBOL() antlr.TerminalNode
	ROW_SYMBOL() antlr.TerminalNode
	RUN_SYMBOL() antlr.TerminalNode
	SAFE_CAST_SYMBOL() antlr.TerminalNode
	SCHEMA_SYMBOL() antlr.TerminalNode
	SEARCH_SYMBOL() antlr.TerminalNode
	SECURITY_SYMBOL() antlr.TerminalNode
	SEQUENCE_SYMBOL() antlr.TerminalNode
	SETS_SYMBOL() antlr.TerminalNode
	SHOW_SYMBOL() antlr.TerminalNode
	SNAPSHOT_SYMBOL() antlr.TerminalNode
	SOURCE_SYMBOL() antlr.TerminalNode
	SQL_SYMBOL() antlr.TerminalNode
	STABLE_SYMBOL() antlr.TerminalNode
	START_SYMBOL() antlr.TerminalNode
	STATIC_DESCRIBE_SYMBOL() antlr.TerminalNode
	STORED_SYMBOL() antlr.TerminalNode
	STORING_SYMBOL() antlr.TerminalNode
	STRICT_SYMBOL() antlr.TerminalNode
	SYSTEM_SYMBOL() antlr.TerminalNode
	SYSTEM_TIME_SYMBOL() antlr.TerminalNode
	TABLE_SYMBOL() antlr.TerminalNode
	TABLES_SYMBOL() antlr.TerminalNode
	TARGET_SYMBOL() antlr.TerminalNode
	TEMP_SYMBOL() antlr.TerminalNode
	TEMPORARY_SYMBOL() antlr.TerminalNode
	TIME_SYMBOL() antlr.TerminalNode
	TIMESTAMP_SYMBOL() antlr.TerminalNode
	TRANSACTION_SYMBOL() antlr.TerminalNode
	TRANSFORM_SYMBOL() antlr.TerminalNode
	TRUNCATE_SYMBOL() antlr.TerminalNode
	TYPE_SYMBOL() antlr.TerminalNode
	UNDROP_SYMBOL() antlr.TerminalNode
	UNIQUE_SYMBOL() antlr.TerminalNode
	UNKNOWN_SYMBOL() antlr.TerminalNode
	UNPIVOT_SYMBOL() antlr.TerminalNode
	UNTIL_SYMBOL() antlr.TerminalNode
	UPDATE_SYMBOL() antlr.TerminalNode
	VALUE_SYMBOL() antlr.TerminalNode
	VALUES_SYMBOL() antlr.TerminalNode
	VECTOR_SYMBOL() antlr.TerminalNode
	VIEW_SYMBOL() antlr.TerminalNode
	VIEWS_SYMBOL() antlr.TerminalNode
	VOLATILE_SYMBOL() antlr.TerminalNode
	WEIGHT_SYMBOL() antlr.TerminalNode
	WHILE_SYMBOL() antlr.TerminalNode
	WRITE_SYMBOL() antlr.TerminalNode
	ZONE_SYMBOL() antlr.TerminalNode
	DESCRIPTOR_SYMBOL() antlr.TerminalNode
	INTERLEAVE_SYMBOL() antlr.TerminalNode
	NULL_FILTERED_SYMBOL() antlr.TerminalNode
	PARENT_SYMBOL() antlr.TerminalNode

	// IsCommon_keyword_as_identifierContext differentiates from other interfaces.
	IsCommon_keyword_as_identifierContext()
}

type Common_keyword_as_identifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommon_keyword_as_identifierContext() *Common_keyword_as_identifierContext {
	var p = new(Common_keyword_as_identifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_common_keyword_as_identifier
	return p
}

func InitEmptyCommon_keyword_as_identifierContext(p *Common_keyword_as_identifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_common_keyword_as_identifier
}

func (*Common_keyword_as_identifierContext) IsCommon_keyword_as_identifierContext() {}

func NewCommon_keyword_as_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Common_keyword_as_identifierContext {
	var p = new(Common_keyword_as_identifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_common_keyword_as_identifier

	return p
}

func (s *Common_keyword_as_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Common_keyword_as_identifierContext) ABORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserABORT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) ACCESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserACCESS_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) ACTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserACTION_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) AGGREGATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAGGREGATE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) ADD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserADD_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) ALTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserALTER_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) ALWAYS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserALWAYS_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) ANALYZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserANALYZE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) APPROX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserAPPROX_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) ARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserARE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) ASSERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserASSERT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) BATCH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserBATCH_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) BEGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserBEGIN_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) BIGDECIMAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserBIGDECIMAL_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) BIGNUMERIC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserBIGNUMERIC_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) BREAK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserBREAK_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) CALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCALL_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) CASCADE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCASCADE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) CHECK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCHECK_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) CLAMPED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCLAMPED_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) CLONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCLONE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) COPY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOPY_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) CLUSTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCLUSTER_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) COLUMN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOLUMN_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) COLUMNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOLUMNS_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) COMMIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCOMMIT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) CONNECTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCONNECTION_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) CONSTANT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCONSTANT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) CONSTRAINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCONSTRAINT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) CONTINUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCONTINUE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) CORRESPONDING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCORRESPONDING_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) CYCLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserCYCLE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) DATA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDATA_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) DATABASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDATABASE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) DATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDATE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) DATETIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDATETIME_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) DECIMAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDECIMAL_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) DECLARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDECLARE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) DEFINER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDEFINER_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) DELETE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDELETE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) DELETION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDELETION_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) DEPTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDEPTH_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) DESCRIBE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDESCRIBE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) DETERMINISTIC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDETERMINISTIC_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) DO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDO_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) DROP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDROP_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) ELSEIF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserELSEIF_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) ENFORCED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserENFORCED_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) ERROR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserERROR_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) EXCEPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEXCEPTION_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) EXECUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEXECUTE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) EXPLAIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEXPLAIN_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) EXPORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEXPORT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) EXTEND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEXTEND_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) EXTERNAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserEXTERNAL_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) FILES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFILES_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) FILTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFILTER_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) FILL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFILL_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) FIRST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFIRST_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) FOREIGN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFOREIGN_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFORMAT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) FUNCTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFUNCTION_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) GENERATED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserGENERATED_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) GRANT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserGRANT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) GROUP_ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserGROUP_ROWS_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) HIDDEN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserHIDDEN_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) IDENTITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserIDENTITY_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) IMMEDIATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserIMMEDIATE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) IMMUTABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserIMMUTABLE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) IMPORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserIMPORT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) INCLUDE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINCLUDE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) INCREMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINCREMENT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) INDEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINDEX_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) INOUT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINOUT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) INPUT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINPUT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) INSERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINSERT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) INVOKER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINVOKER_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) ISOLATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserISOLATION_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) ITERATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserITERATE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) JSON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserJSON_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserKEY_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) LANGUAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLANGUAGE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) LAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLAST_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) LEAVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLEAVE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) LEVEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLEVEL_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) LOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLOAD_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) LOOP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLOOP_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) MACRO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMACRO_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) MAP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMAP_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) MATCH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMATCH_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) KW_MATCH_RECOGNIZE_NONRESERVED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserKW_MATCH_RECOGNIZE_NONRESERVED_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) MATCHED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMATCHED_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) MATERIALIZED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMATERIALIZED_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) MAX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMAX_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) MAXVALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMAXVALUE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) MEASURES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMEASURES_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) MESSAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMESSAGE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) METADATA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMETADATA_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) MIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMIN_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) MINVALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMINVALUE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) MODEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMODEL_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) MODULE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserMODULE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) NUMERIC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserNUMERIC_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) OFFSET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserOFFSET_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) ONLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserONLY_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) OPTIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserOPTIONS_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) OUT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserOUT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) OUTPUT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserOUTPUT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) OVERWRITE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserOVERWRITE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) PARTITIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPARTITIONS_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) PATTERN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPATTERN_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) PERCENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPERCENT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) PIVOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPIVOT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) POLICIES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPOLICIES_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) POLICY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPOLICY_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) PRIMARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPRIMARY_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) PRIVATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPRIVATE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) PRIVILEGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPRIVILEGE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) PRIVILEGES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPRIVILEGES_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) PROCEDURE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPROCEDURE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) PROJECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPROJECT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) PUBLIC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPUBLIC_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) RAISE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRAISE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) READ_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserREAD_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) REFERENCES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserREFERENCES_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) REMOTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserREMOTE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) REMOVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserREMOVE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) RENAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRENAME_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) REPEAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserREPEAT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) REPEATABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserREPEATABLE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) REPLACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserREPLACE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) REPLACE_FIELDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserREPLACE_FIELDS_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) REPLICA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserREPLICA_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) REPORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserREPORT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) RESTRICT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRESTRICT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) RESTRICTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRESTRICTION_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) RETURNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRETURNS_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) RETURN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRETURN_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) REVOKE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserREVOKE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) ROLLBACK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserROLLBACK_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) ROW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserROW_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) RUN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserRUN_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) SAFE_CAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSAFE_CAST_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) SCHEMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSCHEMA_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) SEARCH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSEARCH_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) SECURITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSECURITY_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) SEQUENCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSEQUENCE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) SETS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSETS_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) SHOW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSHOW_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) SNAPSHOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSNAPSHOT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) SOURCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSOURCE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) SQL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSQL_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) STABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSTABLE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) START_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSTART_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) STATIC_DESCRIBE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSTATIC_DESCRIBE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) STORED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSTORED_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) STORING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSTORING_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) STRICT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSTRICT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) SYSTEM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSYSTEM_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) SYSTEM_TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSYSTEM_TIME_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTABLE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) TABLES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTABLES_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) TARGET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTARGET_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) TEMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTEMP_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) TEMPORARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTEMPORARY_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTIME_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) TIMESTAMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTIMESTAMP_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) TRANSACTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTRANSACTION_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) TRANSFORM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTRANSFORM_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) TRUNCATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTRUNCATE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) TYPE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTYPE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) UNDROP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserUNDROP_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) UNIQUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserUNIQUE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) UNKNOWN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserUNKNOWN_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) UNPIVOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserUNPIVOT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) UNTIL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserUNTIL_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) UPDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserUPDATE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) VALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserVALUE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) VALUES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserVALUES_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) VECTOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserVECTOR_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) VIEW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserVIEW_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) VIEWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserVIEWS_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) VOLATILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserVOLATILE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) WEIGHT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWEIGHT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) WHILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWHILE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) WRITE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserWRITE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) ZONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserZONE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) DESCRIPTOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDESCRIPTOR_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) INTERLEAVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINTERLEAVE_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) NULL_FILTERED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserNULL_FILTERED_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) PARENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserPARENT_SYMBOL, 0)
}

func (s *Common_keyword_as_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Common_keyword_as_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Common_keyword_as_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterCommon_keyword_as_identifier(s)
	}
}

func (s *Common_keyword_as_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitCommon_keyword_as_identifier(s)
	}
}

func (s *Common_keyword_as_identifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitCommon_keyword_as_identifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Common_keyword_as_identifier() (localctx ICommon_keyword_as_identifierContext) {
	localctx = NewCommon_keyword_as_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, GoogleSQLParserRULE_common_keyword_as_identifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2990)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -508611237030395904) != 0) || ((int64((_la - 67)) & ^0x3f) == 0 && ((int64(1) << (_la - 67)) & -1) != 0) || ((int64((_la - 131)) & ^0x3f) == 0 && ((int64(1) << (_la - 131)) & -1) != 0) || ((int64((_la - 195)) & ^0x3f) == 0 && ((int64(1) << (_la - 195)) & 17592186044415) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IToken_identifierContext is an interface to support dynamic dispatch.
type IToken_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode

	// IsToken_identifierContext differentiates from other interfaces.
	IsToken_identifierContext()
}

type Token_identifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyToken_identifierContext() *Token_identifierContext {
	var p = new(Token_identifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_token_identifier
	return p
}

func InitEmptyToken_identifierContext(p *Token_identifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_token_identifier
}

func (*Token_identifierContext) IsToken_identifierContext() {}

func NewToken_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Token_identifierContext {
	var p = new(Token_identifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_token_identifier

	return p
}

func (s *Token_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Token_identifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserIDENTIFIER, 0)
}

func (s *Token_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Token_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Token_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterToken_identifier(s)
	}
}

func (s *Token_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitToken_identifier(s)
	}
}

func (s *Token_identifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitToken_identifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Token_identifier() (localctx IToken_identifierContext) {
	localctx = NewToken_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, GoogleSQLParserRULE_token_identifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2992)
		p.Match(GoogleSQLParserIDENTIFIER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStruct_typeContext is an interface to support dynamic dispatch.
type IStruct_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRUCT_SYMBOL() antlr.TerminalNode
	Template_type_open() ITemplate_type_openContext
	Template_type_close() ITemplate_type_closeContext

	// IsStruct_typeContext differentiates from other interfaces.
	IsStruct_typeContext()
}

type Struct_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_typeContext() *Struct_typeContext {
	var p = new(Struct_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_struct_type
	return p
}

func InitEmptyStruct_typeContext(p *Struct_typeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_struct_type
}

func (*Struct_typeContext) IsStruct_typeContext() {}

func NewStruct_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_typeContext {
	var p = new(Struct_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_struct_type

	return p
}

func (s *Struct_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_typeContext) STRUCT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSTRUCT_SYMBOL, 0)
}

func (s *Struct_typeContext) Template_type_open() ITemplate_type_openContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplate_type_openContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplate_type_openContext)
}

func (s *Struct_typeContext) Template_type_close() ITemplate_type_closeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplate_type_closeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplate_type_closeContext)
}

func (s *Struct_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Struct_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterStruct_type(s)
	}
}

func (s *Struct_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitStruct_type(s)
	}
}

func (s *Struct_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitStruct_type(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Struct_type() (localctx IStruct_typeContext) {
	localctx = NewStruct_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, GoogleSQLParserRULE_struct_type)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2994)
		p.Match(GoogleSQLParserSTRUCT_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2995)
		p.Template_type_open()
	}
	{
		p.SetState(2996)
		p.Template_type_close()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IArray_typeContext is an interface to support dynamic dispatch.
type IArray_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_SYMBOL() antlr.TerminalNode
	Template_type_open() ITemplate_type_openContext
	Type_() ITypeContext
	Template_type_close() ITemplate_type_closeContext

	// IsArray_typeContext differentiates from other interfaces.
	IsArray_typeContext()
}

type Array_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_typeContext() *Array_typeContext {
	var p = new(Array_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_array_type
	return p
}

func InitEmptyArray_typeContext(p *Array_typeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_array_type
}

func (*Array_typeContext) IsArray_typeContext() {}

func NewArray_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_typeContext {
	var p = new(Array_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_array_type

	return p
}

func (s *Array_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_typeContext) ARRAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserARRAY_SYMBOL, 0)
}

func (s *Array_typeContext) Template_type_open() ITemplate_type_openContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplate_type_openContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplate_type_openContext)
}

func (s *Array_typeContext) Type_() ITypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Array_typeContext) Template_type_close() ITemplate_type_closeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplate_type_closeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplate_type_closeContext)
}

func (s *Array_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Array_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterArray_type(s)
	}
}

func (s *Array_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitArray_type(s)
	}
}

func (s *Array_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitArray_type(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Array_type() (localctx IArray_typeContext) {
	localctx = NewArray_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, GoogleSQLParserRULE_array_type)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2998)
		p.Match(GoogleSQLParserARRAY_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2999)
		p.Template_type_open()
	}
	{
		p.SetState(3000)
		p.Type_()
	}
	{
		p.SetState(3001)
		p.Template_type_close()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITemplate_type_openContext is an interface to support dynamic dispatch.
type ITemplate_type_openContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT_BRACKET_SYMBOL() antlr.TerminalNode

	// IsTemplate_type_openContext differentiates from other interfaces.
	IsTemplate_type_openContext()
}

type Template_type_openContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplate_type_openContext() *Template_type_openContext {
	var p = new(Template_type_openContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_template_type_open
	return p
}

func InitEmptyTemplate_type_openContext(p *Template_type_openContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_template_type_open
}

func (*Template_type_openContext) IsTemplate_type_openContext() {}

func NewTemplate_type_openContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Template_type_openContext {
	var p = new(Template_type_openContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_template_type_open

	return p
}

func (s *Template_type_openContext) GetParser() antlr.Parser { return s.parser }

func (s *Template_type_openContext) LT_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserLT_BRACKET_SYMBOL, 0)
}

func (s *Template_type_openContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Template_type_openContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Template_type_openContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterTemplate_type_open(s)
	}
}

func (s *Template_type_openContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitTemplate_type_open(s)
	}
}

func (s *Template_type_openContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitTemplate_type_open(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Template_type_open() (localctx ITemplate_type_openContext) {
	localctx = NewTemplate_type_openContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, GoogleSQLParserRULE_template_type_open)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3003)
		p.Match(GoogleSQLParserLT_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITemplate_type_closeContext is an interface to support dynamic dispatch.
type ITemplate_type_closeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GT_BRACKET_SYMBOL() antlr.TerminalNode

	// IsTemplate_type_closeContext differentiates from other interfaces.
	IsTemplate_type_closeContext()
}

type Template_type_closeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplate_type_closeContext() *Template_type_closeContext {
	var p = new(Template_type_closeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_template_type_close
	return p
}

func InitEmptyTemplate_type_closeContext(p *Template_type_closeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_template_type_close
}

func (*Template_type_closeContext) IsTemplate_type_closeContext() {}

func NewTemplate_type_closeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Template_type_closeContext {
	var p = new(Template_type_closeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_template_type_close

	return p
}

func (s *Template_type_closeContext) GetParser() antlr.Parser { return s.parser }

func (s *Template_type_closeContext) GT_BRACKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserGT_BRACKET_SYMBOL, 0)
}

func (s *Template_type_closeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Template_type_closeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Template_type_closeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterTemplate_type_close(s)
	}
}

func (s *Template_type_closeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitTemplate_type_close(s)
	}
}

func (s *Template_type_closeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitTemplate_type_close(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Template_type_close() (localctx ITemplate_type_closeContext) {
	localctx = NewTemplate_type_closeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, GoogleSQLParserRULE_template_type_close)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3005)
		p.Match(GoogleSQLParserGT_BRACKET_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDate_or_time_literalContext is an interface to support dynamic dispatch.
type IDate_or_time_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Date_or_time_literal_kind() IDate_or_time_literal_kindContext
	String_literal() IString_literalContext

	// IsDate_or_time_literalContext differentiates from other interfaces.
	IsDate_or_time_literalContext()
}

type Date_or_time_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDate_or_time_literalContext() *Date_or_time_literalContext {
	var p = new(Date_or_time_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_date_or_time_literal
	return p
}

func InitEmptyDate_or_time_literalContext(p *Date_or_time_literalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_date_or_time_literal
}

func (*Date_or_time_literalContext) IsDate_or_time_literalContext() {}

func NewDate_or_time_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Date_or_time_literalContext {
	var p = new(Date_or_time_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_date_or_time_literal

	return p
}

func (s *Date_or_time_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Date_or_time_literalContext) Date_or_time_literal_kind() IDate_or_time_literal_kindContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDate_or_time_literal_kindContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDate_or_time_literal_kindContext)
}

func (s *Date_or_time_literalContext) String_literal() IString_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_literalContext)
}

func (s *Date_or_time_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Date_or_time_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Date_or_time_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterDate_or_time_literal(s)
	}
}

func (s *Date_or_time_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitDate_or_time_literal(s)
	}
}

func (s *Date_or_time_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitDate_or_time_literal(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Date_or_time_literal() (localctx IDate_or_time_literalContext) {
	localctx = NewDate_or_time_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, GoogleSQLParserRULE_date_or_time_literal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3007)
		p.Date_or_time_literal_kind()
	}
	{
		p.SetState(3008)
		p.string_literal(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDate_or_time_literal_kindContext is an interface to support dynamic dispatch.
type IDate_or_time_literal_kindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATE_SYMBOL() antlr.TerminalNode
	TIME_SYMBOL() antlr.TerminalNode
	DATETIME_SYMBOL() antlr.TerminalNode
	TIMESTAMP_SYMBOL() antlr.TerminalNode

	// IsDate_or_time_literal_kindContext differentiates from other interfaces.
	IsDate_or_time_literal_kindContext()
}

type Date_or_time_literal_kindContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDate_or_time_literal_kindContext() *Date_or_time_literal_kindContext {
	var p = new(Date_or_time_literal_kindContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_date_or_time_literal_kind
	return p
}

func InitEmptyDate_or_time_literal_kindContext(p *Date_or_time_literal_kindContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_date_or_time_literal_kind
}

func (*Date_or_time_literal_kindContext) IsDate_or_time_literal_kindContext() {}

func NewDate_or_time_literal_kindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Date_or_time_literal_kindContext {
	var p = new(Date_or_time_literal_kindContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_date_or_time_literal_kind

	return p
}

func (s *Date_or_time_literal_kindContext) GetParser() antlr.Parser { return s.parser }

func (s *Date_or_time_literal_kindContext) DATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDATE_SYMBOL, 0)
}

func (s *Date_or_time_literal_kindContext) TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTIME_SYMBOL, 0)
}

func (s *Date_or_time_literal_kindContext) DATETIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDATETIME_SYMBOL, 0)
}

func (s *Date_or_time_literal_kindContext) TIMESTAMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTIMESTAMP_SYMBOL, 0)
}

func (s *Date_or_time_literal_kindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Date_or_time_literal_kindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Date_or_time_literal_kindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterDate_or_time_literal_kind(s)
	}
}

func (s *Date_or_time_literal_kindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitDate_or_time_literal_kind(s)
	}
}

func (s *Date_or_time_literal_kindContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitDate_or_time_literal_kind(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Date_or_time_literal_kind() (localctx IDate_or_time_literal_kindContext) {
	localctx = NewDate_or_time_literal_kindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, GoogleSQLParserRULE_date_or_time_literal_kind)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3010)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921504606846976) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFloating_point_literalContext is an interface to support dynamic dispatch.
type IFloating_point_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOAT() antlr.TerminalNode

	// IsFloating_point_literalContext differentiates from other interfaces.
	IsFloating_point_literalContext()
}

type Floating_point_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloating_point_literalContext() *Floating_point_literalContext {
	var p = new(Floating_point_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_floating_point_literal
	return p
}

func InitEmptyFloating_point_literalContext(p *Floating_point_literalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_floating_point_literal
}

func (*Floating_point_literalContext) IsFloating_point_literalContext() {}

func NewFloating_point_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Floating_point_literalContext {
	var p = new(Floating_point_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_floating_point_literal

	return p
}

func (s *Floating_point_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Floating_point_literalContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFLOAT, 0)
}

func (s *Floating_point_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Floating_point_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Floating_point_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterFloating_point_literal(s)
	}
}

func (s *Floating_point_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitFloating_point_literal(s)
	}
}

func (s *Floating_point_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitFloating_point_literal(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Floating_point_literal() (localctx IFloating_point_literalContext) {
	localctx = NewFloating_point_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, GoogleSQLParserRULE_floating_point_literal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3012)
		p.Match(GoogleSQLParserFLOAT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJson_literalContext is an interface to support dynamic dispatch.
type IJson_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JSON_SYMBOL() antlr.TerminalNode
	String_literal() IString_literalContext

	// IsJson_literalContext differentiates from other interfaces.
	IsJson_literalContext()
}

type Json_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_literalContext() *Json_literalContext {
	var p = new(Json_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_json_literal
	return p
}

func InitEmptyJson_literalContext(p *Json_literalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_json_literal
}

func (*Json_literalContext) IsJson_literalContext() {}

func NewJson_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_literalContext {
	var p = new(Json_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_json_literal

	return p
}

func (s *Json_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_literalContext) JSON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserJSON_SYMBOL, 0)
}

func (s *Json_literalContext) String_literal() IString_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_literalContext)
}

func (s *Json_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Json_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterJson_literal(s)
	}
}

func (s *Json_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitJson_literal(s)
	}
}

func (s *Json_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitJson_literal(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Json_literal() (localctx IJson_literalContext) {
	localctx = NewJson_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, GoogleSQLParserRULE_json_literal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3014)
		p.Match(GoogleSQLParserJSON_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3015)
		p.string_literal(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBignumeric_literalContext is an interface to support dynamic dispatch.
type IBignumeric_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Bignumeric_literal_prefix() IBignumeric_literal_prefixContext
	String_literal() IString_literalContext

	// IsBignumeric_literalContext differentiates from other interfaces.
	IsBignumeric_literalContext()
}

type Bignumeric_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBignumeric_literalContext() *Bignumeric_literalContext {
	var p = new(Bignumeric_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_bignumeric_literal
	return p
}

func InitEmptyBignumeric_literalContext(p *Bignumeric_literalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_bignumeric_literal
}

func (*Bignumeric_literalContext) IsBignumeric_literalContext() {}

func NewBignumeric_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bignumeric_literalContext {
	var p = new(Bignumeric_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_bignumeric_literal

	return p
}

func (s *Bignumeric_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Bignumeric_literalContext) Bignumeric_literal_prefix() IBignumeric_literal_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBignumeric_literal_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBignumeric_literal_prefixContext)
}

func (s *Bignumeric_literalContext) String_literal() IString_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_literalContext)
}

func (s *Bignumeric_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bignumeric_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bignumeric_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterBignumeric_literal(s)
	}
}

func (s *Bignumeric_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitBignumeric_literal(s)
	}
}

func (s *Bignumeric_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitBignumeric_literal(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Bignumeric_literal() (localctx IBignumeric_literalContext) {
	localctx = NewBignumeric_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, GoogleSQLParserRULE_bignumeric_literal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3017)
		p.Bignumeric_literal_prefix()
	}
	{
		p.SetState(3018)
		p.string_literal(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBignumeric_literal_prefixContext is an interface to support dynamic dispatch.
type IBignumeric_literal_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BIGNUMERIC_SYMBOL() antlr.TerminalNode
	BIGDECIMAL_SYMBOL() antlr.TerminalNode

	// IsBignumeric_literal_prefixContext differentiates from other interfaces.
	IsBignumeric_literal_prefixContext()
}

type Bignumeric_literal_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBignumeric_literal_prefixContext() *Bignumeric_literal_prefixContext {
	var p = new(Bignumeric_literal_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_bignumeric_literal_prefix
	return p
}

func InitEmptyBignumeric_literal_prefixContext(p *Bignumeric_literal_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_bignumeric_literal_prefix
}

func (*Bignumeric_literal_prefixContext) IsBignumeric_literal_prefixContext() {}

func NewBignumeric_literal_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bignumeric_literal_prefixContext {
	var p = new(Bignumeric_literal_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_bignumeric_literal_prefix

	return p
}

func (s *Bignumeric_literal_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Bignumeric_literal_prefixContext) BIGNUMERIC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserBIGNUMERIC_SYMBOL, 0)
}

func (s *Bignumeric_literal_prefixContext) BIGDECIMAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserBIGDECIMAL_SYMBOL, 0)
}

func (s *Bignumeric_literal_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bignumeric_literal_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bignumeric_literal_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterBignumeric_literal_prefix(s)
	}
}

func (s *Bignumeric_literal_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitBignumeric_literal_prefix(s)
	}
}

func (s *Bignumeric_literal_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitBignumeric_literal_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Bignumeric_literal_prefix() (localctx IBignumeric_literal_prefixContext) {
	localctx = NewBignumeric_literal_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, GoogleSQLParserRULE_bignumeric_literal_prefix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3020)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GoogleSQLParserBIGNUMERIC_SYMBOL || _la == GoogleSQLParserBIGDECIMAL_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INumeric_literalContext is an interface to support dynamic dispatch.
type INumeric_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Numeric_literal_prefix() INumeric_literal_prefixContext
	String_literal() IString_literalContext

	// IsNumeric_literalContext differentiates from other interfaces.
	IsNumeric_literalContext()
}

type Numeric_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumeric_literalContext() *Numeric_literalContext {
	var p = new(Numeric_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_numeric_literal
	return p
}

func InitEmptyNumeric_literalContext(p *Numeric_literalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_numeric_literal
}

func (*Numeric_literalContext) IsNumeric_literalContext() {}

func NewNumeric_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Numeric_literalContext {
	var p = new(Numeric_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_numeric_literal

	return p
}

func (s *Numeric_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Numeric_literalContext) Numeric_literal_prefix() INumeric_literal_prefixContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumeric_literal_prefixContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumeric_literal_prefixContext)
}

func (s *Numeric_literalContext) String_literal() IString_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_literalContext)
}

func (s *Numeric_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Numeric_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Numeric_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterNumeric_literal(s)
	}
}

func (s *Numeric_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitNumeric_literal(s)
	}
}

func (s *Numeric_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitNumeric_literal(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Numeric_literal() (localctx INumeric_literalContext) {
	localctx = NewNumeric_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, GoogleSQLParserRULE_numeric_literal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3022)
		p.Numeric_literal_prefix()
	}
	{
		p.SetState(3023)
		p.string_literal(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INumeric_literal_prefixContext is an interface to support dynamic dispatch.
type INumeric_literal_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUMERIC_SYMBOL() antlr.TerminalNode
	DECIMAL_SYMBOL() antlr.TerminalNode

	// IsNumeric_literal_prefixContext differentiates from other interfaces.
	IsNumeric_literal_prefixContext()
}

type Numeric_literal_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumeric_literal_prefixContext() *Numeric_literal_prefixContext {
	var p = new(Numeric_literal_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_numeric_literal_prefix
	return p
}

func InitEmptyNumeric_literal_prefixContext(p *Numeric_literal_prefixContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_numeric_literal_prefix
}

func (*Numeric_literal_prefixContext) IsNumeric_literal_prefixContext() {}

func NewNumeric_literal_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Numeric_literal_prefixContext {
	var p = new(Numeric_literal_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_numeric_literal_prefix

	return p
}

func (s *Numeric_literal_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Numeric_literal_prefixContext) NUMERIC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserNUMERIC_SYMBOL, 0)
}

func (s *Numeric_literal_prefixContext) DECIMAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserDECIMAL_SYMBOL, 0)
}

func (s *Numeric_literal_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Numeric_literal_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Numeric_literal_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterNumeric_literal_prefix(s)
	}
}

func (s *Numeric_literal_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitNumeric_literal_prefix(s)
	}
}

func (s *Numeric_literal_prefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitNumeric_literal_prefix(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Numeric_literal_prefix() (localctx INumeric_literal_prefixContext) {
	localctx = NewNumeric_literal_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, GoogleSQLParserRULE_numeric_literal_prefix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3025)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GoogleSQLParserNUMERIC_SYMBOL || _la == GoogleSQLParserDECIMAL_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInteger_literalContext is an interface to support dynamic dispatch.
type IInteger_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_LITERAL() antlr.TerminalNode

	// IsInteger_literalContext differentiates from other interfaces.
	IsInteger_literalContext()
}

type Integer_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_literalContext() *Integer_literalContext {
	var p = new(Integer_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_integer_literal
	return p
}

func InitEmptyInteger_literalContext(p *Integer_literalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_integer_literal
}

func (*Integer_literalContext) IsInteger_literalContext() {}

func NewInteger_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_literalContext {
	var p = new(Integer_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_integer_literal

	return p
}

func (s *Integer_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_literalContext) INTEGER_LITERAL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINTEGER_LITERAL, 0)
}

func (s *Integer_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Integer_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterInteger_literal(s)
	}
}

func (s *Integer_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitInteger_literal(s)
	}
}

func (s *Integer_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitInteger_literal(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Integer_literal() (localctx IInteger_literalContext) {
	localctx = NewInteger_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, GoogleSQLParserRULE_integer_literal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3027)
		p.Match(GoogleSQLParserINTEGER_LITERAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBytes_literalContext is an interface to support dynamic dispatch.
type IBytes_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Bytes_literal_component() IBytes_literal_componentContext
	Bytes_literal() IBytes_literalContext
	String_literal_component() IString_literal_componentContext

	// IsBytes_literalContext differentiates from other interfaces.
	IsBytes_literalContext()
}

type Bytes_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBytes_literalContext() *Bytes_literalContext {
	var p = new(Bytes_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_bytes_literal
	return p
}

func InitEmptyBytes_literalContext(p *Bytes_literalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_bytes_literal
}

func (*Bytes_literalContext) IsBytes_literalContext() {}

func NewBytes_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bytes_literalContext {
	var p = new(Bytes_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_bytes_literal

	return p
}

func (s *Bytes_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Bytes_literalContext) Bytes_literal_component() IBytes_literal_componentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBytes_literal_componentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBytes_literal_componentContext)
}

func (s *Bytes_literalContext) Bytes_literal() IBytes_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBytes_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBytes_literalContext)
}

func (s *Bytes_literalContext) String_literal_component() IString_literal_componentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_literal_componentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_literal_componentContext)
}

func (s *Bytes_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bytes_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bytes_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterBytes_literal(s)
	}
}

func (s *Bytes_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitBytes_literal(s)
	}
}

func (s *Bytes_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitBytes_literal(s)

	default:
		return t.VisitChildren(s)
	}
}





func (p *GoogleSQLParser) Bytes_literal() (localctx IBytes_literalContext) {
	return p.bytes_literal(0)
}

func (p *GoogleSQLParser) bytes_literal(_p int) (localctx IBytes_literalContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBytes_literalContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBytes_literalContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 582
	p.EnterRecursionRule(localctx, 582, GoogleSQLParserRULE_bytes_literal, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3030)
		p.Bytes_literal_component()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(3042)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 315, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(3040)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 314, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBytes_literalContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_bytes_literal)
				p.SetState(3032)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(3033)
					p.Bytes_literal_component()
				}

				          	 literalStopIndex, componentStartIndex := localctx.Bytes_literal().GetStop().GetStop(),
				          	 localctx.Bytes_literal_component().GetStart().GetStart() if literalStopIndex + 1 ==
				          	 componentStartIndex { p.NotifyErrorListeners("Syntax error: concatenated bytes literals must be
				          	 separated by whitespace or comments.", nil, nil) } 


			case 2:
				localctx = NewBytes_literalContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_bytes_literal)
				p.SetState(3036)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(3037)
					p.String_literal_component()
				}
				p.NotifyErrorListeners("Syntax error: string and bytes literals cannot be concatenated.", nil,
				          	 nil); 

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(3044)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 315, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INull_literalContext is an interface to support dynamic dispatch.
type INull_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL_SYMBOL() antlr.TerminalNode

	// IsNull_literalContext differentiates from other interfaces.
	IsNull_literalContext()
}

type Null_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNull_literalContext() *Null_literalContext {
	var p = new(Null_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_null_literal
	return p
}

func InitEmptyNull_literalContext(p *Null_literalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_null_literal
}

func (*Null_literalContext) IsNull_literalContext() {}

func NewNull_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Null_literalContext {
	var p = new(Null_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_null_literal

	return p
}

func (s *Null_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Null_literalContext) NULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserNULL_SYMBOL, 0)
}

func (s *Null_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Null_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Null_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterNull_literal(s)
	}
}

func (s *Null_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitNull_literal(s)
	}
}

func (s *Null_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitNull_literal(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Null_literal() (localctx INull_literalContext) {
	localctx = NewNull_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, GoogleSQLParserRULE_null_literal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3045)
		p.Match(GoogleSQLParserNULL_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBoolean_literalContext is an interface to support dynamic dispatch.
type IBoolean_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE_SYMBOL() antlr.TerminalNode
	FALSE_SYMBOL() antlr.TerminalNode

	// IsBoolean_literalContext differentiates from other interfaces.
	IsBoolean_literalContext()
}

type Boolean_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolean_literalContext() *Boolean_literalContext {
	var p = new(Boolean_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_boolean_literal
	return p
}

func InitEmptyBoolean_literalContext(p *Boolean_literalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_boolean_literal
}

func (*Boolean_literalContext) IsBoolean_literalContext() {}

func NewBoolean_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Boolean_literalContext {
	var p = new(Boolean_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_boolean_literal

	return p
}

func (s *Boolean_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Boolean_literalContext) TRUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserTRUE_SYMBOL, 0)
}

func (s *Boolean_literalContext) FALSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFALSE_SYMBOL, 0)
}

func (s *Boolean_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Boolean_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Boolean_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterBoolean_literal(s)
	}
}

func (s *Boolean_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitBoolean_literal(s)
	}
}

func (s *Boolean_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitBoolean_literal(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Boolean_literal() (localctx IBoolean_literalContext) {
	localctx = NewBoolean_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, GoogleSQLParserRULE_boolean_literal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3047)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GoogleSQLParserTRUE_SYMBOL || _la == GoogleSQLParserFALSE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IString_literalContext is an interface to support dynamic dispatch.
type IString_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	String_literal_component() IString_literal_componentContext
	String_literal() IString_literalContext
	Bytes_literal_component() IBytes_literal_componentContext

	// IsString_literalContext differentiates from other interfaces.
	IsString_literalContext()
}

type String_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_literalContext() *String_literalContext {
	var p = new(String_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_string_literal
	return p
}

func InitEmptyString_literalContext(p *String_literalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_string_literal
}

func (*String_literalContext) IsString_literalContext() {}

func NewString_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_literalContext {
	var p = new(String_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_string_literal

	return p
}

func (s *String_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *String_literalContext) String_literal_component() IString_literal_componentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_literal_componentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_literal_componentContext)
}

func (s *String_literalContext) String_literal() IString_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_literalContext)
}

func (s *String_literalContext) Bytes_literal_component() IBytes_literal_componentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBytes_literal_componentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBytes_literal_componentContext)
}

func (s *String_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *String_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterString_literal(s)
	}
}

func (s *String_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitString_literal(s)
	}
}

func (s *String_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitString_literal(s)

	default:
		return t.VisitChildren(s)
	}
}





func (p *GoogleSQLParser) String_literal() (localctx IString_literalContext) {
	return p.string_literal(0)
}

func (p *GoogleSQLParser) string_literal(_p int) (localctx IString_literalContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewString_literalContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IString_literalContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 588
	p.EnterRecursionRule(localctx, 588, GoogleSQLParserRULE_string_literal, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3050)
		p.String_literal_component()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(3062)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 317, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(3060)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 316, p.GetParserRuleContext()) {
			case 1:
				localctx = NewString_literalContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_string_literal)
				p.SetState(3052)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(3053)
					p.String_literal_component()
				}

				          	 literalStopIndex, componentStartIndex := localctx.String_literal().GetStop().GetStop(),
				          	 localctx.String_literal_component().GetStart().GetStart() if literalStopIndex + 1 ==
				          	 componentStartIndex { p.NotifyErrorListeners("Syntax error: concatenated string literals must
				          	 be separated by whitespace or comments.", nil, nil) } 


			case 2:
				localctx = NewString_literalContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoogleSQLParserRULE_string_literal)
				p.SetState(3056)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(3057)
					p.Bytes_literal_component()
				}
				p.NotifyErrorListeners("Syntax error: string and bytes literals cannot
				          	 be concatenated.", nil, nil); 

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(3064)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 317, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IString_literal_componentContext is an interface to support dynamic dispatch.
type IString_literal_componentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode

	// IsString_literal_componentContext differentiates from other interfaces.
	IsString_literal_componentContext()
}

type String_literal_componentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_literal_componentContext() *String_literal_componentContext {
	var p = new(String_literal_componentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_string_literal_component
	return p
}

func InitEmptyString_literal_componentContext(p *String_literal_componentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_string_literal_component
}

func (*String_literal_componentContext) IsString_literal_componentContext() {}

func NewString_literal_componentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_literal_componentContext {
	var p = new(String_literal_componentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_string_literal_component

	return p
}

func (s *String_literal_componentContext) GetParser() antlr.Parser { return s.parser }

func (s *String_literal_componentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserSTRING_LITERAL, 0)
}

func (s *String_literal_componentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_literal_componentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *String_literal_componentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterString_literal_component(s)
	}
}

func (s *String_literal_componentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitString_literal_component(s)
	}
}

func (s *String_literal_componentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitString_literal_component(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) String_literal_component() (localctx IString_literal_componentContext) {
	localctx = NewString_literal_componentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, GoogleSQLParserRULE_string_literal_component)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3065)
		p.Match(GoogleSQLParserSTRING_LITERAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBytes_literal_componentContext is an interface to support dynamic dispatch.
type IBytes_literal_componentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BYTES_LITERAL() antlr.TerminalNode

	// IsBytes_literal_componentContext differentiates from other interfaces.
	IsBytes_literal_componentContext()
}

type Bytes_literal_componentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBytes_literal_componentContext() *Bytes_literal_componentContext {
	var p = new(Bytes_literal_componentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_bytes_literal_component
	return p
}

func InitEmptyBytes_literal_componentContext(p *Bytes_literal_componentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_bytes_literal_component
}

func (*Bytes_literal_componentContext) IsBytes_literal_componentContext() {}

func NewBytes_literal_componentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bytes_literal_componentContext {
	var p = new(Bytes_literal_componentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_bytes_literal_component

	return p
}

func (s *Bytes_literal_componentContext) GetParser() antlr.Parser { return s.parser }

func (s *Bytes_literal_componentContext) BYTES_LITERAL() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserBYTES_LITERAL, 0)
}

func (s *Bytes_literal_componentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bytes_literal_componentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bytes_literal_componentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterBytes_literal_component(s)
	}
}

func (s *Bytes_literal_componentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitBytes_literal_component(s)
	}
}

func (s *Bytes_literal_componentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitBytes_literal_component(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Bytes_literal_component() (localctx IBytes_literal_componentContext) {
	localctx = NewBytes_literal_componentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, GoogleSQLParserRULE_bytes_literal_component)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3067)
		p.Match(GoogleSQLParserBYTES_LITERAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICountContext is an interface to support dynamic dispatch.
type ICountContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext

	// IsCountContext differentiates from other interfaces.
	IsCountContext()
}

type CountContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCountContext() *CountContext {
	var p = new(CountContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_count
	return p
}

func InitEmptyCountContext(p *CountContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_count
}

func (*CountContext) IsCountContext() {}

func NewCountContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CountContext {
	var p = new(CountContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_count

	return p
}

func (s *CountContext) GetParser() antlr.Parser { return s.parser }

func (s *CountContext) Number() INumberContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *CountContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CountContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CountContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterCount(s)
	}
}

func (s *CountContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitCount(s)
	}
}

func (s *CountContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitCount(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Count() (localctx ICountContext) {
	localctx = NewCountContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, GoogleSQLParserRULE_count)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3069)
		p.Number()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISkip_rowsContext is an interface to support dynamic dispatch.
type ISkip_rowsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext

	// IsSkip_rowsContext differentiates from other interfaces.
	IsSkip_rowsContext()
}

type Skip_rowsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkip_rowsContext() *Skip_rowsContext {
	var p = new(Skip_rowsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_skip_rows
	return p
}

func InitEmptySkip_rowsContext(p *Skip_rowsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_skip_rows
}

func (*Skip_rowsContext) IsSkip_rowsContext() {}

func NewSkip_rowsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Skip_rowsContext {
	var p = new(Skip_rowsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_skip_rows

	return p
}

func (s *Skip_rowsContext) GetParser() antlr.Parser { return s.parser }

func (s *Skip_rowsContext) Number() INumberContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *Skip_rowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Skip_rowsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Skip_rowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterSkip_rows(s)
	}
}

func (s *Skip_rowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitSkip_rows(s)
	}
}

func (s *Skip_rowsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitSkip_rows(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Skip_rows() (localctx ISkip_rowsContext) {
	localctx = NewSkip_rowsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, GoogleSQLParserRULE_skip_rows)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3071)
		p.Number()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	QUOTED_ID() antlr.TerminalNode

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_name
	return p
}

func InitEmptyNameContext(p *NameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_name
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) ID() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserID, 0)
}

func (s *NameContext) QUOTED_ID() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserQUOTED_ID, 0)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *NameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterName(s)
	}
}

func (s *NameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitName(s)
	}
}

func (s *NameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Name() (localctx INameContext) {
	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, GoogleSQLParserRULE_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3073)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GoogleSQLParserQUOTED_ID || _la == GoogleSQLParserID) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICte_nameContext is an interface to support dynamic dispatch.
type ICte_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsCte_nameContext differentiates from other interfaces.
	IsCte_nameContext()
}

type Cte_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCte_nameContext() *Cte_nameContext {
	var p = new(Cte_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_cte_name
	return p
}

func InitEmptyCte_nameContext(p *Cte_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_cte_name
}

func (*Cte_nameContext) IsCte_nameContext() {}

func NewCte_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cte_nameContext {
	var p = new(Cte_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_cte_name

	return p
}

func (s *Cte_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Cte_nameContext) Name() INameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Cte_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cte_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Cte_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterCte_name(s)
	}
}

func (s *Cte_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitCte_name(s)
	}
}

func (s *Cte_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitCte_name(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Cte_name() (localctx ICte_nameContext) {
	localctx = NewCte_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, GoogleSQLParserRULE_cte_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3075)
		p.Name()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumn_nameContext is an interface to support dynamic dispatch.
type IColumn_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsColumn_nameContext differentiates from other interfaces.
	IsColumn_nameContext()
}

type Column_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_nameContext() *Column_nameContext {
	var p = new(Column_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_column_name
	return p
}

func InitEmptyColumn_nameContext(p *Column_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_column_name
}

func (*Column_nameContext) IsColumn_nameContext() {}

func NewColumn_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_nameContext {
	var p = new(Column_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_column_name

	return p
}

func (s *Column_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_nameContext) Name() INameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Column_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Column_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterColumn_name(s)
	}
}

func (s *Column_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitColumn_name(s)
	}
}

func (s *Column_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitColumn_name(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Column_name() (localctx IColumn_nameContext) {
	localctx = NewColumn_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, GoogleSQLParserRULE_column_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3077)
		p.Name()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlias_nameContext is an interface to support dynamic dispatch.
type IAlias_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsAlias_nameContext differentiates from other interfaces.
	IsAlias_nameContext()
}

type Alias_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlias_nameContext() *Alias_nameContext {
	var p = new(Alias_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_alias_name
	return p
}

func InitEmptyAlias_nameContext(p *Alias_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_alias_name
}

func (*Alias_nameContext) IsAlias_nameContext() {}

func NewAlias_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alias_nameContext {
	var p = new(Alias_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_alias_name

	return p
}

func (s *Alias_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Alias_nameContext) Name() INameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Alias_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alias_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alias_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterAlias_name(s)
	}
}

func (s *Alias_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitAlias_name(s)
	}
}

func (s *Alias_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitAlias_name(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Alias_name() (localctx IAlias_nameContext) {
	localctx = NewAlias_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, GoogleSQLParserRULE_alias_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3079)
		p.Name()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_nameContext is an interface to support dynamic dispatch.
type ITable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsTable_nameContext differentiates from other interfaces.
	IsTable_nameContext()
}

type Table_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_nameContext() *Table_nameContext {
	var p = new(Table_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_table_name
	return p
}

func InitEmptyTable_nameContext(p *Table_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_table_name
}

func (*Table_nameContext) IsTable_nameContext() {}

func NewTable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_nameContext {
	var p = new(Table_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_table_name

	return p
}

func (s *Table_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_nameContext) Name() INameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Table_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterTable_name(s)
	}
}

func (s *Table_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitTable_name(s)
	}
}

func (s *Table_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitTable_name(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Table_name() (localctx ITable_nameContext) {
	localctx = NewTable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, GoogleSQLParserRULE_table_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3081)
		p.Name()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Integer_type() IInteger_typeContext
	Float_type() IFloat_typeContext

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_number
	return p
}

func InitEmptyNumberContext(p *NumberContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_number
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) Integer_type() IInteger_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInteger_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInteger_typeContext)
}

func (s *NumberContext) Float_type() IFloat_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloat_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloat_typeContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *NumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterNumber(s)
	}
}

func (s *NumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitNumber(s)
	}
}

func (s *NumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitNumber(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, GoogleSQLParserRULE_number)
	p.SetState(3085)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoogleSQLParserINT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3083)
			p.Integer_type()
		}


	case GoogleSQLParserFLOAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3084)
			p.Float_type()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInteger_typeContext is an interface to support dynamic dispatch.
type IInteger_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INT() antlr.TerminalNode

	// IsInteger_typeContext differentiates from other interfaces.
	IsInteger_typeContext()
}

type Integer_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_typeContext() *Integer_typeContext {
	var p = new(Integer_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_integer_type
	return p
}

func InitEmptyInteger_typeContext(p *Integer_typeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_integer_type
}

func (*Integer_typeContext) IsInteger_typeContext() {}

func NewInteger_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_typeContext {
	var p = new(Integer_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_integer_type

	return p
}

func (s *Integer_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_typeContext) INT() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserINT, 0)
}

func (s *Integer_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Integer_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterInteger_type(s)
	}
}

func (s *Integer_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitInteger_type(s)
	}
}

func (s *Integer_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitInteger_type(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Integer_type() (localctx IInteger_typeContext) {
	localctx = NewInteger_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, GoogleSQLParserRULE_integer_type)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3087)
		p.Match(GoogleSQLParserINT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFloat_typeContext is an interface to support dynamic dispatch.
type IFloat_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOAT() antlr.TerminalNode

	// IsFloat_typeContext differentiates from other interfaces.
	IsFloat_typeContext()
}

type Float_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloat_typeContext() *Float_typeContext {
	var p = new(Float_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_float_type
	return p
}

func InitEmptyFloat_typeContext(p *Float_typeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoogleSQLParserRULE_float_type
}

func (*Float_typeContext) IsFloat_typeContext() {}

func NewFloat_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Float_typeContext {
	var p = new(Float_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoogleSQLParserRULE_float_type

	return p
}

func (s *Float_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Float_typeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(GoogleSQLParserFLOAT, 0)
}

func (s *Float_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Float_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Float_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.EnterFloat_type(s)
	}
}

func (s *Float_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoogleSQLParserListener); ok {
		listenerT.ExitFloat_type(s)
	}
}

func (s *Float_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoogleSQLParserVisitor:
		return t.VisitFloat_type(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoogleSQLParser) Float_type() (localctx IFloat_typeContext) {
	localctx = NewFloat_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, GoogleSQLParserRULE_float_type)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3089)
		p.Match(GoogleSQLParserFLOAT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


func (p *GoogleSQLParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 12:
			var t *Query_set_operation_prefixContext = nil
			if localctx != nil { t = localctx.(*Query_set_operation_prefixContext) }
			return p.Query_set_operation_prefix_Sempred(t, predIndex)

	case 21:
			var t *With_clauseContext = nil
			if localctx != nil { t = localctx.(*With_clauseContext) }
			return p.With_clause_Sempred(t, predIndex)

	case 49:
			var t *From_clause_contentsContext = nil
			if localctx != nil { t = localctx.(*From_clause_contentsContext) }
			return p.From_clause_contents_Sempred(t, predIndex)

	case 50:
			var t *Table_primaryContext = nil
			if localctx != nil { t = localctx.(*Table_primaryContext) }
			return p.Table_primary_Sempred(t, predIndex)

	case 63:
			var t *Row_pattern_exprContext = nil
			if localctx != nil { t = localctx.(*Row_pattern_exprContext) }
			return p.Row_pattern_expr_Sempred(t, predIndex)

	case 64:
			var t *Row_pattern_concatenationContext = nil
			if localctx != nil { t = localctx.(*Row_pattern_concatenationContext) }
			return p.Row_pattern_concatenation_Sempred(t, predIndex)

	case 81:
			var t *Dashed_path_expressionContext = nil
			if localctx != nil { t = localctx.(*Dashed_path_expressionContext) }
			return p.Dashed_path_expression_Sempred(t, predIndex)

	case 82:
			var t *Dashed_identifierContext = nil
			if localctx != nil { t = localctx.(*Dashed_identifierContext) }
			return p.Dashed_identifier_Sempred(t, predIndex)

	case 83:
			var t *Slashed_identifierContext = nil
			if localctx != nil { t = localctx.(*Slashed_identifierContext) }
			return p.Slashed_identifier_Sempred(t, predIndex)

	case 103:
			var t *Unpivot_in_item_list_prefixContext = nil
			if localctx != nil { t = localctx.(*Unpivot_in_item_list_prefixContext) }
			return p.Unpivot_in_item_list_prefix_Sempred(t, predIndex)

	case 130:
			var t *From_itemContext = nil
			if localctx != nil { t = localctx.(*From_itemContext) }
			return p.From_item_Sempred(t, predIndex)

	case 157:
			var t *ExpressionContext = nil
			if localctx != nil { t = localctx.(*ExpressionContext) }
			return p.Expression_Sempred(t, predIndex)

	case 227:
			var t *Generalized_path_expressionContext = nil
			if localctx != nil { t = localctx.(*Generalized_path_expressionContext) }
			return p.Generalized_path_expression_Sempred(t, predIndex)

	case 245:
			var t *Braced_constructor_prefixContext = nil
			if localctx != nil { t = localctx.(*Braced_constructor_prefixContext) }
			return p.Braced_constructor_prefix_Sempred(t, predIndex)

	case 273:
			var t *Path_expressionContext = nil
			if localctx != nil { t = localctx.(*Path_expressionContext) }
			return p.Path_expression_Sempred(t, predIndex)

	case 291:
			var t *Bytes_literalContext = nil
			if localctx != nil { t = localctx.(*Bytes_literalContext) }
			return p.Bytes_literal_Sempred(t, predIndex)

	case 294:
			var t *String_literalContext = nil
			if localctx != nil { t = localctx.(*String_literalContext) }
			return p.String_literal_Sempred(t, predIndex)


	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *GoogleSQLParser) Query_set_operation_prefix_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
			return p.Precpred(p.GetParserRuleContext(), 3)

	case 1:
			return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GoogleSQLParser) With_clause_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
			return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GoogleSQLParser) From_clause_contents_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
			return p.Precpred(p.GetParserRuleContext(), 5)

	case 4:
			return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GoogleSQLParser) Table_primary_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
			return p.Precpred(p.GetParserRuleContext(), 2)

	case 6:
			return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GoogleSQLParser) Row_pattern_expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
			return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GoogleSQLParser) Row_pattern_concatenation_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
			return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GoogleSQLParser) Dashed_path_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
			return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GoogleSQLParser) Dashed_identifier_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
			return p.Precpred(p.GetParserRuleContext(), 5)

	case 11:
			return p.Precpred(p.GetParserRuleContext(), 3)

	case 12:
			return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GoogleSQLParser) Slashed_identifier_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 13:
			return p.Precpred(p.GetParserRuleContext(), 2)

	case 14:
			return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GoogleSQLParser) Unpivot_in_item_list_prefix_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 15:
			return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GoogleSQLParser) From_item_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 16:
			return p.Precpred(p.GetParserRuleContext(), 6)

	case 17:
			return p.Precpred(p.GetParserRuleContext(), 5)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GoogleSQLParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 18:
			return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GoogleSQLParser) Generalized_path_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 19:
			return p.Precpred(p.GetParserRuleContext(), 3)

	case 20:
			return p.Precpred(p.GetParserRuleContext(), 2)

	case 21:
			return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GoogleSQLParser) Braced_constructor_prefix_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 22:
			return p.Precpred(p.GetParserRuleContext(), 3)

	case 23:
			return p.Precpred(p.GetParserRuleContext(), 2)

	case 24:
			return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GoogleSQLParser) Path_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 25:
			return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GoogleSQLParser) Bytes_literal_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 26:
			return p.Precpred(p.GetParserRuleContext(), 2)

	case 27:
			return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GoogleSQLParser) String_literal_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 28:
			return p.Precpred(p.GetParserRuleContext(), 2)

	case 29:
			return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

